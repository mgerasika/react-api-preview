{"ast":null,"code":"import { objectSpread2 as _objectSpread2, toArray as _toArray, toConsumableArray as _toConsumableArray } from '../_virtual/_rollupPluginBabelHelpers.js';\nimport { createCollection, getItem, deleteFromCollection, addToCollection, updateCollection } from './create-collection.util.js';\nfunction createInfiniteCollection(data, next_page, request) {\n  return {\n    pageParams: [0],\n    pages: [createCollection(data, next_page, request)]\n  };\n}\nfunction deleteFromInfiniteCollection(data, id) {\n  if (!data) {\n    return createInfiniteCollection([], 0, {});\n  }\n  return _objectSpread2(_objectSpread2({}, data), {}, {\n    pages: data.pages.map(function (page) {\n      if (getItem(page, id)) {\n        return deleteFromCollection(page, id);\n      }\n      return page;\n    })\n  });\n}\n\n// TODO implement\nfunction addToInfiniteCollection(data, item) {\n  if (!data) {\n    return createInfiniteCollection([item], 0, {});\n  }\n  var _data$pages = _toArray(data.pages),\n    first = _data$pages[0],\n    rest = _data$pages.slice(1);\n  return _objectSpread2(_objectSpread2({}, data), {}, {\n    pages: [addToCollection(first, item)].concat(_toConsumableArray(rest))\n  });\n}\n\n// TODO implement\nfunction updateInfiniteCollection(data, id, newItem) {\n  if (!data) {\n    return createInfiniteCollection([newItem], 0, {});\n  }\n  return _objectSpread2(_objectSpread2({}, data), {}, {\n    pages: data.pages.map(function (page) {\n      if (getItem(page, id)) {\n        return updateCollection(page, id, newItem);\n      }\n      return page;\n    })\n  });\n}\nexport { addToInfiniteCollection, createInfiniteCollection, deleteFromInfiniteCollection, updateInfiniteCollection };","map":{"version":3,"sources":["../../../src/utils/create-infinite-collection.util.ts"],"names":["createInfiniteCollection","data","next_page","request","pageParams","pages","createCollection","deleteFromInfiniteCollection","id","map","page","getItem","deleteFromCollection","addToInfiniteCollection","item","first","rest","addToCollection","updateInfiniteCollection","newItem","updateCollection"],"mappings":";;AAYO,SAASA,wBAAwB,CACpCC,IAAqB,EACrBC,SAA6B,EAC7BC,OAAsE,EAChD;EACtB,OAAO;IACHC,UAAU,EAAE,CAAC,CAAC,CAAC;IACfC,KAAK,EAAE,CAACC,gBAAgB,CAACL,IAAI,EAAEC,SAAS,EAAEC,OAAO,CAAC;GACrD;AACL;AAEO,SAASI,4BAA4B,CACxCN,IAAwC,EACxCO,EAAO,EACe;EACtB,IAAI,CAACP,IAAI,EAAE;IACP,OAAOD,wBAAwB,CAAC,EAAE,EAAE,CAAC,EAAE,CAAE,CAAA,CAAC;EAC9C;EACA,OAAA,cAAA,CAAA,cAAA,CAAA,CAAA,CAAA,EACOC,IAAI,CAAA,EAAA,CAAA,CAAA,EAAA;IACPI,KAAK,EAAEJ,IAAI,CAACI,KAAK,CAACI,GAAG,CAAC,UAACC,IAAI,EAAK;MAC5B,IAAIC,OAAO,CAACD,IAAI,EAAEF,EAAE,CAAC,EAAE;QACnB,OAAOI,oBAAoB,CAACF,IAAI,EAAEF,EAAE,CAAC;MACzC;MACA,OAAOE,IAAI;KACd;EAAC,CAAA,CAAA;AAEV;;AAEA;AACO,SAASG,uBAAuB,CACnCZ,IAAwC,EACxCa,IAAO,EACe;EACtB,IAAI,CAACb,IAAI,EAAE;IACP,OAAOD,wBAAwB,CAAC,CAACc,IAAI,CAAC,EAAE,CAAC,EAAE,CAAE,CAAA,CAAC;EAClD;EACA,IAAyBb,WAAAA,GAAAA,QAAAA,CAAAA,IAAI,CAACI,KAAK,CAAA;IAA5BU,KAAK,GAAA,WAAA,CAAA,CAAA,CAAA;IAAKC,IAAI,GAAA,WAAA,CAAA,KAAA,CAAA,CAAA,CAAA;EACrB,OAAA,cAAA,CAAA,cAAA,CAAA,CAAA,CAAA,EACOf,IAAI,CAAA,EAAA,CAAA,CAAA,EAAA;IACPI,KAAK,EAAA,CAAGY,eAAe,CAACF,KAAK,EAAED,IAAI,CAAC,CAAA,CAAA,MAAA,CAAA,kBAAA,CAAKE,IAAI,CAAA;EAAC,CAAA,CAAA;AAEtD;;AAEA;AACO,SAASE,wBAAwB,CACpCjB,IAAwC,EACxCO,EAAO,EACPW,OAAU,EACY;EACtB,IAAI,CAAClB,IAAI,EAAE;IACP,OAAOD,wBAAwB,CAAC,CAACmB,OAAO,CAAC,EAAE,CAAC,EAAE,CAAE,CAAA,CAAC;EACrD;EACA,OAAA,cAAA,CAAA,cAAA,CAAA,CAAA,CAAA,EACOlB,IAAI,CAAA,EAAA,CAAA,CAAA,EAAA;IACPI,KAAK,EAAEJ,IAAI,CAACI,KAAK,CAACI,GAAG,CAAC,UAACC,IAAI,EAAK;MAC5B,IAAIC,OAAO,CAACD,IAAI,EAAEF,EAAE,CAAC,EAAE;QACnB,OAAOY,gBAAgB,CAACV,IAAI,EAAEF,EAAE,EAAEW,OAAO,CAAC;MAC9C;MACA,OAAOT,IAAI;KACd;EAAC,CAAA,CAAA;AAEV","sourcesContent":["import { ICollectionRequestOptions } from '@common/interfaces/collection-request-options.interface';\nimport { IIdObject } from '@common/interfaces/id-object.interface';\nimport { IInfiniteCollection } from '@common/interfaces/infinite-collection.interface';\nimport { UID } from '@common/interfaces/uid.interface';\nimport {\n    addToCollection,\n    createCollection,\n    deleteFromCollection,\n    getItem,\n    updateCollection,\n} from './create-collection.util';\n\nexport function createInfiniteCollection<T>(\n    data: T[] | undefined,\n    next_page: number | undefined,\n    request: Omit<ICollectionRequestOptions, 'limit'> & { limit?: number },\n): IInfiniteCollection<T> {\n    return {\n        pageParams: [0],\n        pages: [createCollection(data, next_page, request)],\n    };\n}\n\nexport function deleteFromInfiniteCollection<T extends IIdObject>(\n    data: IInfiniteCollection<T> | undefined,\n    id: UID,\n): IInfiniteCollection<T> {\n    if (!data) {\n        return createInfiniteCollection([], 0, {});\n    }\n    return {\n        ...data,\n        pages: data.pages.map((page) => {\n            if (getItem(page, id)) {\n                return deleteFromCollection(page, id);\n            }\n            return page;\n        }),\n    };\n}\n\n// TODO implement\nexport function addToInfiniteCollection<T extends IIdObject>(\n    data: IInfiniteCollection<T> | undefined,\n    item: T,\n): IInfiniteCollection<T> {\n    if (!data) {\n        return createInfiniteCollection([item], 0, {});\n    }\n    const [first, ...rest] = data.pages;\n    return {\n        ...data,\n        pages: [addToCollection(first, item), ...rest],\n    };\n}\n\n// TODO implement\nexport function updateInfiniteCollection<T extends IIdObject>(\n    data: IInfiniteCollection<T> | undefined,\n    id: UID,\n    newItem: T,\n): IInfiniteCollection<T> {\n    if (!data) {\n        return createInfiniteCollection([newItem], 0, {});\n    }\n    return {\n        ...data,\n        pages: data.pages.map((page) => {\n            if (getItem(page, id)) {\n                return updateCollection(page, id, newItem);\n            }\n            return page;\n        }),\n    };\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getExtensionDescription = getExtensionDescription;\nexports.ExplorerBase = void 0;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _loaders = require(\"./loaders\");\nvar _getPropertyByPath = require(\"./getPropertyByPath\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass ExplorerBase {\n  constructor(options) {\n    if (options.cache === true) {\n      this.loadCache = new Map();\n      this.searchCache = new Map();\n    }\n    this.config = options;\n    this.validateConfig();\n  }\n  clearLoadCache() {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n  }\n  clearSearchCache() {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n  }\n  clearCaches() {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n  validateConfig() {\n    const config = this.config;\n    config.searchPlaces.forEach(place => {\n      const loaderKey = _path.default.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n      if (!loader) {\n        throw new Error(`No loader specified for ${getExtensionDescription(place)}, so searchPlaces item \"${place}\" is invalid`);\n      }\n      if (typeof loader !== 'function') {\n        throw new Error(`loader for ${getExtensionDescription(place)} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`);\n      }\n    });\n  }\n  shouldSearchStopWithResult(result) {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n  nextDirectoryToSearch(currentDir, currentResult) {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n    const nextDir = nextDirUp(currentDir);\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n    return nextDir;\n  }\n  loadPackageProp(filepath, content) {\n    const parsedContent = _loaders.loaders.loadJson(filepath, content);\n    const packagePropValue = (0, _getPropertyByPath.getPropertyByPath)(parsedContent, this.config.packageProp);\n    return packagePropValue || null;\n  }\n  getLoaderEntryForFile(filepath) {\n    if (_path.default.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return loader;\n    }\n    const loaderKey = _path.default.extname(filepath) || 'noExt';\n    const loader = this.config.loaders[loaderKey];\n    if (!loader) {\n      throw new Error(`No loader specified for ${getExtensionDescription(filepath)}`);\n    }\n    return loader;\n  }\n  loadedContentToCosmiconfigResult(filepath, loadedContent) {\n    if (loadedContent === null) {\n      return null;\n    }\n    if (loadedContent === undefined) {\n      return {\n        filepath,\n        config: undefined,\n        isEmpty: true\n      };\n    }\n    return {\n      config: loadedContent,\n      filepath\n    };\n  }\n  validateFilePath(filepath) {\n    if (!filepath) {\n      throw new Error('load must pass a non-empty string');\n    }\n  }\n}\nexports.ExplorerBase = ExplorerBase;\nfunction nextDirUp(dir) {\n  return _path.default.dirname(dir);\n}\nfunction getExtensionDescription(filepath) {\n  const ext = _path.default.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}","map":{"version":3,"sources":["../src/ExplorerBase.ts"],"names":["ExplorerBase","constructor","options","cache","loadCache","Map","searchCache","config","validateConfig","clearLoadCache","clear","clearSearchCache","clearCaches","searchPlaces","forEach","place","loaderKey","path","extname","loader","loaders","Error","getExtensionDescription","shouldSearchStopWithResult","result","isEmpty","ignoreEmptySearchPlaces","nextDirectoryToSearch","currentDir","currentResult","nextDir","nextDirUp","stopDir","loadPackageProp","filepath","content","parsedContent","loadJson","packagePropValue","packageProp","getLoaderEntryForFile","basename","bind","loadedContentToCosmiconfigResult","loadedContent","undefined","validateFilePath","dir","dirname","ext"],"mappings":"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","sourcesContent":["import path from 'path';\nimport { loaders } from './loaders';\nimport { getPropertyByPath } from './getPropertyByPath';\nimport {\n  CosmiconfigResult,\n  ExplorerOptions,\n  ExplorerOptionsSync,\n  Cache,\n  LoadedFileContent,\n} from './types';\nimport { Loader } from './index';\n\nclass ExplorerBase<T extends ExplorerOptions | ExplorerOptionsSync> {\n  protected readonly loadCache?: Cache;\n  protected readonly searchCache?: Cache;\n  protected readonly config: T;\n\n  public constructor(options: T) {\n    if (options.cache === true) {\n      this.loadCache = new Map();\n      this.searchCache = new Map();\n    }\n\n    this.config = options;\n    this.validateConfig();\n  }\n\n  public clearLoadCache(): void {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n  }\n\n  public clearSearchCache(): void {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n  }\n\n  public clearCaches(): void {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  private validateConfig(): void {\n    const config = this.config;\n\n    config.searchPlaces.forEach((place): void => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n      if (!loader) {\n        throw new Error(\n          `No loader specified for ${getExtensionDescription(\n            place,\n          )}, so searchPlaces item \"${place}\" is invalid`,\n        );\n      }\n\n      if (typeof loader !== 'function') {\n        throw new Error(\n          `loader for ${getExtensionDescription(\n            place,\n          )} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`,\n        );\n      }\n    });\n  }\n\n  protected shouldSearchStopWithResult(result: CosmiconfigResult): boolean {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  protected nextDirectoryToSearch(\n    currentDir: string,\n    currentResult: CosmiconfigResult,\n  ): string | null {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n    const nextDir = nextDirUp(currentDir);\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n    return nextDir;\n  }\n\n  private loadPackageProp(filepath: string, content: string): unknown {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(\n      parsedContent,\n      this.config.packageProp,\n    );\n    return packagePropValue || null;\n  }\n\n  protected getLoaderEntryForFile(filepath: string): Loader {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return loader;\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n\n    const loader = this.config.loaders[loaderKey];\n\n    if (!loader) {\n      throw new Error(\n        `No loader specified for ${getExtensionDescription(filepath)}`,\n      );\n    }\n\n    return loader;\n  }\n\n  protected loadedContentToCosmiconfigResult(\n    filepath: string,\n    loadedContent: LoadedFileContent,\n  ): CosmiconfigResult {\n    if (loadedContent === null) {\n      return null;\n    }\n    if (loadedContent === undefined) {\n      return { filepath, config: undefined, isEmpty: true };\n    }\n    return { config: loadedContent, filepath };\n  }\n\n  protected validateFilePath(filepath: string): void {\n    if (!filepath) {\n      throw new Error('load must pass a non-empty string');\n    }\n  }\n}\n\nfunction nextDirUp(dir: string): string {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath: string): string {\n  const ext = path.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}\n\nexport { ExplorerBase, getExtensionDescription };\n"]},"metadata":{},"sourceType":"script"}
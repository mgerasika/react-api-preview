{"ast":null,"code":"import { CONST } from '../constants/const.constant.js';\nimport { FormAdditionalContext } from '../general-ui/form/form.component.js';\nimport { useContext, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { useFormContext } from 'react-hook-form';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// Why use this code instead register method -> forwardRef problem with antd - works ok with native inputs but with antd have troubles - manually fire event.\n// also discussion about problem with ref https://stackoverflow.com/questions/58703615/react-hook-form-with-antd-styling\nconst useField = _ref => {\n  let {\n    name,\n    getCustomErrorMessage,\n    ...rest\n  } = _ref;\n  const formContext = useFormContext();\n  const {\n    formState: {\n      errors: fieldsErrors,\n      touchedFields\n    },\n    register,\n    // onChange, onBlur, name, ref!!!\n    unregister,\n    watch,\n    trigger,\n    setValue\n  } = formContext;\n  const formAdditionalContext = useContext(FormAdditionalContext);\n  const registerProps = register(name, {\n    ...rest,\n    ...(getCustomErrorMessage ? getCustomErrorMessage(getDefaultValidationMessages(rest)) : getDefaultValidationMessages(rest))\n  });\n  const {\n    onFieldBlur,\n    onFieldChange,\n    registerBlurHandler\n  } = formAdditionalContext;\n  const {\n    onBlur\n  } = registerProps;\n  useEffect(() => {\n    registerBlurHandler(name, onBlur);\n  }, [registerBlurHandler, name, onBlur]);\n  const fieldValue = watch(name);\n  const valueRef = useRef(fieldValue);\n  valueRef.current = fieldValue;\n  useEffect(() => {\n    return () => unregister(name);\n  }, [name, unregister]);\n  const triggerValidate = useCallback(() => {\n    trigger(name);\n  }, [trigger, name]);\n  const setFieldValue = useCallback(newValue => {\n    if (valueRef.current !== newValue) {\n      valueRef.current = newValue;\n      setValue(name, newValue);\n      onFieldChange(name);\n    }\n  }, [name, onFieldChange, setValue]);\n  const setFieldTouched = useCallback(() => {\n    // don't forget pass name to onBlur event. If missed - touched don't work correctly\n    // if call manually - don't forget add type='blur'\n    onBlur({\n      type: 'blur',\n      target: {\n        name,\n        value: valueRef.current\n      }\n    });\n    if (valueRef.current && typeof valueRef.current === 'string') {\n      setValue(name, valueRef.current.trim());\n    }\n    onFieldBlur(name);\n  }, [name, onBlur, onFieldBlur, setValue]);\n  const fieldError = fieldsErrors[name];\n  const fieldIsTouched = touchedFields ? touchedFields[name] : false;\n  const fieldErrorMessage = fieldIsTouched && fieldError?.type ? fieldError.message : undefined;\n  return useMemo(() => {\n    return {\n      value: fieldValue,\n      triggerValidate,\n      setFieldValue,\n      setFieldTouched,\n      errorMessage: fieldErrorMessage\n    };\n  }, [fieldValue, triggerValidate, setFieldValue, setFieldTouched, fieldErrorMessage]);\n};\nconst getDefaultValidationMessages = _ref2 => {\n  let {\n    required,\n    minLength,\n    maxLength,\n    min,\n    max\n  } = _ref2;\n  const result = {};\n  if (required) {\n    result.required = CONST.thisFieldRequired;\n  }\n  if (maxLength !== undefined && maxLength > 0) {\n    result.maxLength = {\n      value: maxLength,\n      message: `This field too long (at least ${maxLength} characters)`\n    };\n  }\n  if (max !== undefined && max > 0) {\n    result.max = {\n      value: max,\n      message: `This number too big (max ${max})`\n    };\n  }\n  if (min !== undefined) {\n    result.min = {\n      value: min,\n      message: `This number too short (min ${min})`\n    };\n  }\n  if (minLength !== undefined && minLength > 0) {\n    result.minLength = {\n      value: minLength,\n      message: `This field too short (at least ${minLength} characters)`\n    };\n  }\n  result.pattern = {\n    value: /^[/`/\\t/\\n/\\r a-zA-Z0-9/[/$/€/&/+/,/:/;/”/“/=/?/@/#/|/'/</>/./^/*/(/)/%/!/\\\\//{/}///-/\"/'_\\]\\-~£]*$/g,\n    message: 'Only latin symbols allowed'\n  };\n  return result;\n};\nexport { useField };","map":{"version":3,"sources":["../../../src/hooks/use-field.hook.ts"],"names":["useField","name","getCustomErrorMessage","rest","formContext","useFormContext","formState","errors","fieldsErrors","touchedFields","register","unregister","watch","trigger","setValue","formAdditionalContext","useContext","FormAdditionalContext","registerProps","getDefaultValidationMessages","onFieldBlur","onFieldChange","registerBlurHandler","onBlur","useEffect","fieldValue","valueRef","useRef","current","triggerValidate","useCallback","setFieldValue","newValue","setFieldTouched","type","target","value","trim","fieldError","fieldIsTouched","fieldErrorMessage","message","undefined","useMemo","errorMessage","required","minLength","maxLength","min","max","result","CONST","thisFieldRequired","pattern"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { CONST } from '@common/constants/const.constant';\nimport { FormAdditionalContext, IFormAdditionalContextProps } from '@common/general-ui/form/form.component';\nimport { IDictionary } from '@common/interfaces/dictionary.interface';\nimport { useCallback, useContext, useEffect, useMemo, useRef } from 'react';\nimport { RegisterOptions, useFormContext, ValidationRule } from 'react-hook-form';\n\ninterface IUseFieldReturn<T> {\n    errorMessage: string | undefined;\n    setFieldValue: (newValue: T) => void;\n    setFieldTouched: () => void;\n    triggerValidate: () => void;\n    value: T;\n}\n\ninterface IProps extends RegisterOptions {\n    name: any;\n    getCustomErrorMessage: ((opts: RegisterOptions) => RegisterOptions) | undefined;\n}\n\n// Why use this code instead register method -> forwardRef problem with antd - works ok with native inputs but with antd have troubles - manually fire event.\n// also discussion about problem with ref https://stackoverflow.com/questions/58703615/react-hook-form-with-antd-styling\nexport const useField = <T>({ name, getCustomErrorMessage, ...rest }: IProps): IUseFieldReturn<T> => {\n    const formContext = useFormContext<T>();\n    const {\n        formState: { errors: fieldsErrors, touchedFields },\n        register, // onChange, onBlur, name, ref!!!\n        unregister,\n        watch,\n        trigger,\n        setValue,\n    } = formContext;\n\n    const formAdditionalContext = useContext<IFormAdditionalContextProps<any>>(FormAdditionalContext);\n    const registerProps = register(name, {\n        ...rest,\n        ...(getCustomErrorMessage\n            ? getCustomErrorMessage(getDefaultValidationMessages(rest))\n            : getDefaultValidationMessages(rest)),\n    });\n\n    const { onFieldBlur, onFieldChange, registerBlurHandler } = formAdditionalContext;\n    const { onBlur } = registerProps;\n    useEffect(() => {\n        registerBlurHandler(name, onBlur);\n    }, [registerBlurHandler, name, onBlur]);\n\n    const fieldValue = watch(name);\n    const valueRef = useRef<any>(fieldValue);\n    valueRef.current = fieldValue;\n\n    useEffect(() => {\n        return (): void => unregister(name);\n    }, [name, unregister]);\n    const triggerValidate = useCallback(() => {\n        trigger(name);\n    }, [trigger, name]);\n\n    const setFieldValue = useCallback(\n        (newValue: T) => {\n            if (valueRef.current !== newValue) {\n                valueRef.current = newValue;\n                setValue(name, newValue as any);\n                onFieldChange(name as string);\n            }\n        },\n        [name, onFieldChange, setValue],\n    );\n\n    const setFieldTouched = useCallback(() => {\n        // don't forget pass name to onBlur event. If missed - touched don't work correctly\n        // if call manually - don't forget add type='blur'\n        onBlur({\n            type: 'blur',\n            target: {\n                name,\n                value: valueRef.current,\n            },\n        });\n        if (valueRef.current && typeof valueRef.current === 'string') {\n            setValue(name, (valueRef.current as any).trim());\n        }\n        onFieldBlur(name as string);\n    }, [name, onBlur, onFieldBlur, setValue]);\n\n    const fieldError = (fieldsErrors as IDictionary<any>)[name];\n    const fieldIsTouched = touchedFields ? (touchedFields as IDictionary<any>)[name] : false;\n    const fieldErrorMessage = fieldIsTouched && fieldError?.type ? fieldError.message : undefined;\n    return useMemo(() => {\n        return {\n            value: fieldValue as T,\n            triggerValidate,\n            setFieldValue,\n            setFieldTouched,\n\n            errorMessage: fieldErrorMessage,\n        };\n    }, [fieldValue, triggerValidate, setFieldValue, setFieldTouched, fieldErrorMessage]);\n};\n\nconst getDefaultValidationMessages = ({ required, minLength, maxLength, min, max }: RegisterOptions): RegisterOptions => {\n    const result: RegisterOptions = {} as RegisterOptions;\n    if (required) {\n        result.required = CONST.thisFieldRequired;\n    }\n    if (maxLength !== undefined && maxLength > 0) {\n        result.maxLength = {\n            value: maxLength,\n            message: `This field too long (at least ${maxLength} characters)`,\n        } as ValidationRule<number>;\n    }\n    if (max !== undefined && max > 0) {\n        result.max = {\n            value: max,\n            message: `This number too big (max ${max})`,\n        } as ValidationRule<number>;\n    }\n    if (min !== undefined) {\n        result.min = {\n            value: min,\n            message: `This number too short (min ${min})`,\n        } as ValidationRule<number>;\n    }\n    if (minLength !== undefined && minLength > 0) {\n        result.minLength = {\n            value: minLength,\n            message: `This field too short (at least ${minLength} characters)`,\n        } as ValidationRule<number>;\n    }\n    result.pattern = {\n        value: /^[/`/\\t/\\n/\\r a-zA-Z0-9/[/$/€/&/+/,/:/;/”/“/=/?/@/#/|/'/</>/./^/*/(/)/%/!/\\\\//{/}///-/\"/'_\\]\\-~£]*$/g,\n        message: 'Only latin symbols allowed',\n    };\n    return result;\n};\n"]},"metadata":{},"sourceType":"module"}
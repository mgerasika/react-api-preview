{"ast":null,"code":"import { t } from '@common/hooks/use-t.hook';\nimport { generateId } from '@common/utils/generate-id.util';\nimport dayjs from 'dayjs';\nimport { formatDate } from './format-date.util.js';\nimport { getNow } from './now.util.js';\nimport { throwException } from './throw-exception.util.js';\nlet ECalendarEventType;\n(function (ECalendarEventType) {\n  ECalendarEventType[\"subscription\"] = \"subscription\";\n  ECalendarEventType[\"order\"] = \"order\";\n})(ECalendarEventType || (ECalendarEventType = {}));\nconst getStep = _ref => {\n  let {\n    billing_period,\n    billing_period_unit,\n    isNewSubscription\n  } = _ref;\n  if (billing_period_unit === 'week') {\n    return isNewSubscription ? 7 * Math.min(1, billing_period) : 7 * billing_period;\n  } else if (billing_period_unit === 'day') {\n    return billing_period;\n  }\n  throwException('Not implemented (get step)');\n};\nlet EUpcomingDeliverySubType;\n(function (EUpcomingDeliverySubType) {\n  EUpcomingDeliverySubType[\"upcomingDelivery\"] = \"upcomingDelivery\";\n  EUpcomingDeliverySubType[\"pause\"] = \"pause\";\n  EUpcomingDeliverySubType[\"skippedButPauseRemoved\"] = \"skippedButPauseRemoved\";\n  EUpcomingDeliverySubType[\"blockedForUpdate\"] = \"blockedForUpdate\";\n})(EUpcomingDeliverySubType || (EUpcomingDeliverySubType = {}));\nconst isSameOrAfter = (day1, day2) => {\n  return day1.isSame(day2, 'days') || day1.isAfter(day2, 'days');\n};\nconst isSameOrBefore = (day1, day2) => {\n  return day1.isSame(day2, 'days') || day1.isBefore(day2, 'days');\n};\nfunction getEventsFromOrders(_ref2) {\n  let {\n    rangeStartDate,\n    rangeEndDate,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes\n  } = _ref2;\n  const res = [];\n  orders.forEach(order => {\n    const orderDate = dayjs(order.orderDate);\n    if (isSameOrAfter(orderDate, rangeStartDate) && isSameOrBefore(orderDate, rangeEndDate)) {\n      res.push({\n        id: generateId('event'),\n        title: t('Order ') + ` (${order?.payment_status}) ` + order?.order_line_items?.map(i => i.description).join(', '),\n        allDay: true,\n        editable: false,\n        start: orderDate.toDate(),\n        metadata: {\n          type: ECalendarEventType.order,\n          orderObj: {\n            order,\n            subscriptionBillingDate: orderDate.toDate(),\n            subscriptionBillingDate_blockedOnUI: dayjs(orderDate).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate()\n          }\n        },\n        extraDate: orderDate.toDate()\n      });\n    }\n  });\n  return res;\n}\nfunction getEventsFromSubscriptions(today, subscriptions, rangeStartDate, rangeEndDate, orderDates, addAdditionalMinutesForBlockUIInMinutes) {\n  let res = [];\n  const activeSubscriptions = subscriptions.filter(s => s.status !== 'cancelled' && !s.deleted);\n  activeSubscriptions.forEach(subscription => {\n    res = [...res, ...getEventsFromSubscription({\n      today,\n      subscription,\n      rangeStartDate,\n      rangeEndDate,\n      orderDates,\n      addAdditionalMinutesForBlockUIInMinutes\n    })];\n  });\n  return res;\n}\nfunction getEventsFromSubscription(_ref3) {\n  let {\n    today,\n    subscription,\n    rangeStartDate,\n    rangeEndDate,\n    orderDates,\n    addAdditionalMinutesForBlockUIInMinutes\n  } = _ref3;\n  const res = [];\n  const todayM = dayjs(today);\n  const cutOff = subscription.cutOff;\n  // const subscriptionStartDate = subscription.pause\n  //     ? subscription.startDate\n  // \t: subscription.nextBillingAtDate || subscription.startDate;\n\n  // Warning!!! don't change to startDate - not working in a lot of cases!!!\n  let subscriptionStartDate = subscription.nextBillingAtDate;\n  // modify day of week\n  subscriptionStartDate = dayjs(subscriptionStartDate).set('day', subscription.cutOffDayOfWeekFromDC).toDate();\n  let step = getStep({\n    billing_period: subscription.billing_period || 0,\n    billing_period_unit: subscription.billing_period_unit,\n    isNewSubscription: false\n  }) || Number.MAX_VALUE;\n  // should coming from subscription or delivery configuration\n  let current = dayjs(subscriptionStartDate); //.set('hours', 10).set('minutes', 0);\n  current = current.set('hours', Number(subscription.cutoffTime?.getHours()));\n  current = current.set('minutes', Number(subscription.cutoffTime?.getMinutes()));\n  current = current.set('seconds', 0);\n  while (current.isAfter(rangeStartDate)) {\n    const prevTick = current.subtract(step, 'd');\n    if (prevTick.isSame(subscription.startDate, 'd') || prevTick.isAfter(subscription.startDate)) {\n      current = current.subtract(step, 'd');\n    } else {\n      break;\n    }\n  }\n  let subscriptionEndDate = subscription.endDate;\n  const pauses = subscription.pauses || [];\n  while (isSameOrBefore(current, rangeEndDate)) {\n    const pause = pauses.find(pause => {\n      const pauseEndDate = dayjs(pause?.endDate).subtract(1, 'm');\n      return current.isSame(pause.startDate, 'd') || current.isSame(pauseEndDate) || current.isAfter(pause.startDate) && current.isBefore(pauseEndDate);\n    });\n    const haveOrder = orderDates.find(orderDate => current.isSame(orderDate, 'd'));\n    if (!haveOrder) {\n      if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate) && (!subscription.cancelDate || subscription.cancelDate && current.isBefore(subscription.cancelDate, 'd'))) {\n        const currentWithAdditionalMinutesForBlockUI = dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes');\n        let subType = EUpcomingDeliverySubType.upcomingDelivery;\n        if (pause) {\n          subType = EUpcomingDeliverySubType.pause;\n        } else if (current.isBefore(subscription.nextBillingAtDate, 'day') && current.isBefore(todayM)) {\n          // if (!isSameOrAfter(current, todayM))\n          {\n            subType = EUpcomingDeliverySubType.skippedButPauseRemoved;\n            // current = current.add(step, 'd');\n            // continue;\n          }\n        } else {\n          subType = todayM.isAfter(currentWithAdditionalMinutesForBlockUI) || todayM.isSame(currentWithAdditionalMinutesForBlockUI) ? EUpcomingDeliverySubType.blockedForUpdate : EUpcomingDeliverySubType.upcomingDelivery;\n        }\n        if (subscription.has_scheduled_changes && isSameOrAfter(current, subscription.nextBillingAtDate) && subscription.subscription_with_scheduled_changes?.id) {\n          res.push({\n            id: generateId('event'),\n            title: `${subscription.id}`,\n            start: current.toDate(),\n            allDay: true,\n            editable: false,\n            metadata: {\n              type: ECalendarEventType.subscription,\n              subscriptionObj: {\n                subscription: subscription.subscription_with_scheduled_changes,\n                subType,\n                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                subscriptionBillingDate: current.toDate(),\n                subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate(),\n                totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0)\n              }\n            },\n            extraDate: current.toDate()\n          });\n          step = getStep({\n            billing_period: subscription.subscription_with_scheduled_changes?.billing_period || 0,\n            billing_period_unit: subscription.subscription_with_scheduled_changes?.billing_period_unit,\n            isNewSubscription: false\n          }) || Number.MAX_VALUE;\n          subscriptionEndDate = subscription.subscription_with_scheduled_changes?.endDate;\n        } else if (!isSameOrAfter(current, subscription.nextBillingAtDate) && subType == EUpcomingDeliverySubType.upcomingDelivery) ;else {\n          const title = `${subscription.id}`;\n          res.push({\n            id: generateId('event'),\n            title,\n            start: current.toDate(),\n            allDay: true,\n            editable: false,\n            metadata: {\n              subscriptionObj: {\n                subscription,\n                subType,\n                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                subscriptionBillingDate: current.toDate(),\n                subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate(),\n                totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0)\n              },\n              type: ECalendarEventType.subscription\n            },\n            extraDate: current.toDate()\n          });\n        }\n      }\n    }\n    current = current.add(step, 'd');\n  }\n  return res;\n}\nfunction getEventsFromPrice(_ref4) {\n  let {\n    price,\n    rangeStartDate,\n    rangeEndDate,\n    cutOff,\n    isNewSubscription\n  } = _ref4;\n  const res = [];\n  let current = rangeStartDate ? dayjs(rangeStartDate) : dayjs(getNow()).hour(23).minute(59).second(59);\n  const step = getStep({\n    billing_period: price.period || 0,\n    billing_period_unit: price.period_unit,\n    isNewSubscription\n  }) || Number.MAX_VALUE;\n  const subscriptionEndDate = new Date(8640000000000000);\n  while (isSameOrBefore(current, rangeEndDate)) {\n    if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate)) {\n      res.push({\n        id: generateId('event'),\n        title: formatDate(current.toDate()),\n        start: current.toDate(),\n        allDay: true,\n        editable: false,\n        metadata: {\n          type: ECalendarEventType.subscription,\n          priceObj: {\n            price,\n            subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n            subscriptionBillingDate: current.toDate(),\n            subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(0, 'minutes').toDate()\n          }\n\n          // subscriptionSkipObject: undefined,\n        },\n\n        extraDate: current.toDate()\n      });\n    }\n    current = current.add(step, 'd');\n  }\n  return res;\n}\nconst getAllEvents = _ref5 => {\n  let {\n    today,\n    subscriptions,\n    range,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes\n  } = _ref5;\n  const subscriptionEvents = getEventsFromSubscriptions(today, subscriptions || [], range?.start, range?.end, orders?.map(o => o.orderDate) || [], addAdditionalMinutesForBlockUIInMinutes);\n  const orderEvents = getEventsFromOrders({\n    orders: orders || [],\n    rangeStartDate: range?.start,\n    rangeEndDate: range?.end,\n    addAdditionalMinutesForBlockUIInMinutes\n  });\n  return [...subscriptionEvents, ...orderEvents].sort((a, b) => a.start.getTime && b.start.getTime && a.start?.getTime() > b.start?.getTime() ? 1 : -1);\n};\nfunction getFirstEvent(events) {\n  const [firstEvent] = events.filter(f => f.metadata?.type === ECalendarEventType.subscription && f.metadata.subscriptionObj?.subType !== EUpcomingDeliverySubType.skippedButPauseRemoved)\n  // filter past skips\n  .filter(f => f.metadata?.subscriptionObj?.subType !== EUpcomingDeliverySubType.pause || f.metadata?.subscriptionObj?.subType === EUpcomingDeliverySubType.pause && f.metadata?.subscriptionObj.subscriptionBillingDate.getTime() > getNow().getTime());\n  return firstEvent;\n}\nexport { ECalendarEventType, EUpcomingDeliverySubType, getAllEvents, getEventsFromPrice, getFirstEvent, getStep };","map":{"version":3,"sources":["../../../src/utils/get-events.util.ts"],"names":["ECalendarEventType","getStep","billing_period","billing_period_unit","isNewSubscription","Math","min","throwException","EUpcomingDeliverySubType","isSameOrAfter","day1","day2","isSame","isAfter","isSameOrBefore","isBefore","getEventsFromOrders","rangeStartDate","rangeEndDate","orders","addAdditionalMinutesForBlockUIInMinutes","res","forEach","order","orderDate","dayjs","push","id","generateId","title","t","payment_status","order_line_items","map","i","description","join","allDay","editable","start","toDate","metadata","type","orderObj","subscriptionBillingDate","subscriptionBillingDate_blockedOnUI","subtract","extraDate","getEventsFromSubscriptions","today","subscriptions","orderDates","activeSubscriptions","filter","s","status","deleted","subscription","getEventsFromSubscription","todayM","cutOff","subscriptionStartDate","nextBillingAtDate","set","cutOffDayOfWeekFromDC","step","Number","MAX_VALUE","current","cutoffTime","getHours","getMinutes","prevTick","startDate","subscriptionEndDate","endDate","pauses","pause","find","pauseEndDate","haveOrder","cancelDate","currentWithAdditionalMinutesForBlockUI","subType","upcomingDelivery","skippedButPauseRemoved","blockedForUpdate","has_scheduled_changes","subscription_with_scheduled_changes","subscriptionObj","subscriptionDeliveryDate","add","totalPrice","totalAddonsPrice","getEventsFromPrice","price","getNow","hour","minute","second","period","period_unit","Date","formatDate","priceObj","getAllEvents","range","subscriptionEvents","end","o","orderEvents","sort","a","b","getTime","getFirstEvent","events","firstEvent","f"],"mappings":"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","sourcesContent":["import { CustomEventInput, ICalendarDateRange } from '@common/general-ui/full-calendar/full-calendar.component';\nimport { t } from '@common/hooks/use-t.hook';\nimport { IIdObject } from '@common/interfaces/id-object.interface';\nimport { generateId } from '@common/utils/generate-id.util';\nimport dayjs from 'dayjs';\nimport { formatDate } from './format-date.util';\nimport { getNow } from './now.util';\nimport { throwException } from './throw-exception.util';\n\nexport enum ECalendarEventType {\n    subscription = 'subscription',\n    order = 'order',\n}\n\nexport interface IPauseCommon {\n    pauseBillingDate: Date;\n    resumeBillingDate: Date;\n}\n\nexport interface ISubscriptionCommon extends IIdObject {\n    status?: string;\n    deleted?: boolean;\n    cutOff: number;\n    cutoffTime: Date | undefined;\n    cutOffDayOfWeekFromDC: number;\n    nextBillingAtDate?: Date;\n    subscription_items?: Array<{ item_price_id?: string }>;\n    startDate?: Date;\n    endDate?: Date;\n    cancelDate?: Date;\n    has_scheduled_changes?: boolean;\n    subscription_with_scheduled_changes?: ISubscriptionCommon;\n    pauses: IDayRangeCommon[] | undefined;\n    totalPrice: number;\n    totalAddonsPrice: number;\n    billing_period?: number;\n    billing_period_unit?: string;\n}\n\nexport interface IItemPriceCommon {\n    period?: number;\n    period_unit?: string;\n}\n\nexport interface IDayRangeCommon {\n    startDate?: Date;\n    endDate?: Date;\n}\n\nexport interface IOrderCommon {\n    orderDate: Date;\n    payment_status?: string;\n    order_line_items?: { description?: string }[];\n}\n\nexport const getStep = ({\n    billing_period,\n    billing_period_unit,\n    isNewSubscription,\n}: {\n    billing_period: number;\n    billing_period_unit: string | undefined;\n    isNewSubscription: boolean;\n}): number | void => {\n    if (billing_period_unit === 'week') {\n        return isNewSubscription ? 7 * Math.min(1, billing_period) : 7 * billing_period;\n    } else if (billing_period_unit === 'day') {\n        return billing_period;\n    }\n    throwException('Not implemented (get step)');\n};\n\nexport enum EUpcomingDeliverySubType {\n    upcomingDelivery = 'upcomingDelivery',\n    pause = 'pause',\n    skippedButPauseRemoved = 'skippedButPauseRemoved',\n    blockedForUpdate = 'blockedForUpdate',\n}\n\nexport interface ICalendarMetaData<\n    TSubscription extends ISubscriptionCommon = ISubscriptionCommon,\n    TPrice extends IItemPriceCommon = IItemPriceCommon,\n    TOrder extends IOrderCommon = IOrderCommon,\n> {\n    type: ECalendarEventType;\n    subscriptionObj?: {\n        subType: EUpcomingDeliverySubType | undefined;\n        subscription?: TSubscription;\n        // subscriptionSkipObject: ICbSubscriptionSkip | undefined;\n        subscriptionDeliveryDate: Date;\n        subscriptionBillingDate_blockedOnUI: Date;\n        subscriptionBillingDate: Date;\n        totalPrice: number;\n    };\n    priceObj?: {\n        price?: TPrice;\n        subscriptionDeliveryDate: Date | undefined;\n        subscriptionBillingDate_blockedOnUI: Date | undefined;\n        subscriptionBillingDate: Date | undefined;\n    };\n    orderObj?: {\n        order: TOrder | undefined;\n        subscriptionBillingDate: Date | undefined;\n        subscriptionBillingDate_blockedOnUI: Date | undefined;\n    };\n}\n\nconst isSameOrAfter = (day1: dayjs.Dayjs, day2: Date | dayjs.Dayjs | undefined): boolean => {\n    return day1.isSame(day2, 'days') || day1.isAfter(day2, 'days');\n};\nconst isSameOrBefore = (day1: dayjs.Dayjs, day2: Date | dayjs.Dayjs | undefined): boolean => {\n    return day1.isSame(day2, 'days') || day1.isBefore(day2, 'days');\n};\nexport type ICalendarEventCommon<\n    TSubsr extends ISubscriptionCommon = ISubscriptionCommon,\n    TPrice extends IItemPriceCommon = IItemPriceCommon,\n    TOrder extends IOrderCommon = IOrderCommon,\n> = CustomEventInput<ICalendarMetaData<TSubsr, TPrice, TOrder>> & IIdObject;\n\nfunction getEventsFromOrders({\n    rangeStartDate,\n    rangeEndDate,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    orders: IOrderCommon[];\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    orders.forEach((order) => {\n        const orderDate = dayjs(order.orderDate);\n\n        if (isSameOrAfter(orderDate, rangeStartDate) && isSameOrBefore(orderDate, rangeEndDate)) {\n            res.push({\n                id: generateId('event'),\n                title:\n                    t('Order ') +\n                    ` (${order?.payment_status}) ` +\n                    order?.order_line_items?.map((i) => i.description).join(', '),\n                allDay: true,\n                editable: false,\n                start: orderDate.toDate(),\n                metadata: {\n                    type: ECalendarEventType.order,\n                    orderObj: {\n                        order,\n                        subscriptionBillingDate: orderDate.toDate(),\n                        subscriptionBillingDate_blockedOnUI: dayjs(orderDate)\n                            .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                            .toDate(),\n                    },\n                },\n                extraDate: orderDate.toDate(),\n            });\n        }\n    });\n    return res;\n}\n\nfunction getEventsFromSubscriptions(\n    today: Date,\n    subscriptions: ISubscriptionCommon[],\n    rangeStartDate: Date | undefined,\n    rangeEndDate: Date | undefined,\n    orderDates: Date[],\n    addAdditionalMinutesForBlockUIInMinutes: number,\n): ICalendarEventCommon[] {\n    let res: ICalendarEventCommon[] = [];\n\n    const activeSubscriptions = subscriptions.filter((s) => s.status !== 'cancelled' && !s.deleted);\n\n    activeSubscriptions.forEach((subscription) => {\n        res = [\n            ...res,\n\n            ...getEventsFromSubscription({\n                today,\n                subscription,\n                rangeStartDate,\n                rangeEndDate,\n                orderDates,\n                addAdditionalMinutesForBlockUIInMinutes,\n            }),\n        ];\n    });\n\n    return res;\n}\n\nfunction getEventsFromSubscription({\n    today,\n    subscription,\n    rangeStartDate,\n    rangeEndDate,\n    orderDates,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    today: Date;\n    subscription: ISubscriptionCommon;\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    orderDates: Date[];\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    const todayM = dayjs(today);\n    const cutOff = subscription.cutOff;\n    // const subscriptionStartDate = subscription.pause\n    //     ? subscription.startDate\n    // \t: subscription.nextBillingAtDate || subscription.startDate;\n\n    // Warning!!! don't change to startDate - not working in a lot of cases!!!\n    let subscriptionStartDate = subscription.nextBillingAtDate;\n    // modify day of week\n    subscriptionStartDate = dayjs(subscriptionStartDate)\n        .set('day', subscription.cutOffDayOfWeekFromDC as number)\n        .toDate();\n\n    let step =\n        getStep({\n            billing_period: subscription.billing_period || 0,\n            billing_period_unit: subscription.billing_period_unit,\n            isNewSubscription: false,\n        }) || Number.MAX_VALUE;\n    // should coming from subscription or delivery configuration\n    let current = dayjs(subscriptionStartDate); //.set('hours', 10).set('minutes', 0);\n    current = current.set('hours', Number(subscription.cutoffTime?.getHours()));\n    current = current.set('minutes', Number(subscription.cutoffTime?.getMinutes()));\n    current = current.set('seconds', 0);\n    while (current.isAfter(rangeStartDate)) {\n        const prevTick = current.subtract(step, 'd');\n        if (prevTick.isSame(subscription.startDate, 'd') || prevTick.isAfter(subscription.startDate)) {\n            current = current.subtract(step, 'd');\n        } else {\n            break;\n        }\n    }\n\n    let subscriptionEndDate = subscription.endDate;\n\n    const pauses = subscription.pauses || [];\n\n    while (isSameOrBefore(current, rangeEndDate)) {\n        const pause = pauses.find((pause) => {\n            const pauseEndDate = dayjs(pause?.endDate).subtract(1, 'm');\n            return (\n                current.isSame(pause.startDate, 'd') ||\n                current.isSame(pauseEndDate) ||\n                (current.isAfter(pause.startDate) && current.isBefore(pauseEndDate))\n            );\n        });\n\n        const haveOrder = orderDates.find((orderDate) => current.isSame(orderDate, 'd'));\n        if (!haveOrder) {\n            if (\n                isSameOrAfter(current, rangeStartDate) &&\n                isSameOrBefore(current, subscriptionEndDate) &&\n                (!subscription.cancelDate || (subscription.cancelDate && current.isBefore(subscription.cancelDate, 'd')))\n            ) {\n                const currentWithAdditionalMinutesForBlockUI = dayjs(current).subtract(\n                    addAdditionalMinutesForBlockUIInMinutes,\n                    'minutes',\n                );\n\n                let subType: EUpcomingDeliverySubType = EUpcomingDeliverySubType.upcomingDelivery;\n                if (pause) {\n                    subType = EUpcomingDeliverySubType.pause;\n                } else if (current.isBefore(subscription.nextBillingAtDate, 'day') && current.isBefore(todayM)) {\n                    // if (!isSameOrAfter(current, todayM))\n                    {\n                        subType = EUpcomingDeliverySubType.skippedButPauseRemoved;\n                        // current = current.add(step, 'd');\n                        // continue;\n                    }\n                } else {\n                    subType =\n                        todayM.isAfter(currentWithAdditionalMinutesForBlockUI) ||\n                        todayM.isSame(currentWithAdditionalMinutesForBlockUI)\n                            ? EUpcomingDeliverySubType.blockedForUpdate\n                            : EUpcomingDeliverySubType.upcomingDelivery;\n                }\n                if (\n                    subscription.has_scheduled_changes &&\n                    isSameOrAfter(current, subscription.nextBillingAtDate) &&\n                    subscription.subscription_with_scheduled_changes?.id\n                ) {\n                    res.push({\n                        id: generateId('event'),\n                        title: `${subscription.id}`,\n                        start: current.toDate(),\n                        allDay: true,\n                        editable: false,\n                        metadata: {\n                            type: ECalendarEventType.subscription,\n                            subscriptionObj: {\n                                subscription: subscription.subscription_with_scheduled_changes,\n                                subType,\n                                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                                subscriptionBillingDate: current.toDate(),\n                                subscriptionBillingDate_blockedOnUI: dayjs(current)\n                                    .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                                    .toDate(),\n                                totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0),\n                            },\n                        },\n                        extraDate: current.toDate(),\n                    });\n\n                    step =\n                        getStep({\n                            billing_period: subscription.subscription_with_scheduled_changes?.billing_period || 0,\n                            billing_period_unit: subscription.subscription_with_scheduled_changes?.billing_period_unit,\n                            isNewSubscription: false,\n                        }) || Number.MAX_VALUE;\n                    subscriptionEndDate = subscription.subscription_with_scheduled_changes?.endDate;\n                } else if (\n                    !isSameOrAfter(current, subscription.nextBillingAtDate) &&\n                    subType == EUpcomingDeliverySubType.upcomingDelivery\n                ) {\n                    // do nothing it's not possible\n                    // upcoming delivery will be available only after nextBillingAt or in the same day\n                } else {\n                    const title = `${subscription.id}`;\n                    res.push({\n                        id: generateId('event'),\n                        title,\n                        start: current.toDate(),\n                        allDay: true,\n                        editable: false,\n                        metadata: {\n                            subscriptionObj: {\n                                subscription,\n                                subType,\n                                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                                subscriptionBillingDate: current.toDate(),\n                                subscriptionBillingDate_blockedOnUI: dayjs(current)\n                                    .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                                    .toDate(),\n                                totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0),\n                            },\n\n                            type: ECalendarEventType.subscription,\n                        },\n                        extraDate: current.toDate(),\n                    });\n                }\n            }\n        }\n        current = current.add(step, 'd');\n    }\n\n    return res;\n}\n\nexport function getEventsFromPrice({\n    price,\n    rangeStartDate,\n    rangeEndDate,\n    cutOff,\n    isNewSubscription,\n}: {\n    price: IItemPriceCommon;\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    cutOff: number;\n    isNewSubscription: boolean;\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    let current = rangeStartDate ? dayjs(rangeStartDate) : dayjs(getNow()).hour(23).minute(59).second(59);\n    const step =\n        getStep({ billing_period: price.period || 0, billing_period_unit: price.period_unit, isNewSubscription }) ||\n        Number.MAX_VALUE;\n    const subscriptionEndDate = new Date(8640000000000000);\n\n    while (isSameOrBefore(current, rangeEndDate)) {\n        if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate)) {\n            res.push({\n                id: generateId('event'),\n                title: formatDate(current.toDate()),\n                start: current.toDate(),\n                allDay: true,\n                editable: false,\n                metadata: {\n                    type: ECalendarEventType.subscription,\n                    priceObj: {\n                        price,\n                        subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                        subscriptionBillingDate: current.toDate(),\n                        subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(0, 'minutes').toDate(),\n                    },\n\n                    // subscriptionSkipObject: undefined,\n                },\n                extraDate: current.toDate(),\n            });\n        }\n        current = current.add(step, 'd');\n    }\n\n    return res;\n}\n\nexport const getAllEvents = ({\n    today,\n    subscriptions,\n    range,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    today: Date;\n    range: ICalendarDateRange | undefined;\n    subscriptions: ISubscriptionCommon[] | undefined;\n    orders: IOrderCommon[] | undefined;\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] => {\n    const subscriptionEvents = getEventsFromSubscriptions(\n        today,\n        subscriptions || [],\n        range?.start,\n        range?.end,\n        orders?.map((o) => o.orderDate) || [],\n        addAdditionalMinutesForBlockUIInMinutes,\n    );\n\n    const orderEvents = getEventsFromOrders({\n        orders: orders || [],\n        rangeStartDate: range?.start,\n        rangeEndDate: range?.end,\n        addAdditionalMinutesForBlockUIInMinutes,\n    });\n    return [...subscriptionEvents, ...orderEvents].sort((a, b) =>\n        (a.start as Date).getTime && (b.start as Date).getTime && (a.start as Date)?.getTime() > (b.start as Date)?.getTime()\n            ? 1\n            : -1,\n    );\n};\n\nexport function getFirstEvent<T extends ICalendarEventCommon>(events: ICalendarEventCommon[]): T | undefined {\n    const [firstEvent] = events\n        .filter(\n            (f) =>\n                f.metadata?.type === ECalendarEventType.subscription &&\n                f.metadata.subscriptionObj?.subType !== EUpcomingDeliverySubType.skippedButPauseRemoved,\n        )\n        // filter past skips\n        .filter(\n            (f) =>\n                f.metadata?.subscriptionObj?.subType !== EUpcomingDeliverySubType.pause ||\n                (f.metadata?.subscriptionObj?.subType === EUpcomingDeliverySubType.pause &&\n                    f.metadata?.subscriptionObj.subscriptionBillingDate.getTime() > getNow().getTime()),\n        );\n    return firstEvent as T;\n}\n"]},"metadata":{},"sourceType":"module"}
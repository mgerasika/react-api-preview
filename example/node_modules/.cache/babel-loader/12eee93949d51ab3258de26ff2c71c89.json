{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readCodePoint = readCodePoint;\nexports.readInt = readInt;\nexports.readStringContents = readStringContents;\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}","map":{"version":3,"sources":["../src/index.ts"],"names":["isDigit","code","forbiddenNumericSeparatorSiblings","decBinOct","Set","hex","isAllowedNumericSeparatorSibling","bin","ch","oct","dec","readStringContents","type","input","pos","lineStart","curLine","errors","initialPos","initialLineStart","initialCurLine","out","firstInvalidLoc","chunkStart","length","unterminated","slice","charCodeAt","isStringEnd","res","readEscapedChar","str","containsInvalid","inTemplate","throwOnInvalid","readHexChar","String","fromCharCode","readCodePoint","fromCodePoint","strictNumericEscape","startPos","match","octalStr","octal","parseInt","next","len","forceLen","n","readInt","invalidEscapeSequence","radix","allowNumSeparator","bailOnError","start","forbiddenSiblings","isAllowedSibling","invalid","total","i","e","Infinity","val","prev","numericSeparatorInEscapeSequence","Number","isNaN","has","unexpectedNumericSeparator","invalidDigit","indexOf","invalidCodePoint"],"mappings":";;;;;;;;eAAA,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;EACrB,OAAOA,IAAI,IAAA,EAAJA,IAAkBA,IAAI,IAAA,EAA7B;AACD,C;AAED,MAAMC,iCAAiC,GAAG;EACxCC,SAAS,EAAE,IAAIC,GAAJ,CAAgB,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,CAAhB,CAD6B;EAWxCC,GAAG,EAAE,IAAID,GAAJ,CAAgB,CAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,CAAhB;AAXmC,CAA1C;AAmBA,MAAME,gCAAgC,GAAG;EAEvCC,GAAG,EAAGC,EAAD,IAAgBA,EAAE,KAAA,EAAFA,IAA2BA,EAAE,KAAA,EAFX;EAKvCC,GAAG,EAAGD,EAAD,IAAgBA,EAAE,IAAA,EAAFA,IAA0BA,EAAE,IAAA,EALV;EAQvCE,GAAG,EAAGF,EAAD,IAAgBA,EAAE,IAAA,EAAFA,IAA0BA,EAAE,IAAA,EARV;EAWvCH,GAAG,EAAGG,EAAD,IACFA,EAAE,IAAA,EAAFA,IAA0BA,EAAE,IAAA,EAA7B,IACCA,EAAE,IAAA,EAAFA,IAA8BA,EAAE,IAAA,EADjC,IAECA,EAAE,IAAA,EAAFA,IAA8BA,EAAE,IAAA;AAdI,CAAzC;AAyBO,SAASG,kBAAT,CACLC,IADK,EAELC,KAFK,EAGLC,GAHK,EAILC,SAJK,EAKLC,OALK,EAMLC,MANK,EAOL;EACA,MAAMC,UAAU,GAAGJ,GAAnB;EACA,MAAMK,gBAAgB,GAAGJ,SAAzB;EACA,MAAMK,cAAc,GAAGJ,OAAvB;EAEA,IAAIK,GAAG,GAAG,EAAV;EACA,IAAIC,eAAe,GAAG,IAAtB;EACA,IAAIC,UAAU,GAAGT,GAAjB;EACA,MAAM;IAAEU;EAAF,CAAA,GAAaX,KAAnB;EACA,SAAS;IACP,IAAIC,GAAG,IAAIU,MAAX,EAAmB;MACjBP,MAAM,CAACQ,YAAPR,CAAoBC,UAApBD,EAAgCE,gBAAhCF,EAAkDG,cAAlDH,CAAAA;MACAI,GAAG,IAAIR,KAAK,CAACa,KAANb,CAAYU,UAAZV,EAAwBC,GAAxBD,CAAPQ;MACA;IACD;IACD,MAAMb,EAAE,GAAGK,KAAK,CAACc,UAANd,CAAiBC,GAAjBD,CAAX;IACA,IAAIe,WAAW,CAAChB,IAAD,EAAOJ,EAAP,EAAWK,KAAX,EAAkBC,GAAlB,CAAf,EAAuC;MACrCO,GAAG,IAAIR,KAAK,CAACa,KAANb,CAAYU,UAAZV,EAAwBC,GAAxBD,CAAPQ;MACA;IACD;IACD,IAAIb,EAAE,KAAA,EAAN,EAAgC;MAC9Ba,GAAG,IAAIR,KAAK,CAACa,KAANb,CAAYU,UAAZV,EAAwBC,GAAxBD,CAAPQ;MACA,MAAMQ,GAAG,GAAGC,eAAe,CACzBjB,KADyB,EAEzBC,GAFyB,EAGzBC,SAHyB,EAIzBC,OAJyB,EAKzBJ,IAAI,KAAK,UALgB,EAMzBK,MANyB,CAA3B;MAQA,IAAIY,GAAG,CAACrB,EAAJqB,KAAW,IAAXA,IAAmB,CAACP,eAAxB,EAAyC;QACvCA,eAAe,GAAG;UAAER,GAAF;UAAOC,SAAP;UAAkBC;QAAlB,CAAlBM;MACD,CAFD,MAEO;QACLD,GAAG,IAAIQ,GAAG,CAACrB,EAAXa;MACD;MACD,CAAC;QAAEP,GAAF;QAAOC,SAAP;QAAkBC;MAAlB,CAAA,GAA8Ba,GAA/B;MACAN,UAAU,GAAGT,GAAbS;IACD,CAjBD,MAiBO,IACLf,EAAE,KAAA,IAAFA,IACAA,EAAE,KAAA,IAFG,EAGL;MACA,EAAEM,GAAF;MACA,EAAEE,OAAF;MACAD,SAAS,GAAGD,GAAZC;IACD,CAPM,MAOA,IAAIP,EAAE,KAAA,EAAFA,IAA6BA,EAAE,KAAA,EAAnC,EAAkE;MACvE,IAAII,IAAI,KAAK,UAAb,EAAyB;QACvBS,GAAG,IAAIR,KAAK,CAACa,KAANb,CAAYU,UAAZV,EAAwBC,GAAxBD,CAAAA,GAA+B,IAAtCQ;QACA,EAAEP,GAAF;QACA,IACEN,EAAE,KAAA,EAAFA,IACAK,KAAK,CAACc,UAANd,CAAiBC,GAAjBD,CAAAA,KAAAA,EAFF,EAGE;UACA,EAAEC,GAAF;QACD;QACD,EAAEE,OAAF;QACAO,UAAU,GAAGR,SAAS,GAAGD,GAAzBS;MACD,CAXD,MAWO;QACLN,MAAM,CAACQ,YAAPR,CAAoBC,UAApBD,EAAgCE,gBAAhCF,EAAkDG,cAAlDH,CAAAA;MACD;IACF,CAfM,MAeA;MACL,EAAEH,GAAF;IACD;EACF;EACD,OAAO;IACLA,GADK;IAELiB,GAAG,EAAEV,GAFA;IAGLC,eAHK;IAILP,SAJK;IAKLC,OALK;IASLgB,eAAe,EAAE,CAAC,CAACV;EATd,CAAP;AAWD;AAED,SAASM,WAAT,CACEhB,IADF,EAEEJ,EAFF,EAGEK,KAHF,EAIEC,GAJF,EAKE;EACA,IAAIF,IAAI,KAAK,UAAb,EAAyB;IACvB,OACEJ,EAAE,KAAA,EAAFA,IACCA,EAAE,KAAA,EAAFA,IACCK,KAAK,CAACc,UAANd,CAAiBC,GAAG,GAAG,CAAvBD,CAAAA,KAAAA,GAHJ;EAKD;EACD,OACEL,EAAE,MAAMI,IAAI,KAAK,QAATA,GAAAA,EAAAA,GAAAA,EAAN,CADJ;AAGD;AAOD,SAASkB,eAAT,CACEjB,KADF,EAEEC,GAFF,EAGEC,SAHF,EAIEC,OAJF,EAKEiB,UALF,EAMEhB,MANF,EAOE;EACA,MAAMiB,cAAc,GAAG,CAACD,UAAxB;EACAnB,GAAG,EAAA;EAEH,MAAMe,GAAG,GAAIrB,EAAD,KAAwB;IAAEM,GAAF;IAAON,EAAP;IAAWO,SAAX;IAAsBC;EAAtB,CAAxB,CAAZ;EAEA,MAAMR,EAAE,GAAGK,KAAK,CAACc,UAANd,CAAiBC,GAAG,EAApBD,CAAX;EACA,QAAQL,EAAR;IACE,KAAA,GAAA;MACE,OAAOqB,GAAG,CAAC,IAAD,CAAV;IACF,KAAA,GAAA;MACE,OAAOA,GAAG,CAAC,IAAD,CAAV;IACF,KAAA,GAAA;MAA2B;QACzB,IAAI5B,IAAJ;QACA,CAAC;UAAEA,IAAF;UAAQa;QAAR,CAAA,GAAgBqB,WAAW,CAC1BtB,KAD0B,EAE1BC,GAF0B,EAG1BC,SAH0B,EAI1BC,OAJ0B,EAK1B,CAL0B,EAM1B,KAN0B,EAO1BkB,cAP0B,EAQ1BjB,MAR0B,CAA5B;QAUA,OAAOY,GAAG,CAAC5B,IAAI,KAAK,IAATA,GAAgB,IAAhBA,GAAuBmC,MAAM,CAACC,YAAPD,CAAoBnC,IAApBmC,CAAxB,CAAV;MACD;IACD,KAAA,GAAA;MAA2B;QACzB,IAAInC,IAAJ;QACA,CAAC;UAAEA,IAAF;UAAQa;QAAR,CAAA,GAAgBwB,aAAa,CAC5BzB,KAD4B,EAE5BC,GAF4B,EAG5BC,SAH4B,EAI5BC,OAJ4B,EAK5BkB,cAL4B,EAM5BjB,MAN4B,CAA9B;QAQA,OAAOY,GAAG,CAAC5B,IAAI,KAAK,IAATA,GAAgB,IAAhBA,GAAuBmC,MAAM,CAACG,aAAPH,CAAqBnC,IAArBmC,CAAxB,CAAV;MACD;IACD,KAAA,GAAA;MACE,OAAOP,GAAG,CAAC,IAAD,CAAV;IACF,KAAA,EAAA;MACE,OAAOA,GAAG,CAAC,IAAD,CAAV;IACF,KAAA,GAAA;MACE,OAAOA,GAAG,CAAC,QAAD,CAAV;IACF,KAAA,GAAA;MACE,OAAOA,GAAG,CAAC,IAAD,CAAV;IACF,KAAA,EAAA;MACE,IAAIhB,KAAK,CAACc,UAANd,CAAiBC,GAAjBD,CAAAA,KAAAA,EAAJ,EAAkD;QAChD,EAAEC,GAAF;MACD;IAEH,KAAA,EAAA;MACEC,SAAS,GAAGD,GAAZC;MACA,EAAEC,OAAF;IAEF,KAAA,IAAA;IACA,KAAA,IAAA;MACE,OAAOa,GAAG,CAAC,EAAD,CAAV;IACF,KAAA,EAAA;IACA,KAAA,EAAA;MACE,IAAII,UAAJ,EAAgB;QACd,OAAOJ,GAAG,CAAC,IAAD,CAAV;MACD,CAFD,MAEO;QACLZ,MAAM,CAACuB,mBAAPvB,CAA2BH,GAAG,GAAG,CAAjCG,EAAoCF,SAApCE,EAA+CD,OAA/CC,CAAAA;MACD;IAEH;MACE,IAAIT,EAAE,IAAA,EAAFA,IAA0BA,EAAE,IAAA,EAAhC,EAAsD;QACpD,MAAMiC,QAAQ,GAAG3B,GAAG,GAAG,CAAvB;QACA,MAAM4B,KAAK,GAAG7B,KAAK,CAACa,KAANb,CAAY4B,QAAZ5B,EAAsBC,GAAG,GAAG,CAA5BD,CAAAA,CAA+B6B,KAA/B7B,CAAqC,SAArCA,CAAd;QAEA,IAAI8B,QAAQ,GAAGD,KAAK,CAAC,CAAD,CAApB;QAEA,IAAIE,KAAK,GAAGC,QAAQ,CAACF,QAAD,EAAW,CAAX,CAApB;QACA,IAAIC,KAAK,GAAG,GAAZ,EAAiB;UACfD,QAAQ,GAAGA,QAAQ,CAACjB,KAATiB,CAAe,CAAfA,EAAkB,CAAC,CAAnBA,CAAXA;UACAC,KAAK,GAAGC,QAAQ,CAACF,QAAD,EAAW,CAAX,CAAhBC;QACD;QACD9B,GAAG,IAAI6B,QAAQ,CAACnB,MAATmB,GAAkB,CAAzB7B;QACA,MAAMgC,IAAI,GAAGjC,KAAK,CAACc,UAANd,CAAiBC,GAAjBD,CAAb;QACA,IACE8B,QAAQ,KAAK,GAAbA,IACAG,IAAI,KAAA,EADJH,IAEAG,IAAI,KAAA,EAHN,EAIE;UACA,IAAIb,UAAJ,EAAgB;YACd,OAAOJ,GAAG,CAAC,IAAD,CAAV;UACD,CAFD,MAEO;YACLZ,MAAM,CAACuB,mBAAPvB,CAA2BwB,QAA3BxB,EAAqCF,SAArCE,EAAgDD,OAAhDC,CAAAA;UACD;QACF;QAED,OAAOY,GAAG,CAACO,MAAM,CAACC,YAAPD,CAAoBQ,KAApBR,CAAD,CAAV;MACD;MAED,OAAOP,GAAG,CAACO,MAAM,CAACC,YAAPD,CAAoB5B,EAApB4B,CAAD,CAAV;EAAA;AAEL;AAOD,SAASD,WAAT,CACEtB,KADF,EAEEC,GAFF,EAGEC,SAHF,EAIEC,OAJF,EAKE+B,GALF,EAMEC,QANF,EAOEd,cAPF,EAQEjB,MARF,EASE;EACA,MAAMC,UAAU,GAAGJ,GAAnB;EACA,IAAImC,CAAJ;EACA,CAAC;IAAEA,CAAF;IAAKnC;EAAL,CAAA,GAAaoC,OAAO,CACnBrC,KADmB,EAEnBC,GAFmB,EAGnBC,SAHmB,EAInBC,OAJmB,EAKnB,EALmB,EAMnB+B,GANmB,EAOnBC,QAPmB,EAQnB,KARmB,EASnB/B,MATmB,EAUD,CAACiB,cAVA,CAArB;EAYA,IAAIe,CAAC,KAAK,IAAV,EAAgB;IACd,IAAIf,cAAJ,EAAoB;MAClBjB,MAAM,CAACkC,qBAAPlC,CAA6BC,UAA7BD,EAAyCF,SAAzCE,EAAoDD,OAApDC,CAAAA;IACD,CAFD,MAEO;MACLH,GAAG,GAAGI,UAAU,GAAG,CAAnBJ;IACD;EACF;EACD,OAAO;IAAEb,IAAI,EAAEgD,CAAR;IAAWnC;EAAX,CAAP;AACD;AAuBM,SAASoC,OAAT,CACLrC,KADK,EAELC,GAFK,EAGLC,SAHK,EAILC,OAJK,EAKLoC,KALK,EAMLL,GANK,EAOLC,QAPK,EAQLK,iBARK,EASLpC,MATK,EAULqC,WAVK,EAWL;EACA,MAAMC,KAAK,GAAGzC,GAAd;EACA,MAAM0C,iBAAiB,GACrBJ,KAAK,KAAK,EAAVA,GACIlD,iCAAiC,CAACG,GADtC+C,GAEIlD,iCAAiC,CAACC,SAHxC;EAIA,MAAMsD,gBAAgB,GACpBL,KAAK,KAAK,EAAVA,GACI9C,gCAAgC,CAACD,GADrC+C,GAEIA,KAAK,KAAK,EAAVA,GACA9C,gCAAgC,CAACI,GADjC0C,GAEAA,KAAK,KAAK,CAAVA,GACA9C,gCAAgC,CAACG,GADjC2C,GAEA9C,gCAAgC,CAACC,GAPvC;EASA,IAAImD,OAAO,GAAG,KAAd;EACA,IAAIC,KAAK,GAAG,CAAZ;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGd,GAAG,IAAI,IAAPA,GAAce,QAAdf,GAAyBA,GAA7C,EAAkDa,CAAC,GAAGC,CAAtD,EAAyD,EAAED,CAA3D,EAA8D;IAC5D,MAAM3D,IAAI,GAAGY,KAAK,CAACc,UAANd,CAAiBC,GAAjBD,CAAb;IACA,IAAIkD,GAAJ;IAEA,IAAI9D,IAAI,KAAA,EAAJA,IAAiCoD,iBAAiB,KAAK,MAA3D,EAAmE;MACjE,MAAMW,IAAI,GAAGnD,KAAK,CAACc,UAANd,CAAiBC,GAAG,GAAG,CAAvBD,CAAb;MACA,MAAMiC,IAAI,GAAGjC,KAAK,CAACc,UAANd,CAAiBC,GAAG,GAAG,CAAvBD,CAAb;MAEA,IAAI,CAACwC,iBAAL,EAAwB;QACtB,IAAIC,WAAJ,EAAiB,OAAO;UAAEL,CAAC,EAAE,IAAL;UAAWnC;QAAX,CAAP;QACjBG,MAAM,CAACgD,gCAAPhD,CAAwCH,GAAxCG,EAA6CF,SAA7CE,EAAwDD,OAAxDC,CAAAA;MACD,CAHD,MAGO,IACLiD,MAAM,CAACC,KAAPD,CAAapB,IAAboB,CAAAA,IACA,CAACT,gBAAgB,CAACX,IAAD,CADjBoB,IAEAV,iBAAiB,CAACY,GAAlBZ,CAAsBQ,IAAtBR,CAFAU,IAGAV,iBAAiB,CAACY,GAAlBZ,CAAsBV,IAAtBU,CAJK,EAKL;QACA,IAAIF,WAAJ,EAAiB,OAAO;UAAEL,CAAC,EAAE,IAAL;UAAWnC;QAAX,CAAP;QACjBG,MAAM,CAACoD,0BAAPpD,CAAkCH,GAAlCG,EAAuCF,SAAvCE,EAAkDD,OAAlDC,CAAAA;MACD;MAGD,EAAEH,GAAF;MACA;IACD;IAED,IAAIb,IAAI,IAAA,EAAR,EAAkC;MAChC8D,GAAG,GAAG9D,IAAI,GAAA,EAAJA,GAAAA,EAAN8D;IACD,CAFD,MAEO,IAAI9D,IAAI,IAAA,EAAR,EAAkC;MACvC8D,GAAG,GAAG9D,IAAI,GAAA,EAAJA,GAAAA,EAAN8D;IACD,CAFM,MAEA,IAAI,QAAA,CAAkB9D,IAAlB,CAAJ,EAA6B;MAClC8D,GAAG,GAAG9D,IAAI,GAAA,EAAV8D;IACD,CAFM,MAEA;MACLA,GAAG,GAAGD,QAANC;IACD;IACD,IAAIA,GAAG,IAAIX,KAAX,EAAkB;MAGhB,IAAIW,GAAG,IAAI,CAAPA,IAAYT,WAAhB,EAA6B;QAC3B,OAAO;UAAEL,CAAC,EAAE,IAAL;UAAWnC;QAAX,CAAP;MACD,CAFD,MAEO,IACLiD,GAAG,IAAI,CAAPA,IACA9C,MAAM,CAACqD,YAAPrD,CAAoBH,GAApBG,EAAyBF,SAAzBE,EAAoCD,OAApCC,EAA6CmC,KAA7CnC,CAFK,EAGL;QACA8C,GAAG,GAAG,CAANA;MACD,CALM,MAKA,IAAIf,QAAJ,EAAc;QACnBe,GAAG,GAAG,CAANA;QACAL,OAAO,GAAG,IAAVA;MACD,CAHM,MAGA;QACL;MACD;IACF;IACD,EAAE5C,GAAF;IACA6C,KAAK,GAAGA,KAAK,GAAGP,KAARO,GAAgBI,GAAxBJ;EACD;EACD,IAAI7C,GAAG,KAAKyC,KAARzC,IAAkBiC,GAAG,IAAI,IAAPA,IAAejC,GAAG,GAAGyC,KAANzC,KAAgBiC,GAAjDjC,IAAyD4C,OAA7D,EAAsE;IACpE,OAAO;MAAET,CAAC,EAAE,IAAL;MAAWnC;IAAX,CAAP;EACD;EAED,OAAO;IAAEmC,CAAC,EAAEU,KAAL;IAAY7C;EAAZ,CAAP;AACD;AAMM,SAASwB,aAAT,CACLzB,KADK,EAELC,GAFK,EAGLC,SAHK,EAILC,OAJK,EAKLkB,cALK,EAMLjB,MANK,EAOL;EACA,MAAMT,EAAE,GAAGK,KAAK,CAACc,UAANd,CAAiBC,GAAjBD,CAAX;EACA,IAAIZ,IAAJ;EAEA,IAAIO,EAAE,KAAA,GAAN,EAAqC;IACnC,EAAEM,GAAF;IACA,CAAC;MAAEb,IAAF;MAAQa;IAAR,CAAA,GAAgBqB,WAAW,CAC1BtB,KAD0B,EAE1BC,GAF0B,EAG1BC,SAH0B,EAI1BC,OAJ0B,EAK1BH,KAAK,CAAC0D,OAAN1D,CAAc,GAAdA,EAAmBC,GAAnBD,CAAAA,GAA0BC,GALA,EAM1B,IAN0B,EAO1BoB,cAP0B,EAQ1BjB,MAR0B,CAA5B;IAUA,EAAEH,GAAF;IACA,IAAIb,IAAI,KAAK,IAATA,IAAiBA,IAAI,GAAG,QAA5B,EAAsC;MACpC,IAAIiC,cAAJ,EAAoB;QAClBjB,MAAM,CAACuD,gBAAPvD,CAAwBH,GAAxBG,EAA6BF,SAA7BE,EAAwCD,OAAxCC,CAAAA;MACD,CAFD,MAEO;QACL,OAAO;UAAEhB,IAAI,EAAE,IAAR;UAAca;QAAd,CAAP;MACD;IACF;EACF,CApBD,MAoBO;IACL,CAAC;MAAEb,IAAF;MAAQa;IAAR,CAAA,GAAgBqB,WAAW,CAC1BtB,KAD0B,EAE1BC,GAF0B,EAG1BC,SAH0B,EAI1BC,OAJ0B,EAK1B,CAL0B,EAM1B,KAN0B,EAO1BkB,cAP0B,EAQ1BjB,MAR0B,CAA5B;EAUD;EACD,OAAO;IAAEhB,IAAF;IAAQa;EAAR,CAAP;AACD","sourcesContent":["import * as charCodes from \"charcodes\";\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ]),\n  hex: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ]),\n};\n\nconst isAllowedNumericSeparatorSibling = {\n  // 0 - 1\n  bin: (ch: number) => ch === charCodes.digit0 || ch === charCodes.digit1,\n\n  // 0 - 7\n  oct: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit7,\n\n  // 0 - 9\n  dec: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit9,\n\n  // 0 - 9, A - F, a - f,\n  hex: (ch: number) =>\n    (ch >= charCodes.digit0 && ch <= charCodes.digit9) ||\n    (ch >= charCodes.uppercaseA && ch <= charCodes.uppercaseF) ||\n    (ch >= charCodes.lowercaseA && ch <= charCodes.lowercaseF),\n};\n\nexport type StringContentsErrorHandlers = EscapedCharErrorHandlers & {\n  unterminated(\n    initialPos: number,\n    initialLineStart: number,\n    initialCurLine: number,\n  ): void;\n};\n\nexport function readStringContents(\n  type: \"single\" | \"double\" | \"template\",\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  errors: StringContentsErrorHandlers,\n) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const { length } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === charCodes.backslash) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        type === \"template\",\n        errors,\n      );\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = { pos, lineStart, curLine };\n      } else {\n        out += res.ch;\n      }\n      ({ pos, lineStart, curLine } = res);\n      chunkStart = pos;\n    } else if (\n      ch === charCodes.lineSeparator ||\n      ch === charCodes.paragraphSeparator\n    ) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === charCodes.lineFeed || ch === charCodes.carriageReturn) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (\n          ch === charCodes.carriageReturn &&\n          input.charCodeAt(pos) === charCodes.lineFeed\n        ) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n\n    // TODO(Babel 8): This is only needed for backwards compatibility,\n    // we can remove it.\n    containsInvalid: !!firstInvalidLoc,\n  };\n}\n\nfunction isStringEnd(\n  type: \"single\" | \"double\" | \"template\",\n  ch: number,\n  input: string,\n  pos: number,\n) {\n  if (type === \"template\") {\n    return (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign &&\n        input.charCodeAt(pos + 1) === charCodes.leftCurlyBrace)\n    );\n  }\n  return (\n    ch === (type === \"double\" ? charCodes.quotationMark : charCodes.apostrophe)\n  );\n}\n\ntype EscapedCharErrorHandlers = HexCharErrorHandlers &\n  CodePointErrorHandlers & {\n    strictNumericEscape(pos: number, lineStart: number, curLine: number): void;\n  };\n\nfunction readEscapedChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  inTemplate: boolean,\n  errors: EscapedCharErrorHandlers,\n) {\n  const throwOnInvalid = !inTemplate;\n  pos++; // skip '\\'\n\n  const res = (ch: string | null) => ({ pos, ch, lineStart, curLine });\n\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case charCodes.lowercaseN:\n      return res(\"\\n\");\n    case charCodes.lowercaseR:\n      return res(\"\\r\");\n    case charCodes.lowercaseX: {\n      let code;\n      ({ code, pos } = readHexChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        2,\n        false,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCharCode(code));\n    }\n    case charCodes.lowercaseU: {\n      let code;\n      ({ code, pos } = readCodePoint(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCodePoint(code));\n    }\n    case charCodes.lowercaseT:\n      return res(\"\\t\");\n    case charCodes.lowercaseB:\n      return res(\"\\b\");\n    case charCodes.lowercaseV:\n      return res(\"\\u000b\");\n    case charCodes.lowercaseF:\n      return res(\"\\f\");\n    case charCodes.carriageReturn:\n      if (input.charCodeAt(pos) === charCodes.lineFeed) {\n        ++pos;\n      }\n    // fall through\n    case charCodes.lineFeed:\n      lineStart = pos;\n      ++curLine;\n    // fall through\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return res(\"\");\n    case charCodes.digit8:\n    case charCodes.digit9:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    // fall through\n    default:\n      if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/)!;\n\n        let octalStr = match[0];\n\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (\n          octalStr !== \"0\" ||\n          next === charCodes.digit8 ||\n          next === charCodes.digit9\n        ) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n\n        return res(String.fromCharCode(octal));\n      }\n\n      return res(String.fromCharCode(ch));\n  }\n}\n\ntype HexCharErrorHandlers = IntErrorHandlers & {\n  invalidEscapeSequence(pos: number, lineStart: number, curLine: number): void;\n};\n\n// Used to read character escape sequences ('\\x', '\\u').\nfunction readHexChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  len: number,\n  forceLen: boolean,\n  throwOnInvalid: boolean,\n  errors: HexCharErrorHandlers,\n) {\n  const initialPos = pos;\n  let n;\n  ({ n, pos } = readInt(\n    input,\n    pos,\n    lineStart,\n    curLine,\n    16,\n    len,\n    forceLen,\n    false,\n    errors,\n    /* bailOnError */ !throwOnInvalid,\n  ));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return { code: n, pos };\n}\n\nexport type IntErrorHandlers = {\n  numericSeparatorInEscapeSequence(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  unexpectedNumericSeparator(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  // It can return \"true\" to indicate that the error was handled\n  // and the int parsing should continue.\n  invalidDigit(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n    radix: number,\n  ): boolean;\n};\n\nexport function readInt(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  radix: number,\n  len: number | undefined,\n  forceLen: boolean,\n  allowNumSeparator: boolean | \"bail\",\n  errors: IntErrorHandlers,\n  bailOnError: boolean,\n) {\n  const start = pos;\n  const forbiddenSiblings =\n    radix === 16\n      ? forbiddenNumericSeparatorSiblings.hex\n      : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling =\n    radix === 16\n      ? isAllowedNumericSeparatorSibling.hex\n      : radix === 10\n      ? isAllowedNumericSeparatorSibling.dec\n      : radix === 8\n      ? isAllowedNumericSeparatorSibling.oct\n      : isAllowedNumericSeparatorSibling.bin;\n\n  let invalid = false;\n  let total = 0;\n\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n\n    if (code === charCodes.underscore && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n\n      if (!allowNumSeparator) {\n        if (bailOnError) return { n: null, pos };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (\n        Number.isNaN(next) ||\n        !isAllowedSibling(next) ||\n        forbiddenSiblings.has(prev) ||\n        forbiddenSiblings.has(next)\n      ) {\n        if (bailOnError) return { n: null, pos };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      // Ignore this _ character\n      ++pos;\n      continue;\n    }\n\n    if (code >= charCodes.lowercaseA) {\n      val = code - charCodes.lowercaseA + charCodes.lineFeed;\n    } else if (code >= charCodes.uppercaseA) {\n      val = code - charCodes.uppercaseA + charCodes.lineFeed;\n    } else if (charCodes.isDigit(code)) {\n      val = code - charCodes.digit0; // 0-9\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      // If we found a digit which is too big, errors.invalidDigit can return true to avoid\n      // breaking the loop (this is used for error recovery).\n      if (val <= 9 && bailOnError) {\n        return { n: null, pos };\n      } else if (\n        val <= 9 &&\n        errors.invalidDigit(pos, lineStart, curLine, radix)\n      ) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || (len != null && pos - start !== len) || invalid) {\n    return { n: null, pos };\n  }\n\n  return { n: total, pos };\n}\n\nexport type CodePointErrorHandlers = HexCharErrorHandlers & {\n  invalidCodePoint(pos: number, lineStart: number, curLine: number): void;\n};\n\nexport function readCodePoint(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  throwOnInvalid: boolean,\n  errors: CodePointErrorHandlers,\n) {\n  const ch = input.charCodeAt(pos);\n  let code;\n\n  if (ch === charCodes.leftCurlyBrace) {\n    ++pos;\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      input.indexOf(\"}\", pos) - pos,\n      true,\n      throwOnInvalid,\n      errors,\n    ));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return { code: null, pos };\n      }\n    }\n  } else {\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      4,\n      false,\n      throwOnInvalid,\n      errors,\n    ));\n  }\n  return { code, pos };\n}\n"]},"metadata":{},"sourceType":"script"}
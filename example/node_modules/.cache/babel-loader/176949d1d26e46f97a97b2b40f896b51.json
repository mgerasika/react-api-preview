{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\nvar _t = require(\"@babel/types\");\nvar _parser = require(\"@babel/parser\");\nvar _codeFrame = require(\"@babel/code-frame\");\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n  let name;\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","parseAndBuildMetadata","_t","require","_parser","_codeFrame","isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","PATTERN","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","validate","syntactic","placeholders","placeholderNames","Set","legacy","isLegacyRef","undefined","placeholderVisitorHandler","assign","node","ancestors","state","_state$placeholderWhi","name","Error","test","has","slice","parent","key","length","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","i","index","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","parse","err","loc","message","codeFrameColumns","start"],"sources":["/home/mgerasika/Documents/git/oddbox/oddbox-frontend-npm-usage-example/node_modules/@babel/template/lib/parse.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\n\nvar _t = require(\"@babel/types\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const syntactic = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const legacy = {\n    placeholders: [],\n    placeholderNames: new Set()\n  };\n  const isLegacyRef = {\n    value: undefined\n  };\n  traverse(ast, placeholderVisitorHandler, {\n    syntactic,\n    legacy,\n    isLegacyRef,\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  });\n  return Object.assign({\n    ast\n  }, isLegacyRef.value ? legacy : syntactic);\n}\n\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n\n  let name;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    } else {\n      name = node.name.name;\n      state.isLegacyRef.value = false;\n    }\n  } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n    state.isLegacyRef.value = true;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n    state.isLegacyRef.value = true;\n  } else {\n    return;\n  }\n\n  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n\n  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const {\n    placeholders,\n    placeholderNames\n  } = state.isLegacyRef.value ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\n\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,qBAAqB;AAEvC,IAAIC,EAAE,GAAGC,OAAO,CAAC,cAAc,CAAC;AAEhC,IAAIC,OAAO,GAAGD,OAAO,CAAC,eAAe,CAAC;AAEtC,IAAIE,UAAU,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAE7C,MAAM;EACJG,gBAAgB;EAChBC,qBAAqB;EACrBC,UAAU;EACVC,YAAY;EACZC,eAAe;EACfC,eAAe;EACfC,aAAa;EACbC,WAAW;EACXC,eAAe;EACfC,oBAAoB;EACpBC;AACF,CAAC,GAAGd,EAAE;AACN,MAAMe,OAAO,GAAG,eAAe;AAE/B,SAAShB,qBAAqB,CAACiB,SAAS,EAAEC,IAAI,EAAEC,IAAI,EAAE;EACpD,MAAM;IACJC,oBAAoB;IACpBC,kBAAkB;IAClBC,gBAAgB;IAChBC;EACF,CAAC,GAAGJ,IAAI;EACR,MAAMK,GAAG,GAAGC,kBAAkB,CAACP,IAAI,EAAEC,IAAI,CAACO,MAAM,EAAEH,qBAAqB,CAAC;EACxET,oBAAoB,CAACU,GAAG,EAAE;IACxBF;EACF,CAAC,CAAC;EACFL,SAAS,CAACU,QAAQ,CAACH,GAAG,CAAC;EACvB,MAAMI,SAAS,GAAG;IAChBC,YAAY,EAAE,EAAE;IAChBC,gBAAgB,EAAE,IAAIC,GAAG;EAC3B,CAAC;EACD,MAAMC,MAAM,GAAG;IACbH,YAAY,EAAE,EAAE;IAChBC,gBAAgB,EAAE,IAAIC,GAAG;EAC3B,CAAC;EACD,MAAME,WAAW,GAAG;IAClBnC,KAAK,EAAEoC;EACT,CAAC;EACDnB,QAAQ,CAACS,GAAG,EAAEW,yBAAyB,EAAE;IACvCP,SAAS;IACTI,MAAM;IACNC,WAAW;IACXb,oBAAoB;IACpBC,kBAAkB;IAClBE;EACF,CAAC,CAAC;EACF,OAAO5B,MAAM,CAACyC,MAAM,CAAC;IACnBZ;EACF,CAAC,EAAES,WAAW,CAACnC,KAAK,GAAGkC,MAAM,GAAGJ,SAAS,CAAC;AAC5C;AAEA,SAASO,yBAAyB,CAACE,IAAI,EAAEC,SAAS,EAAEC,KAAK,EAAE;EACzD,IAAIC,qBAAqB;EAEzB,IAAIC,IAAI;EAER,IAAI9B,aAAa,CAAC0B,IAAI,CAAC,EAAE;IACvB,IAAIE,KAAK,CAAChB,qBAAqB,KAAK,KAAK,EAAE;MACzC,MAAM,IAAImB,KAAK,CAAC,gDAAgD,GAAG,oCAAoC,CAAC;IAC1G,CAAC,MAAM;MACLD,IAAI,GAAGJ,IAAI,CAACI,IAAI,CAACA,IAAI;MACrBF,KAAK,CAACN,WAAW,CAACnC,KAAK,GAAG,KAAK;IACjC;EACF,CAAC,MAAM,IAAIyC,KAAK,CAACN,WAAW,CAACnC,KAAK,KAAK,KAAK,IAAIyC,KAAK,CAAChB,qBAAqB,EAAE;IAC3E;EACF,CAAC,MAAM,IAAIf,YAAY,CAAC6B,IAAI,CAAC,IAAI5B,eAAe,CAAC4B,IAAI,CAAC,EAAE;IACtDI,IAAI,GAAGJ,IAAI,CAACI,IAAI;IAChBF,KAAK,CAACN,WAAW,CAACnC,KAAK,GAAG,IAAI;EAChC,CAAC,MAAM,IAAIe,eAAe,CAACwB,IAAI,CAAC,EAAE;IAChCI,IAAI,GAAGJ,IAAI,CAACvC,KAAK;IACjByC,KAAK,CAACN,WAAW,CAACnC,KAAK,GAAG,IAAI;EAChC,CAAC,MAAM;IACL;EACF;EAEA,IAAI,CAACyC,KAAK,CAACN,WAAW,CAACnC,KAAK,KAAKyC,KAAK,CAAClB,kBAAkB,IAAI,IAAI,IAAIkB,KAAK,CAACnB,oBAAoB,IAAI,IAAI,CAAC,EAAE;IACxG,MAAM,IAAIsB,KAAK,CAAC,qEAAqE,GAAG,sCAAsC,CAAC;EACjI;EAEA,IAAIH,KAAK,CAACN,WAAW,CAACnC,KAAK,KAAKyC,KAAK,CAAClB,kBAAkB,KAAK,KAAK,IAAI,CAAC,CAACkB,KAAK,CAAClB,kBAAkB,IAAIL,OAAO,EAAE2B,IAAI,CAACF,IAAI,CAAC,CAAC,IAAI,EAAE,CAACD,qBAAqB,GAAGD,KAAK,CAACnB,oBAAoB,KAAK,IAAI,IAAIoB,qBAAqB,CAACI,GAAG,CAACH,IAAI,CAAC,CAAC,EAAE;IAC9N;EACF;EAEAH,SAAS,GAAGA,SAAS,CAACO,KAAK,EAAE;EAC7B,MAAM;IACJR,IAAI,EAAES,MAAM;IACZC;EACF,CAAC,GAAGT,SAAS,CAACA,SAAS,CAACU,MAAM,GAAG,CAAC,CAAC;EACnC,IAAIC,IAAI;EAER,IAAIpC,eAAe,CAACwB,IAAI,CAAC,IAAI1B,aAAa,CAAC0B,IAAI,EAAE;IAC/Ca,YAAY,EAAE;EAChB,CAAC,CAAC,EAAE;IACFD,IAAI,GAAG,QAAQ;EACjB,CAAC,MAAM,IAAIvC,eAAe,CAACoC,MAAM,CAAC,IAAIC,GAAG,KAAK,WAAW,IAAI1C,gBAAgB,CAACyC,MAAM,CAAC,IAAIC,GAAG,KAAK,WAAW,IAAIxC,UAAU,CAACuC,MAAM,CAAC,IAAIC,GAAG,KAAK,QAAQ,EAAE;IACtJE,IAAI,GAAG,OAAO;EAChB,CAAC,MAAM,IAAI3C,qBAAqB,CAACwC,MAAM,CAAC,IAAI,CAACnC,aAAa,CAAC0B,IAAI,CAAC,EAAE;IAChEY,IAAI,GAAG,WAAW;IAClBX,SAAS,GAAGA,SAAS,CAACO,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACpC,CAAC,MAAM,IAAIjC,WAAW,CAACyB,IAAI,CAAC,IAAI1B,aAAa,CAAC0B,IAAI,CAAC,EAAE;IACnDY,IAAI,GAAG,WAAW;EACpB,CAAC,MAAM;IACLA,IAAI,GAAG,OAAO;EAChB;EAEA,MAAM;IACJpB,YAAY;IACZC;EACF,CAAC,GAAGS,KAAK,CAACN,WAAW,CAACnC,KAAK,GAAGyC,KAAK,CAACP,MAAM,GAAGO,KAAK,CAACX,SAAS;EAC5DC,YAAY,CAACsB,IAAI,CAAC;IAChBV,IAAI;IACJQ,IAAI;IACJG,OAAO,EAAE5B,GAAG,IAAI6B,gBAAgB,CAAC7B,GAAG,EAAEc,SAAS,CAAC;IAChDgB,WAAW,EAAExB,gBAAgB,CAACc,GAAG,CAACH,IAAI;EACxC,CAAC,CAAC;EACFX,gBAAgB,CAACyB,GAAG,CAACd,IAAI,CAAC;AAC5B;AAEA,SAASY,gBAAgB,CAAC7B,GAAG,EAAEc,SAAS,EAAE;EACxC,IAAIQ,MAAM,GAAGtB,GAAG;EAEhB,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,SAAS,CAACU,MAAM,GAAG,CAAC,EAAEQ,CAAC,EAAE,EAAE;IAC7C,MAAM;MACJT,GAAG;MACHU;IACF,CAAC,GAAGnB,SAAS,CAACkB,CAAC,CAAC;IAEhB,IAAIC,KAAK,KAAKvB,SAAS,EAAE;MACvBY,MAAM,GAAGA,MAAM,CAACC,GAAG,CAAC;IACtB,CAAC,MAAM;MACLD,MAAM,GAAGA,MAAM,CAACC,GAAG,CAAC,CAACU,KAAK,CAAC;IAC7B;EACF;EAEA,MAAM;IACJV,GAAG;IACHU;EACF,CAAC,GAAGnB,SAAS,CAACA,SAAS,CAACU,MAAM,GAAG,CAAC,CAAC;EACnC,OAAO;IACLF,MAAM;IACNC,GAAG;IACHU;EACF,CAAC;AACH;AAEA,SAAShC,kBAAkB,CAACP,IAAI,EAAEwC,UAAU,EAAEnC,qBAAqB,EAAE;EACnE,MAAMoC,OAAO,GAAG,CAACD,UAAU,CAACC,OAAO,IAAI,EAAE,EAAEd,KAAK,EAAE;EAElD,IAAItB,qBAAqB,KAAK,KAAK,EAAE;IACnCoC,OAAO,CAACR,IAAI,CAAC,cAAc,CAAC;EAC9B;EAEAO,UAAU,GAAG/D,MAAM,CAACyC,MAAM,CAAC;IACzBwB,0BAA0B,EAAE,IAAI;IAChCC,uBAAuB,EAAE,IAAI;IAC7BC,UAAU,EAAE;EACd,CAAC,EAAEJ,UAAU,EAAE;IACbC;EACF,CAAC,CAAC;EAEF,IAAI;IACF,OAAO,CAAC,CAAC,EAAExD,OAAO,CAAC4D,KAAK,EAAE7C,IAAI,EAAEwC,UAAU,CAAC;EAC7C,CAAC,CAAC,OAAOM,GAAG,EAAE;IACZ,MAAMC,GAAG,GAAGD,GAAG,CAACC,GAAG;IAEnB,IAAIA,GAAG,EAAE;MACPD,GAAG,CAACE,OAAO,IAAI,IAAI,GAAG,CAAC,CAAC,EAAE9D,UAAU,CAAC+D,gBAAgB,EAAEjD,IAAI,EAAE;QAC3DkD,KAAK,EAAEH;MACT,CAAC,CAAC;MACFD,GAAG,CAAC9C,IAAI,GAAG,4BAA4B;IACzC;IAEA,MAAM8C,GAAG;EACX;AACF"},"metadata":{},"sourceType":"script"}
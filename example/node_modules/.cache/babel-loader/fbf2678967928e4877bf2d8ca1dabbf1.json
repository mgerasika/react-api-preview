{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { createCollection, getItem, deleteFromCollection, addToCollection, updateCollection } from './create-collection.util.js';\nfunction createInfiniteCollection(data, next_page, request) {\n  return {\n    pageParams: [0],\n    pages: [createCollection(data, next_page, request)]\n  };\n}\nfunction deleteFromInfiniteCollection(data, id) {\n  if (!data) {\n    return createInfiniteCollection([], 0, {});\n  }\n  return _objectSpread(_objectSpread({}, data), {}, {\n    pages: data.pages.map(function (page) {\n      if (getItem(page, id)) {\n        return deleteFromCollection(page, id);\n      }\n      return page;\n    })\n  });\n}\n\n// TODO implement\nfunction addToInfiniteCollection(data, item) {\n  if (!data) {\n    return createInfiniteCollection([item], 0, {});\n  }\n  var _data$pages = _toArray(data.pages),\n    first = _data$pages[0],\n    rest = _data$pages.slice(1);\n  return _objectSpread(_objectSpread({}, data), {}, {\n    pages: [addToCollection(first, item)].concat(_toConsumableArray(rest))\n  });\n}\n\n// TODO implement\nfunction updateInfiniteCollection(data, id, newItem) {\n  if (!data) {\n    return createInfiniteCollection([newItem], 0, {});\n  }\n  return _objectSpread(_objectSpread({}, data), {}, {\n    pages: data.pages.map(function (page) {\n      if (getItem(page, id)) {\n        return updateCollection(page, id, newItem);\n      }\n      return page;\n    })\n  });\n}\nexport { addToInfiniteCollection, createInfiniteCollection, deleteFromInfiniteCollection, updateInfiniteCollection };","map":{"version":3,"sources":["../../../src/utils/create-infinite-collection.util.ts"],"names":["createInfiniteCollection","data","next_page","request","pageParams","pages","createCollection","deleteFromInfiniteCollection","id","map","page","getItem","deleteFromCollection","addToInfiniteCollection","item","first","rest","addToCollection","updateInfiniteCollection","newItem","updateCollection"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAYO,SAASA,wBAAwB,CACpCC,IAAqB,EACrBC,SAA6B,EAC7BC,OAAsE,EAChD;EACtB,OAAO;IACHC,UAAU,EAAE,CAAC,CAAC,CAAC;IACfC,KAAK,EAAE,CAACC,gBAAgB,CAACL,IAAI,EAAEC,SAAS,EAAEC,OAAO,CAAC;GACrD;AACL;AAEO,SAASI,4BAA4B,CACxCN,IAAwC,EACxCO,EAAO,EACe;EACtB,IAAI,CAACP,IAAI,EAAE;IACP,OAAOD,wBAAwB,CAAC,EAAE,EAAE,CAAC,EAAE,CAAE,CAAA,CAAC;EAC9C;EACA,OAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EACOC,IAAI,CAAA,EAAA,CAAA,CAAA,EAAA;IACPI,KAAK,EAAEJ,IAAI,CAACI,KAAK,CAACI,GAAG,CAAEC,UAAAA,IAAI,EAAK;MAC5B,IAAIC,OAAO,CAACD,IAAI,EAAEF,EAAE,CAAC,EAAE;QACnB,OAAOI,oBAAoB,CAACF,IAAI,EAAEF,EAAE,CAAC;MACzC;MACA,OAAOE,IAAI;KACd;EAAA,CAAA,CAAA;AAET;;AAEA;AACO,SAASG,uBAAuB,CACnCZ,IAAwC,EACxCa,IAAO,EACe;EACtB,IAAI,CAACb,IAAI,EAAE;IACP,OAAOD,wBAAwB,CAAC,CAACc,IAAI,CAAC,EAAE,CAAC,EAAE,CAAE,CAAA,CAAC;EAClD;EACA,IAAA,WAAA,GAAA,QAAA,CAAyBb,IAAI,CAACI,KAAK,CAAA;IAA5BU,KAAK,GAAA,WAAA,CAAA,CAAA,CAAA;IAAKC,IAAI,GAAA,WAAA,CAAA,KAAA,CAAA,CAAA,CAAA;EACrB,OAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EACOf,IAAI,CAAA,EAAA,CAAA,CAAA,EAAA;IACPI,KAAK,EAAA,CAAGY,eAAe,CAACF,KAAK,EAAED,IAAI,CAAC,CAAA,CAAA,MAAA,CAAA,kBAAA,CAAKE,IAAI,CAAA;EAAA,CAAA,CAAA;AAErD;;AAEA;AACO,SAASE,wBAAwB,CACpCjB,IAAwC,EACxCO,EAAO,EACPW,OAAU,EACY;EACtB,IAAI,CAAClB,IAAI,EAAE;IACP,OAAOD,wBAAwB,CAAC,CAACmB,OAAO,CAAC,EAAE,CAAC,EAAE,CAAE,CAAA,CAAC;EACrD;EACA,OAAA,aAAA,CAAA,aAAA,CAAA,CAAA,CAAA,EACOlB,IAAI,CAAA,EAAA,CAAA,CAAA,EAAA;IACPI,KAAK,EAAEJ,IAAI,CAACI,KAAK,CAACI,GAAG,CAAEC,UAAAA,IAAI,EAAK;MAC5B,IAAIC,OAAO,CAACD,IAAI,EAAEF,EAAE,CAAC,EAAE;QACnB,OAAOY,gBAAgB,CAACV,IAAI,EAAEF,EAAE,EAAEW,OAAO,CAAC;MAC9C;MACA,OAAOT,IAAI;KACd;EAAA,CAAA,CAAA;AAET","sourcesContent":["import { ICollectionRequestOptions } from '@common/interfaces/collection-request-options.interface';\nimport { IIdObject } from '@common/interfaces/id-object.interface';\nimport { IInfiniteCollection } from '@common/interfaces/infinite-collection.interface';\nimport { UID } from '@common/interfaces/uid.interface';\nimport {\n    addToCollection,\n    createCollection,\n    deleteFromCollection,\n    getItem,\n    updateCollection,\n} from './create-collection.util';\n\nexport function createInfiniteCollection<T>(\n    data: T[] | undefined,\n    next_page: number | undefined,\n    request: Omit<ICollectionRequestOptions, 'limit'> & { limit?: number },\n): IInfiniteCollection<T> {\n    return {\n        pageParams: [0],\n        pages: [createCollection(data, next_page, request)],\n    };\n}\n\nexport function deleteFromInfiniteCollection<T extends IIdObject>(\n    data: IInfiniteCollection<T> | undefined,\n    id: UID,\n): IInfiniteCollection<T> {\n    if (!data) {\n        return createInfiniteCollection([], 0, {});\n    }\n    return {\n        ...data,\n        pages: data.pages.map((page) => {\n            if (getItem(page, id)) {\n                return deleteFromCollection(page, id);\n            }\n            return page;\n        }),\n    };\n}\n\n// TODO implement\nexport function addToInfiniteCollection<T extends IIdObject>(\n    data: IInfiniteCollection<T> | undefined,\n    item: T,\n): IInfiniteCollection<T> {\n    if (!data) {\n        return createInfiniteCollection([item], 0, {});\n    }\n    const [first, ...rest] = data.pages;\n    return {\n        ...data,\n        pages: [addToCollection(first, item), ...rest],\n    };\n}\n\n// TODO implement\nexport function updateInfiniteCollection<T extends IIdObject>(\n    data: IInfiniteCollection<T> | undefined,\n    id: UID,\n    newItem: T,\n): IInfiniteCollection<T> {\n    if (!data) {\n        return createInfiniteCollection([newItem], 0, {});\n    }\n    return {\n        ...data,\n        pages: data.pages.map((page) => {\n            if (getItem(page, id)) {\n                return updateCollection(page, id, newItem);\n            }\n            return page;\n        }),\n    };\n}\n"]},"metadata":{},"sourceType":"module"}
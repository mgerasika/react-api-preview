{"ast":null,"code":"import { Crc32 } from \"@aws-crypto/crc32\";\n// All prelude components are unsigned, 32-bit integers\nvar PRELUDE_MEMBER_LENGTH = 4;\n// The prelude consists of two components\nvar PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\n// Checksums are always CRC32 hashes.\nvar CHECKSUM_LENGTH = 4;\n// Messages must include a full prelude, a prelude checksum, and a message checksum\nvar MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n/**\n * @internal\n */\nexport function splitMessage(_a) {\n  var byteLength = _a.byteLength,\n    byteOffset = _a.byteOffset,\n    buffer = _a.buffer;\n  if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n  }\n  var view = new DataView(buffer, byteOffset, byteLength);\n  var messageLength = view.getUint32(0, false);\n  if (byteLength !== messageLength) {\n    throw new Error(\"Reported message length does not match received message length\");\n  }\n  var headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n  var expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n  var expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n  var checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n  if (expectedPreludeChecksum !== checksummer.digest()) {\n    throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum (\" + checksummer.digest() + \")\");\n  }\n  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n  if (expectedMessageChecksum !== checksummer.digest()) {\n    throw new Error(\"The message checksum (\" + checksummer.digest() + \") did not match the expected value of \" + expectedMessageChecksum);\n  }\n  return {\n    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))\n  };\n}","map":{"version":3,"sources":["../../src/splitMessage.ts"],"names":[],"mappings":"AAAA,SAAS,KAAK,QAAQ,mBAAmB;AAEzC;AACA,IAAM,qBAAqB,GAAG,CAAC;AAC/B;AACA,IAAM,cAAc,GAAG,qBAAqB,GAAG,CAAC;AAChD;AACA,IAAM,eAAe,GAAG,CAAC;AACzB;AACA,IAAM,sBAAsB,GAAG,cAAc,GAAG,eAAe,GAAG,CAAC;AAUnE;;AAEG;AACH,OAAM,SAAU,YAAY,CAAC,EAAmD,EAAA;MAAjD,UAAU,GAAA,EAAA,CAAA,UAAA;IAAE,UAAU,GAAA,EAAA,CAAA,UAAA;IAAE,MAAM,GAAA,EAAA,CAAA,MAAA;EAC3D,IAAI,UAAU,GAAG,sBAAsB,EAAE;IACvC,MAAM,IAAI,KAAK,CAAC,yEAAyE,CAAC;EAC3F;EAED,IAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,EAAE,UAAU,EAAE,UAAU,CAAC;EAEzD,IAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;EAE9C,IAAI,UAAU,KAAK,aAAa,EAAE;IAChC,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC;EAClF;EAED,IAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,qBAAqB,EAAE,KAAK,CAAC;EACjE,IAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;EACrE,IAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,GAAG,eAAe,EAAE,KAAK,CAAC;EAEnF,IAAM,WAAW,GAAG,IAAI,KAAK,EAAE,CAAC,MAAM,CAAC,IAAI,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,cAAc,CAAC,CAAC;EAC1F,IAAI,uBAAuB,KAAK,WAAW,CAAC,MAAM,EAAE,EAAE;IACpD,MAAM,IAAI,KAAK,CACb,iDAAA,GAAkD,uBAAuB,GAAA,kDAAA,GAAmD,WAAW,CAAC,MAAM,EAAE,GAAA,GAAG,CACpJ;EACF;EAED,WAAW,CAAC,MAAM,CAChB,IAAI,UAAU,CAAC,MAAM,EAAE,UAAU,GAAG,cAAc,EAAE,UAAU,IAAI,cAAc,GAAG,eAAe,CAAC,CAAC,CACrG;EACD,IAAI,uBAAuB,KAAK,WAAW,CAAC,MAAM,EAAE,EAAE;IACpD,MAAM,IAAI,KAAK,CACb,wBAAA,GAAyB,WAAW,CAAC,MAAM,EAAE,GAAA,wCAAA,GAAyC,uBAAyB,CAChH;EACF;EAED,OAAO;IACL,OAAO,EAAE,IAAI,QAAQ,CAAC,MAAM,EAAE,UAAU,GAAG,cAAc,GAAG,eAAe,EAAE,YAAY,CAAC;IAC1F,IAAI,EAAE,IAAI,UAAU,CAClB,MAAM,EACN,UAAU,GAAG,cAAc,GAAG,eAAe,GAAG,YAAY,EAC5D,aAAa,GAAG,YAAY,IAAI,cAAc,GAAG,eAAe,GAAG,eAAe,CAAC;GAEtF;AACH","sourcesContent":["import { Crc32 } from \"@aws-crypto/crc32\";\n\n// All prelude components are unsigned, 32-bit integers\nconst PRELUDE_MEMBER_LENGTH = 4;\n// The prelude consists of two components\nconst PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\n// Checksums are always CRC32 hashes.\nconst CHECKSUM_LENGTH = 4;\n// Messages must include a full prelude, a prelude checksum, and a message checksum\nconst MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n\n/**\n * @internal\n */\nexport interface MessageParts {\n  headers: DataView;\n  body: Uint8Array;\n}\n\n/**\n * @internal\n */\nexport function splitMessage({ byteLength, byteOffset, buffer }: ArrayBufferView): MessageParts {\n  if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error(\"Provided message too short to accommodate event stream message overhead\");\n  }\n\n  const view = new DataView(buffer, byteOffset, byteLength);\n\n  const messageLength = view.getUint32(0, false);\n\n  if (byteLength !== messageLength) {\n    throw new Error(\"Reported message length does not match received message length\");\n  }\n\n  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n\n  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n  if (expectedPreludeChecksum !== checksummer.digest()) {\n    throw new Error(\n      `The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`\n    );\n  }\n\n  checksummer.update(\n    new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH))\n  );\n  if (expectedMessageChecksum !== checksummer.digest()) {\n    throw new Error(\n      `The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`\n    );\n  }\n\n  return {\n    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n    body: new Uint8Array(\n      buffer,\n      byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength,\n      messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)\n    ),\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
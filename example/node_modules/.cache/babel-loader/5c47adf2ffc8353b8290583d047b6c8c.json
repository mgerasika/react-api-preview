{"ast":null,"code":"import { __read } from \"tslib\";\nvar DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nvar IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nvar DOTS_PATTERN = /\\.\\./;\nexport var DOT_PATTERN = /\\./;\nexport var S3_HOSTNAME_PATTERN = /^(.+\\.)?s3[.-]([a-z0-9-]+)\\./;\nvar S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\\.amazonaws\\.com$/;\nvar AWS_PARTITION_SUFFIX = \"amazonaws.com\";\nexport var isBucketNameOptions = function isBucketNameOptions(options) {\n  return typeof options.bucketName === \"string\";\n};\n/**\n * Get pseudo region from supplied region. For example, if supplied with `fips-us-west-2`, it returns `us-west-2`.\n * @internal\n */\nexport var getPseudoRegion = function getPseudoRegion(region) {\n  return isFipsRegion(region) ? region.replace(/fips-|-fips/, \"\") : region;\n};\n/**\n * Determines whether a given string is DNS compliant per the rules outlined by\n * S3. Length, capitaization, and leading dot restrictions are enforced by the\n * DOMAIN_PATTERN regular expression.\n * @internal\n *\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n */\nexport var isDnsCompatibleBucketName = function isDnsCompatibleBucketName(bucketName) {\n  return DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\n};\nvar getRegionalSuffix = function getRegionalSuffix(hostname) {\n  var parts = hostname.match(S3_HOSTNAME_PATTERN);\n  return [parts[2], hostname.replace(new RegExp(\"^\" + parts[0]), \"\")];\n};\nexport var getSuffix = function getSuffix(hostname) {\n  return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [\"us-east-1\", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n};\n/**\n * Infer region and hostname suffix from a complete hostname\n * @internal\n * @param hostname - Hostname\n * @returns [Region, Hostname suffix]\n */\nexport var getSuffixForArnEndpoint = function getSuffixForArnEndpoint(hostname) {\n  return S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [hostname.replace(\".\" + AWS_PARTITION_SUFFIX, \"\"), AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n};\nexport var validateArnEndpointOptions = function validateArnEndpointOptions(options) {\n  if (options.pathStyleEndpoint) {\n    throw new Error(\"Path-style S3 endpoint is not supported when bucket is an ARN\");\n  }\n  if (options.accelerateEndpoint) {\n    throw new Error(\"Accelerate endpoint is not supported when bucket is an ARN\");\n  }\n  if (!options.tlsCompatible) {\n    throw new Error(\"HTTPS is required when bucket is an ARN\");\n  }\n};\nexport var validateService = function validateService(service) {\n  if (service !== \"s3\" && service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3' or 's3-outposts' in ARN service component\");\n  }\n};\nexport var validateS3Service = function validateS3Service(service) {\n  if (service !== \"s3\") {\n    throw new Error(\"Expect 's3' in Accesspoint ARN service component\");\n  }\n};\nexport var validateOutpostService = function validateOutpostService(service) {\n  if (service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3-posts' in Outpost ARN service component\");\n  }\n};\n/**\n * Validate partition inferred from ARN is the same to `options.clientPartition`.\n * @internal\n */\nexport var validatePartition = function validatePartition(partition, options) {\n  if (partition !== options.clientPartition) {\n    throw new Error(\"Partition in ARN is incompatible, got \\\"\" + partition + \"\\\" but expected \\\"\" + options.clientPartition + \"\\\"\");\n  }\n};\n/**\n * validate region value inferred from ARN. If `options.useArnRegion` is set, it validates the region is not a FIPS\n * region. If `options.useArnRegion` is unset, it validates the region is equal to `options.clientRegion` or\n * `options.clientSigningRegion`.\n * @internal\n */\nexport var validateRegion = function validateRegion(region, options) {\n  if (region === \"\") {\n    throw new Error(\"ARN region is empty\");\n  }\n  if (!options.useArnRegion && !isEqualRegions(region, options.clientRegion) && !isEqualRegions(region, options.clientSigningRegion)) {\n    throw new Error(\"Region in ARN is incompatible, got \" + region + \" but expected \" + options.clientRegion);\n  }\n  if (options.useArnRegion && isFipsRegion(region)) {\n    throw new Error(\"Endpoint does not support FIPS region\");\n  }\n};\nvar isFipsRegion = function isFipsRegion(region) {\n  return region.startsWith(\"fips-\") || region.endsWith(\"-fips\");\n};\nvar isEqualRegions = function isEqualRegions(regionA, regionB) {\n  return regionA === regionB || getPseudoRegion(regionA) === regionB || regionA === getPseudoRegion(regionB);\n};\n/**\n * Validate an account ID\n * @internal\n */\nexport var validateAccountId = function validateAccountId(accountId) {\n  if (!/[0-9]{12}/.exec(accountId)) {\n    throw new Error(\"Access point ARN accountID does not match regex '[0-9]{12}'\");\n  }\n};\n/**\n * Validate a host label according to https://tools.ietf.org/html/rfc3986#section-3.2.2\n * @internal\n */\nexport var validateDNSHostLabel = function validateDNSHostLabel(label, options) {\n  if (options === void 0) {\n    options = {\n      tlsCompatible: true\n    };\n  }\n  // reference: https://tools.ietf.org/html/rfc3986#section-3.2.2\n  if (label.length >= 64 || !/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(label) || /(\\d+\\.){3}\\d+/.test(label) || /[.-]{2}/.test(label) || (options === null || options === void 0 ? void 0 : options.tlsCompatible) && DOT_PATTERN.test(label)) {\n    throw new Error(\"Invalid DNS label \" + label);\n  }\n};\n/**\n * Validate and parse an Access Point ARN or Outposts ARN\n * @internal\n *\n * @param resource - The resource section of an ARN\n * @returns Access Point Name and optional Outpost ID.\n */\nexport var getArnResources = function getArnResources(resource) {\n  var delimiter = resource.includes(\":\") ? \":\" : \"/\";\n  var _a = __read(resource.split(delimiter)),\n    resourceType = _a[0],\n    rest = _a.slice(1);\n  if (resourceType === \"accesspoint\") {\n    // Parse accesspoint ARN\n    if (rest.length !== 1 || rest[0] === \"\") {\n      throw new Error(\"Access Point ARN should have one resource accesspoint\" + delimiter + \"{accesspointname}\");\n    }\n    return {\n      accesspointName: rest[0]\n    };\n  } else if (resourceType === \"outpost\") {\n    // Parse outpost ARN\n    if (!rest[0] || rest[1] !== \"accesspoint\" || !rest[2] || rest.length !== 3) {\n      throw new Error(\"Outpost ARN should have resource outpost\" + delimiter + \"{outpostId}\" + delimiter + \"accesspoint\" + delimiter + \"{accesspointName}\");\n    }\n    var _b = __read(rest, 3),\n      outpostId = _b[0],\n      _ = _b[1],\n      accesspointName = _b[2];\n    return {\n      outpostId: outpostId,\n      accesspointName: accesspointName\n    };\n  } else {\n    throw new Error(\"ARN resource should begin with 'accesspoint\" + delimiter + \"' or 'outpost\" + delimiter + \"'\");\n  }\n};\n/**\n * Throw if dual stack configuration is set to true.\n * @internal\n */\nexport var validateNoDualstack = function validateNoDualstack(dualstackEndpoint) {\n  if (dualstackEndpoint) throw new Error(\"Dualstack endpoint is not supported with Outpost\");\n};\n/**\n * Validate region is not appended or prepended with a `fips-`\n * @internal\n */\nexport var validateNoFIPS = function validateNoFIPS(region) {\n  if (isFipsRegion(region !== null && region !== void 0 ? region : \"\")) throw new Error(\"FIPS region is not supported with Outpost, got \" + region);\n};","map":{"version":3,"sources":["../../src/bucketHostnameUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { ARN } from \"@aws-sdk/util-arn-parser\";\n\nconst DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\\.\\-]{1,61}[a-z0-9]$/;\nconst IP_ADDRESS_PATTERN = /(\\d+\\.){3}\\d+/;\nconst DOTS_PATTERN = /\\.\\./;\nexport const DOT_PATTERN = /\\./;\nexport const S3_HOSTNAME_PATTERN = /^(.+\\.)?s3[.-]([a-z0-9-]+)\\./;\nconst S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\\.amazonaws\\.com$/;\nconst AWS_PARTITION_SUFFIX = \"amazonaws.com\";\n\nexport interface AccessPointArn extends ARN {\n  accessPointName: string;\n}\n\nexport interface BucketHostnameParams {\n  isCustomEndpoint: boolean;\n  baseHostname: string;\n  bucketName: string;\n  clientRegion: string;\n  accelerateEndpoint?: boolean;\n  dualstackEndpoint?: boolean;\n  pathStyleEndpoint?: boolean;\n  tlsCompatible?: boolean;\n}\n\nexport interface ArnHostnameParams extends Omit<BucketHostnameParams, \"bucketName\"> {\n  bucketName: ARN;\n  clientSigningRegion?: string;\n  clientPartition?: string;\n  useArnRegion?: boolean;\n}\n\nexport const isBucketNameOptions = (\n  options: BucketHostnameParams | ArnHostnameParams\n): options is BucketHostnameParams => typeof options.bucketName === \"string\";\n\n/**\n * Get pseudo region from supplied region. For example, if supplied with `fips-us-west-2`, it returns `us-west-2`.\n * @internal\n */\nexport const getPseudoRegion = (region: string) => (isFipsRegion(region) ? region.replace(/fips-|-fips/, \"\") : region);\n\n/**\n * Determines whether a given string is DNS compliant per the rules outlined by\n * S3. Length, capitaization, and leading dot restrictions are enforced by the\n * DOMAIN_PATTERN regular expression.\n * @internal\n *\n * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html\n */\nexport const isDnsCompatibleBucketName = (bucketName: string): boolean =>\n  DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);\n\nconst getRegionalSuffix = (hostname: string): [string, string] => {\n  const parts = hostname.match(S3_HOSTNAME_PATTERN)!;\n  return [parts[2], hostname.replace(new RegExp(`^${parts[0]}`), \"\")];\n};\n\nexport const getSuffix = (hostname: string): [string, string] =>\n  S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [\"us-east-1\", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);\n\n/**\n * Infer region and hostname suffix from a complete hostname\n * @internal\n * @param hostname - Hostname\n * @returns [Region, Hostname suffix]\n */\nexport const getSuffixForArnEndpoint = (hostname: string): [string, string] =>\n  S3_US_EAST_1_ALTNAME_PATTERN.test(hostname)\n    ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, \"\"), AWS_PARTITION_SUFFIX]\n    : getRegionalSuffix(hostname);\n\nexport const validateArnEndpointOptions = (options: {\n  accelerateEndpoint?: boolean;\n  tlsCompatible?: boolean;\n  pathStyleEndpoint?: boolean;\n}) => {\n  if (options.pathStyleEndpoint) {\n    throw new Error(\"Path-style S3 endpoint is not supported when bucket is an ARN\");\n  }\n  if (options.accelerateEndpoint) {\n    throw new Error(\"Accelerate endpoint is not supported when bucket is an ARN\");\n  }\n  if (!options.tlsCompatible) {\n    throw new Error(\"HTTPS is required when bucket is an ARN\");\n  }\n};\n\nexport const validateService = (service: string) => {\n  if (service !== \"s3\" && service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3' or 's3-outposts' in ARN service component\");\n  }\n};\n\nexport const validateS3Service = (service: string) => {\n  if (service !== \"s3\") {\n    throw new Error(\"Expect 's3' in Accesspoint ARN service component\");\n  }\n};\n\nexport const validateOutpostService = (service: string) => {\n  if (service !== \"s3-outposts\") {\n    throw new Error(\"Expect 's3-posts' in Outpost ARN service component\");\n  }\n};\n\n/**\n * Validate partition inferred from ARN is the same to `options.clientPartition`.\n * @internal\n */\nexport const validatePartition = (partition: string, options: { clientPartition: string }) => {\n  if (partition !== options.clientPartition) {\n    throw new Error(`Partition in ARN is incompatible, got \"${partition}\" but expected \"${options.clientPartition}\"`);\n  }\n};\n\n/**\n * validate region value inferred from ARN. If `options.useArnRegion` is set, it validates the region is not a FIPS\n * region. If `options.useArnRegion` is unset, it validates the region is equal to `options.clientRegion` or\n * `options.clientSigningRegion`.\n * @internal\n */\nexport const validateRegion = (\n  region: string,\n  options: {\n    useArnRegion?: boolean;\n    clientRegion: string;\n    clientSigningRegion: string;\n  }\n) => {\n  if (region === \"\") {\n    throw new Error(\"ARN region is empty\");\n  }\n  if (\n    !options.useArnRegion &&\n    !isEqualRegions(region, options.clientRegion) &&\n    !isEqualRegions(region, options.clientSigningRegion)\n  ) {\n    throw new Error(`Region in ARN is incompatible, got ${region} but expected ${options.clientRegion}`);\n  }\n  if (options.useArnRegion && isFipsRegion(region)) {\n    throw new Error(\"Endpoint does not support FIPS region\");\n  }\n};\n\nconst isFipsRegion = (region: string) => region.startsWith(\"fips-\") || region.endsWith(\"-fips\");\n\nconst isEqualRegions = (regionA: string, regionB: string) =>\n  regionA === regionB || getPseudoRegion(regionA) === regionB || regionA === getPseudoRegion(regionB);\n\n/**\n * Validate an account ID\n * @internal\n */\nexport const validateAccountId = (accountId: string) => {\n  if (!/[0-9]{12}/.exec(accountId)) {\n    throw new Error(\"Access point ARN accountID does not match regex '[0-9]{12}'\");\n  }\n};\n\n/**\n * Validate a host label according to https://tools.ietf.org/html/rfc3986#section-3.2.2\n * @internal\n */\nexport const validateDNSHostLabel = (label: string, options: { tlsCompatible?: boolean } = { tlsCompatible: true }) => {\n  // reference: https://tools.ietf.org/html/rfc3986#section-3.2.2\n  if (\n    label.length >= 64 ||\n    !/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(label) ||\n    /(\\d+\\.){3}\\d+/.test(label) ||\n    /[.-]{2}/.test(label) ||\n    (options?.tlsCompatible && DOT_PATTERN.test(label))\n  ) {\n    throw new Error(`Invalid DNS label ${label}`);\n  }\n};\n\n/**\n * Validate and parse an Access Point ARN or Outposts ARN\n * @internal\n *\n * @param resource - The resource section of an ARN\n * @returns Access Point Name and optional Outpost ID.\n */\nexport const getArnResources = (\n  resource: string\n): {\n  accesspointName: string;\n  outpostId?: string;\n} => {\n  const delimiter = resource.includes(\":\") ? \":\" : \"/\";\n  const [resourceType, ...rest] = resource.split(delimiter);\n  if (resourceType === \"accesspoint\") {\n    // Parse accesspoint ARN\n    if (rest.length !== 1 || rest[0] === \"\") {\n      throw new Error(`Access Point ARN should have one resource accesspoint${delimiter}{accesspointname}`);\n    }\n    return { accesspointName: rest[0] };\n  } else if (resourceType === \"outpost\") {\n    // Parse outpost ARN\n    if (!rest[0] || rest[1] !== \"accesspoint\" || !rest[2] || rest.length !== 3) {\n      throw new Error(\n        `Outpost ARN should have resource outpost${delimiter}{outpostId}${delimiter}accesspoint${delimiter}{accesspointName}`\n      );\n    }\n    const [outpostId, _, accesspointName] = rest;\n    return { outpostId, accesspointName };\n  } else {\n    throw new Error(`ARN resource should begin with 'accesspoint${delimiter}' or 'outpost${delimiter}'`);\n  }\n};\n\n/**\n * Throw if dual stack configuration is set to true.\n * @internal\n */\nexport const validateNoDualstack = (dualstackEndpoint: boolean) => {\n  if (dualstackEndpoint) throw new Error(\"Dualstack endpoint is not supported with Outpost\");\n};\n\n/**\n * Validate region is not appended or prepended with a `fips-`\n * @internal\n */\nexport const validateNoFIPS = (region: string) => {\n  if (isFipsRegion(region ?? \"\")) throw new Error(`FIPS region is not supported with Outpost, got ${region}`);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
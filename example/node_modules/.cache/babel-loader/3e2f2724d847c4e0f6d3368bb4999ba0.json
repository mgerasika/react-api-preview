{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Explorer = void 0;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _ExplorerBase = require(\"./ExplorerBase\");\nvar _readFile = require(\"./readFile\");\nvar _cacheWrapper = require(\"./cacheWrapper\");\nvar _getDirectory = require(\"./getDirectory\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _asyncIterator(iterable) {\n  var method;\n  if (typeof Symbol !== \"undefined\") {\n    if (Symbol.asyncIterator) {\n      method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n    if (Symbol.iterator) {\n      method = iterable[Symbol.iterator];\n      if (method != null) return method.call(iterable);\n    }\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nclass Explorer extends _ExplorerBase.ExplorerBase {\n  constructor(options) {\n    super(options);\n  }\n  async search() {\n    let searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n    const startDirectory = await (0, _getDirectory.getDirectory)(searchFrom);\n    const result = await this.searchFromDirectory(startDirectory);\n    return result;\n  }\n  async searchFromDirectory(dir) {\n    const absoluteDir = _path.default.resolve(process.cwd(), dir);\n    const run = async () => {\n      const result = await this.searchDirectory(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n      if (nextDir) {\n        return this.searchFromDirectory(nextDir);\n      }\n      const transformResult = await this.config.transform(result);\n      return transformResult;\n    };\n    if (this.searchCache) {\n      return (0, _cacheWrapper.cacheWrapper)(this.searchCache, absoluteDir, run);\n    }\n    return run();\n  }\n  async searchDirectory(dir) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(this.config.searchPlaces), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const place = _value;\n        const placeResult = await this.loadSearchPlace(dir, place);\n        if (this.shouldSearchStopWithResult(placeResult) === true) {\n          return placeResult;\n        }\n      } // config not found\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    return null;\n  }\n  async loadSearchPlace(dir, place) {\n    const filepath = _path.default.join(dir, place);\n    const fileContents = await (0, _readFile.readFile)(filepath);\n    const result = await this.createCosmiconfigResult(filepath, fileContents);\n    return result;\n  }\n  async loadFileContent(filepath, content) {\n    if (content === null) {\n      return null;\n    }\n    if (content.trim() === '') {\n      return undefined;\n    }\n    const loader = this.getLoaderEntryForFile(filepath);\n    const loaderResult = await loader(filepath, content);\n    return loaderResult;\n  }\n  async createCosmiconfigResult(filepath, content) {\n    const fileContent = await this.loadFileContent(filepath, content);\n    const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);\n    return result;\n  }\n  async load(filepath) {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = _path.default.resolve(process.cwd(), filepath);\n    const runLoad = async () => {\n      const fileContents = await (0, _readFile.readFile)(absoluteFilePath, {\n        throwNotFound: true\n      });\n      const result = await this.createCosmiconfigResult(absoluteFilePath, fileContents);\n      const transformResult = await this.config.transform(result);\n      return transformResult;\n    };\n    if (this.loadCache) {\n      return (0, _cacheWrapper.cacheWrapper)(this.loadCache, absoluteFilePath, runLoad);\n    }\n    return runLoad();\n  }\n}\nexports.Explorer = Explorer;","map":{"version":3,"sources":["../src/Explorer.ts"],"names":["Explorer","ExplorerBase","constructor","options","search","searchFrom","process","cwd","startDirectory","result","searchFromDirectory","dir","absoluteDir","path","resolve","run","searchDirectory","nextDir","nextDirectoryToSearch","transformResult","config","transform","searchCache","place","searchPlaces","placeResult","loadSearchPlace","shouldSearchStopWithResult","filepath","join","fileContents","createCosmiconfigResult","loadFileContent","content","trim","undefined","loader","getLoaderEntryForFile","loaderResult","fileContent","loadedContentToCosmiconfigResult","load","validateFilePath","absoluteFilePath","runLoad","throwNotFound","loadCache"],"mappings":"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","sourcesContent":["import path from 'path';\nimport { ExplorerBase } from './ExplorerBase';\nimport { readFile } from './readFile';\nimport { cacheWrapper } from './cacheWrapper';\nimport { getDirectory } from './getDirectory';\nimport { CosmiconfigResult, ExplorerOptions, LoadedFileContent } from './types';\n\nclass Explorer extends ExplorerBase<ExplorerOptions> {\n  public constructor(options: ExplorerOptions) {\n    super(options);\n  }\n\n  public async search(\n    searchFrom: string = process.cwd(),\n  ): Promise<CosmiconfigResult> {\n    const startDirectory = await getDirectory(searchFrom);\n    const result = await this.searchFromDirectory(startDirectory);\n\n    return result;\n  }\n\n  private async searchFromDirectory(dir: string): Promise<CosmiconfigResult> {\n    const absoluteDir = path.resolve(process.cwd(), dir);\n\n    const run = async (): Promise<CosmiconfigResult> => {\n      const result = await this.searchDirectory(absoluteDir);\n      const nextDir = this.nextDirectoryToSearch(absoluteDir, result);\n\n      if (nextDir) {\n        return this.searchFromDirectory(nextDir);\n      }\n\n      const transformResult = await this.config.transform(result);\n\n      return transformResult;\n    };\n\n    if (this.searchCache) {\n      return cacheWrapper(this.searchCache, absoluteDir, run);\n    }\n\n    return run();\n  }\n\n  private async searchDirectory(dir: string): Promise<CosmiconfigResult> {\n    for await (const place of this.config.searchPlaces) {\n      const placeResult = await this.loadSearchPlace(dir, place);\n\n      if (this.shouldSearchStopWithResult(placeResult) === true) {\n        return placeResult;\n      }\n    }\n\n    // config not found\n    return null;\n  }\n\n  private async loadSearchPlace(\n    dir: string,\n    place: string,\n  ): Promise<CosmiconfigResult> {\n    const filepath = path.join(dir, place);\n    const fileContents = await readFile(filepath);\n\n    const result = await this.createCosmiconfigResult(filepath, fileContents);\n\n    return result;\n  }\n\n  private async loadFileContent(\n    filepath: string,\n    content: string | null,\n  ): Promise<LoadedFileContent> {\n    if (content === null) {\n      return null;\n    }\n    if (content.trim() === '') {\n      return undefined;\n    }\n    const loader = this.getLoaderEntryForFile(filepath);\n    const loaderResult = await loader(filepath, content);\n    return loaderResult;\n  }\n\n  private async createCosmiconfigResult(\n    filepath: string,\n    content: string | null,\n  ): Promise<CosmiconfigResult> {\n    const fileContent = await this.loadFileContent(filepath, content);\n    const result = this.loadedContentToCosmiconfigResult(filepath, fileContent);\n\n    return result;\n  }\n\n  public async load(filepath: string): Promise<CosmiconfigResult> {\n    this.validateFilePath(filepath);\n    const absoluteFilePath = path.resolve(process.cwd(), filepath);\n\n    const runLoad = async (): Promise<CosmiconfigResult> => {\n      const fileContents = await readFile(absoluteFilePath, {\n        throwNotFound: true,\n      });\n\n      const result = await this.createCosmiconfigResult(\n        absoluteFilePath,\n        fileContents,\n      );\n\n      const transformResult = await this.config.transform(result);\n\n      return transformResult;\n    };\n\n    if (this.loadCache) {\n      return cacheWrapper(this.loadCache, absoluteFilePath, runLoad);\n    }\n\n    return runLoad();\n  }\n}\n\nexport { Explorer };\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import { EventEmitter } from '../utils/event-emitter.util.js';\nimport { useRef, useEffect, useCallback } from 'react';\nfunction useMessage(_ref) {\n  var iframe = _ref.iframe;\n  var events = useRef({});\n  useEffect(function () {\n    window.onmessage = function (e) {\n      if (e.data) {\n        try {\n          var _data = JSON.parse(e.data);\n          if (_data.channel) {\n            events.current[_data.channel].emit(_data.data);\n          }\n          // eslint-disable-next-line no-empty\n        } catch (_unused) {}\n      }\n    };\n  }, [iframe]);\n  return {\n    postToParent: useCallback(function (channel, data) {\n      if (window.top) {\n        var _window$top;\n        (_window$top = window.top) === null || _window$top === void 0 ? void 0 : _window$top.postMessage(JSON.stringify({\n          channel: channel,\n          data: data\n        }), '*');\n      }\n    }, []),\n    postToIframe: useCallback(function (channel, data) {\n      var _iframe$contentWindow;\n      iframe === null || iframe === void 0 ? void 0 : (_iframe$contentWindow = iframe.contentWindow) === null || _iframe$contentWindow === void 0 ? void 0 : _iframe$contentWindow.postMessage(JSON.stringify({\n        channel: channel,\n        data: data\n      }), '*');\n    }, [iframe === null || iframe === void 0 ? void 0 : iframe.contentWindow]),\n    subscribe: useCallback(function (channel, callback) {\n      if (!events.current[channel]) {\n        events.current[channel] = new EventEmitter();\n      }\n      events.current[channel].subscribe(callback);\n      return function () {\n        return events.current[channel].unsubscribe(callback);\n      };\n    }, [events])\n  };\n}\nexport { useMessage };","map":{"version":3,"sources":["../../../src/hooks/use-message.hook.ts"],"names":["useMessage","iframe","events","useRef","useEffect","window","onmessage","e","data","JSON","parse","channel","current","emit","postToParent","useCallback","top","postMessage","stringify","postToIframe","contentWindow","subscribe","callback","EventEmitter","unsubscribe"],"mappings":";;AAeO,SAASA,UAAU,CAAoC,IAAA,EAAA;EAAA,IAA9BC,MAAM,GAAA,IAAA,CAANA,MAAM;EAClC,IAAMC,MAAM,GAAGC,MAAM,CAA+B,CAAA,CAAE,CAAC;EACvDC,SAAS,CAAC,YAAM;IACZC,MAAM,CAACC,SAAS,GAAG,UAACC,CAAC,EAAW;MAC5B,IAAIA,CAAC,CAACC,IAAI,EAAE;QACR,IAAI;UACA,IAAMA,KAAiB,GAAGC,IAAI,CAACC,KAAK,CAACH,CAAC,CAACC,IAAI,CAAC;UAC5C,IAAIA,KAAI,CAACG,OAAO,EAAE;YACdT,MAAM,CAACU,OAAO,CAACJ,KAAI,CAACG,OAAO,CAAC,CAACE,IAAI,CAACL,KAAI,CAACA,IAAI,CAAC;UAChD;UACA;SACH,CAAC,OAAA,OAAA,EAAM,CAAC;MACb;KACH;EACL,CAAC,EAAE,CAACP,MAAM,CAAC,CAAC;EAEZ,OAAO;IACHa,YAAY,EAAEC,WAAW,CAAC,UAACJ,OAAe,EAAEH,IAAI,EAAK;MACjD,IAAIH,MAAM,CAACW,GAAG,EAAE;QAAA,IAAA,WAAA;QACZ,CAAA,WAAA,GAAA,MAAM,CAACA,GAAG,MAAV,IAAA,IAAA,WAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,WAAA,CAAYC,WAAW,CACnBR,IAAI,CAACS,SAAS,CAAC;UACXP,OAAO,EAAPA,OAAO;UACPH,IAAI,EAAJA;SACH,CAAgB,EACjB,GAAG,CACN;MACL;IACH,CAAA,EAAE,EAAE,CAAC;IAENW,YAAY,EAAEJ,WAAW,CACrB,UAACJ,OAAe,EAAEH,IAAI,EAAK;MAAA,IAAA,qBAAA;MACvBP,MAAM,KAANA,IAAAA,IAAAA,MAAM,KAANA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,CAAAA,qBAAAA,GAAAA,MAAM,CAAEmB,aAAa,MAArBnB,IAAAA,IAAAA,qBAAAA,KAAAA,KAAAA,CAAAA,GAAAA,KAAAA,CAAAA,GAAAA,qBAAAA,CAAuBgB,WAAW,CAC9BR,IAAI,CAACS,SAAS,CAAC;QACXP,OAAO,EAAPA,OAAO;QACPH,IAAI,EAAJA;OACH,CAAgB,EACjB,GAAG,CACN;KACJ,EACD,CAACP,MAAM,KAANA,IAAAA,IAAAA,MAAM,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAANA,MAAM,CAAEmB,aAAa,CAAC,CAC1B;IAEDC,SAAS,EAAEN,WAAW,CAClB,UAACJ,OAAe,EAAEW,QAA0B,EAAK;MAC7C,IAAI,CAACpB,MAAM,CAACU,OAAO,CAACD,OAAO,CAAC,EAAE;QAC1BT,MAAM,CAACU,OAAO,CAACD,OAAO,CAAC,GAAG,IAAIY,YAAY,EAAE;MAChD;MACArB,MAAM,CAACU,OAAO,CAACD,OAAO,CAAC,CAACU,SAAS,CAACC,QAAQ,CAAC;MAC3C,OAAO,YAAA;QAAA,OAAYpB,MAAM,CAACU,OAAO,CAACD,OAAO,CAAC,CAACa,WAAW,CAACF,QAAQ,CAAC;MAAA,CAAA;KACnE,EACD,CAACpB,MAAM,CAAC;GAEf;AACL","sourcesContent":["import { EventEmitter } from '@common/utils/event-emitter.util';\nimport { useCallback, useEffect, useRef } from 'react';\n\nexport interface IMessage<T> {\n    channel: string;\n    data: T;\n}\ninterface IProps {\n    iframe: HTMLIFrameElement | undefined;\n}\ninterface IReturn<T> {\n    postToParent: (name: string, data?: T) => void;\n    postToIframe: (name: string, data?: T) => void;\n    subscribe: (name: string, callback: (data: T) => void) => () => void;\n}\nexport function useMessage<T>({ iframe }: IProps): IReturn<T> {\n    const events = useRef<Record<string, EventEmitter>>({});\n    useEffect(() => {\n        window.onmessage = (e): void => {\n            if (e.data) {\n                try {\n                    const data: IMessage<T> = JSON.parse(e.data);\n                    if (data.channel) {\n                        events.current[data.channel].emit(data.data);\n                    }\n                    // eslint-disable-next-line no-empty\n                } catch {}\n            }\n        };\n    }, [iframe]);\n\n    return {\n        postToParent: useCallback((channel: string, data) => {\n            if (window.top) {\n                window.top?.postMessage(\n                    JSON.stringify({\n                        channel,\n                        data,\n                    } as IMessage<T>),\n                    '*',\n                );\n            }\n        }, []),\n\n        postToIframe: useCallback(\n            (channel: string, data) => {\n                iframe?.contentWindow?.postMessage(\n                    JSON.stringify({\n                        channel,\n                        data,\n                    } as IMessage<T>),\n                    '*',\n                );\n            },\n            [iframe?.contentWindow],\n        ),\n\n        subscribe: useCallback(\n            (channel: string, callback: (arg: T) => void) => {\n                if (!events.current[channel]) {\n                    events.current[channel] = new EventEmitter();\n                }\n                events.current[channel].subscribe(callback);\n                return (): void => events.current[channel].unsubscribe(callback);\n            },\n            [events],\n        ),\n    };\n}\n"]},"metadata":{},"sourceType":"module"}
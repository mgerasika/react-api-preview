{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar LinkItem = /*#__PURE__*/function () {\n  function LinkItem(name, parent,\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  routes, canFormatRouteName) {\n    var _this = this;\n    _classCallCheck(this, LinkItem);\n    _defineProperty(this, \"name\", '');\n    _defineProperty(this, \"formattedName\", '');\n    _defineProperty(this, \"parent\", undefined);\n    _defineProperty(this, \"_canFormatRouteName\", true);\n    this.name = name;\n    this.formattedName = canFormatRouteName ? formatRouteName(name) : name;\n    this.parent = parent;\n    this._canFormatRouteName = canFormatRouteName;\n    if (routes && _typeof(routes) === 'object') {\n      var keys = Object.keys(routes);\n      keys.forEach(function (key) {\n        var value = routes[key];\n        var self = _this;\n        if (typeof value === 'function' && key.startsWith('external_')) {\n          self[key] = function (arg1, arg2, arg3) {\n            return value(arg1, arg2, arg3);\n          };\n        } else if (typeof value === 'function') {\n          var subRoutes = value();\n          self[key] = function (arg) {\n            //if argument not passed into function - then add ':' symbol before key.\n            return new LinkItem(arg || ':' + key, _this, subRoutes, false);\n          };\n        } else if (value instanceof LinkItem) {\n          self[key] = value.name;\n        } else {\n          self[key] = new LinkItem(key, _this, value, true);\n        }\n      });\n    }\n  }\n  _createClass(LinkItem, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var name = this._canFormatRouteName ? formatRouteName(this.name) : this.name;\n      return this.parent ? this.parent + '/' + name : name;\n    }\n  }]);\n  return LinkItem;\n}();\nvar formatRouteName = function formatRouteName(str) {\n  if (str === 'index') {\n    return '';\n  }\n  return str.toString().replace(/([A-Z])/g, function (str) {\n    return '-' + str.toLowerCase();\n  });\n};\nfunction makeLinks(routes) {\n  return new LinkItem('', undefined, routes, true);\n}\nvar EMPTY_LINK_ITEM = {};\nexport { EMPTY_LINK_ITEM, LinkItem, makeLinks };","map":{"version":3,"sources":["../../../src/utils/make-links.util.ts"],"names":["LinkItem","undefined","toJSON","toString","constructor","name","parent","routes","canFormatRouteName","formattedName","formatRouteName","_canFormatRouteName","keys","Object","forEach","key","value","self","startsWith","arg1","arg2","arg3","subRoutes","arg","str","replace","toLowerCase","makeLinks","EMPTY_LINK_ITEM"],"mappings":"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","sourcesContent":["import { IDictionary } from '@common/interfaces/dictionary.interface';\n\nexport interface ILinkItem {\n    toString: () => string;\n    formattedName?: string;\n}\n\nexport class LinkItem implements ILinkItem {\n    public name = '';\n    public formattedName = '';\n    public parent: LinkItem | undefined = undefined;\n    private _canFormatRouteName? = true;\n\n    toJSON(): string {\n        return this.toString();\n    }\n\n    constructor(\n        name: string,\n        parent?: LinkItem | undefined,\n        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n        routes?: unknown,\n        canFormatRouteName?: boolean,\n    ) {\n        this.name = name;\n        this.formattedName = canFormatRouteName ? formatRouteName(name) : name;\n\n        this.parent = parent;\n        this._canFormatRouteName = canFormatRouteName;\n        if (routes && typeof routes === 'object') {\n            const keys = Object.keys(routes);\n            keys.forEach((key) => {\n                const value = routes[key];\n                const self = this as unknown as IDictionary;\n                if (typeof value === 'function' && key.startsWith('external_')) {\n                    self[key] = (arg1: string, arg2: string, arg3: string): LinkItem => {\n                        return value(arg1, arg2, arg3);\n                    };\n                } else if (typeof value === 'function') {\n                    const subRoutes = value();\n                    self[key] = (arg: string): LinkItem => {\n                        //if argument not passed into function - then add ':' symbol before key.\n                        return new LinkItem(arg || ':' + key, this, subRoutes, false);\n                    };\n                } else if (value instanceof LinkItem) {\n                    self[key] = value.name;\n                } else {\n                    self[key] = new LinkItem(key, this, value, true);\n                }\n            });\n        }\n    }\n\n    toString(): string {\n        const name = this._canFormatRouteName ? formatRouteName(this.name) : this.name;\n        return this.parent ? this.parent + '/' + name : name;\n    }\n}\n\nconst formatRouteName = (str: string): string => {\n    if (str === 'index') {\n        return '';\n    }\n    return str.toString().replace(/([A-Z])/g, (str) => '-' + str.toLowerCase());\n};\n\nexport function makeLinks<T>(routes: T): T {\n    return new LinkItem('', undefined, routes, true) as unknown as T;\n}\n\nexport const EMPTY_LINK_ITEM: ILinkItem = {} as unknown as ILinkItem;\n"]},"metadata":{},"sourceType":"module"}
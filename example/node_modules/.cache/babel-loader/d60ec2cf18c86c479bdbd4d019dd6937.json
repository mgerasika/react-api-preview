{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { sleep } from \"./utils/sleep\";\nimport { WaiterState } from \"./waiter\";\n/**\n * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries\n */\nvar exponentialBackoffWithJitter = function exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, attempt) {\n  if (attempt > attemptCeiling) return maxDelay;\n  var delay = minDelay * Math.pow(2, attempt - 1);\n  return randomInRange(minDelay, delay);\n};\nvar randomInRange = function randomInRange(min, max) {\n  return min + Math.random() * (max - min);\n};\n/**\n * Function that runs polling as part of waiters. This will make one inital attempt and then\n * subsequent attempts with an increasing delay.\n * @param params options passed to the waiter.\n * @param client AWS SDK Client\n * @param input client input\n * @param stateChecker function that checks the acceptor states on each poll.\n */\nexport var runPolling = function runPolling(_a, input, acceptorChecks) {\n  var minDelay = _a.minDelay,\n    maxDelay = _a.maxDelay,\n    maxWaitTime = _a.maxWaitTime,\n    abortController = _a.abortController,\n    client = _a.client;\n  return __awaiter(void 0, void 0, void 0, function () {\n    var state, currentAttempt, waitUntil, attemptCeiling, delay, state_1;\n    var _b;\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4 /*yield*/, acceptorChecks(client, input)];\n        case 1:\n          state = _c.sent().state;\n          if (state !== WaiterState.RETRY) {\n            return [2 /*return*/, {\n              state: state\n            }];\n          }\n          currentAttempt = 1;\n          waitUntil = Date.now() + maxWaitTime * 1000;\n          attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n          _c.label = 2;\n        case 2:\n          if (!true) return [3 /*break*/, 5];\n          if ((_b = abortController === null || abortController === void 0 ? void 0 : abortController.signal) === null || _b === void 0 ? void 0 : _b.aborted) {\n            return [2 /*return*/, {\n              state: WaiterState.ABORTED\n            }];\n          }\n          delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n          // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until\n          // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.\n          if (Date.now() + delay * 1000 > waitUntil) {\n            return [2 /*return*/, {\n              state: WaiterState.TIMEOUT\n            }];\n          }\n          return [4 /*yield*/, sleep(delay)];\n        case 3:\n          _c.sent();\n          return [4 /*yield*/, acceptorChecks(client, input)];\n        case 4:\n          state_1 = _c.sent().state;\n          if (state_1 !== WaiterState.RETRY) {\n            return [2 /*return*/, {\n              state: state_1\n            }];\n          }\n          currentAttempt += 1;\n          return [3 /*break*/, 2];\n        case 5:\n          return [2 /*return*/];\n      }\n    });\n  });\n};","map":{"version":3,"sources":["../../src/poller.ts"],"names":[],"mappings":";AAAA,SAAS,KAAK,QAAQ,eAAe;AACrC,SAAsC,WAAW,QAAQ,UAAU;AAEnE;;AAEG;AACH,IAAM,4BAA4B,GAAG,SAA/B,4BAA4B,CAAI,QAAgB,EAAE,QAAgB,EAAE,cAAsB,EAAE,OAAe,EAAA;EAC/G,IAAI,OAAO,GAAG,cAAc,EAAE,OAAO,QAAQ;EAC7C,IAAM,KAAK,GAAG,QAAQ,GAAG,IAAA,CAAA,GAAA,CAAA,CAAC,EAAK,OAAO,GAAG,CAAC,CAAC;EAC3C,OAAO,aAAa,CAAC,QAAQ,EAAE,KAAK,CAAC;AACvC,CAAC;AAED,IAAM,aAAa,GAAG,SAAhB,aAAa,CAAI,GAAW,EAAE,GAAW,EAAA;EAAK,OAAA,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,GAAG,GAAG,GAAG,CAAC;AAAjC,CAAiC;AAErF;;;;;;;AAOG;AACH,OAAO,IAAM,UAAU,GAAG,SAAb,UAAU,CACrB,EAAmF,EACnF,KAAY,EACZ,cAAuE,EAAA;MAFrE,QAAQ,GAAA,EAAA,CAAA,QAAA;IAAE,QAAQ,GAAA,EAAA,CAAA,QAAA;IAAE,WAAW,GAAA,EAAA,CAAA,WAAA;IAAE,eAAe,GAAA,EAAA,CAAA,eAAA;IAAE,MAAM,GAAA,EAAA,CAAA,MAAA;;;;;;;UAIxC,OAAA,CAAA,CAAA,CAAA,WAAM,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;;UAA7C,KAAK,GAAK,EAAA,CAAA,IAAA,EAAmC,CAAA,KAAxC;UACb,IAAI,KAAK,KAAK,WAAW,CAAC,KAAK,EAAE;YAC/B,OAAA,CAAA,CAAA,CAAA,YAAO;cAAE,KAAK,EAAA;YAAA,CAAE,CAAA;UACjB;UAEG,cAAc,GAAG,CAAC;UAChB,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,WAAW,GAAG,IAAI;UAG3C,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,QAAQ,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;;;eAC/D,IAAI,EAAA,OAAA,CAAA,CAAA,CAAA,WAAA,CAAA,CAAA;UACT,IAAA,CAAA,EAAA,GAAI,eAAe,KAAA,IAAA,IAAf,eAAe,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAf,eAAe,CAAE,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,OAAO,EAAE;YACpC,OAAA,CAAA,CAAA,CAAA,YAAO;cAAE,KAAK,EAAE,WAAW,CAAC;YAAO,CAAE,CAAA;UACtC;UACK,KAAK,GAAG,4BAA4B,CAAC,QAAQ,EAAE,QAAQ,EAAE,cAAc,EAAE,cAAc,CAAC;UAC9F;UACA;UACA,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,KAAK,GAAG,IAAI,GAAG,SAAS,EAAE;YACzC,OAAA,CAAA,CAAA,CAAA,YAAO;cAAE,KAAK,EAAE,WAAW,CAAC;YAAO,CAAE,CAAA;UACtC;UACD,OAAA,CAAA,CAAA,CAAA,WAAM,KAAK,CAAC,KAAK,CAAC,CAAA;;UAAlB,EAAA,CAAA,IAAA,EAAkB;UACA,OAAA,CAAA,CAAA,CAAA,WAAM,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;;UAA7C,OAAA,GAAU,EAAA,CAAA,IAAA,EAAmC,CAAA,KAAxC;UACb,IAAI,OAAK,KAAK,WAAW,CAAC,KAAK,EAAE;YAC/B,OAAA,CAAA,CAAA,CAAA,YAAO;cAAE,KAAK,EAAA;YAAA,CAAE,CAAA;UACjB;UAED,cAAc,IAAI,CAAC;;;;;;;CAEtB","sourcesContent":["import { sleep } from \"./utils/sleep\";\nimport { WaiterOptions, WaiterResult, WaiterState } from \"./waiter\";\n\n/**\n * Reference: https://awslabs.github.io/smithy/1.0/spec/waiters.html#waiter-retries\n */\nconst exponentialBackoffWithJitter = (minDelay: number, maxDelay: number, attemptCeiling: number, attempt: number) => {\n  if (attempt > attemptCeiling) return maxDelay;\n  const delay = minDelay * 2 ** (attempt - 1);\n  return randomInRange(minDelay, delay);\n};\n\nconst randomInRange = (min: number, max: number) => min + Math.random() * (max - min);\n\n/**\n * Function that runs polling as part of waiters. This will make one inital attempt and then\n * subsequent attempts with an increasing delay.\n * @param params options passed to the waiter.\n * @param client AWS SDK Client\n * @param input client input\n * @param stateChecker function that checks the acceptor states on each poll.\n */\nexport const runPolling = async <Client, Input>(\n  { minDelay, maxDelay, maxWaitTime, abortController, client }: WaiterOptions<Client>,\n  input: Input,\n  acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>\n): Promise<WaiterResult> => {\n  const { state } = await acceptorChecks(client, input);\n  if (state !== WaiterState.RETRY) {\n    return { state };\n  }\n\n  let currentAttempt = 1;\n  const waitUntil = Date.now() + maxWaitTime * 1000;\n  // The max attempt number that the derived delay time tend to increase.\n  // Pre-compute this number to avoid Number type overflow.\n  const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;\n  while (true) {\n    if (abortController?.signal?.aborted) {\n      return { state: WaiterState.ABORTED };\n    }\n    const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);\n    // Resolve the promise explicitly at timeout or aborted. Otherwise this while loop will keep making API call until\n    // `acceptorCheck` returns non-retry status, even with the Promise.race() outside.\n    if (Date.now() + delay * 1000 > waitUntil) {\n      return { state: WaiterState.TIMEOUT };\n    }\n    await sleep(delay);\n    const { state } = await acceptorChecks(client, input);\n    if (state !== WaiterState.RETRY) {\n      return { state };\n    }\n\n    currentAttempt += 1;\n  }\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
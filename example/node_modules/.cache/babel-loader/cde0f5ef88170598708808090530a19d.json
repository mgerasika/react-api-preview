{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { t } from '../hooks/use-t.hook.js';\nimport { generateId } from './generate-id.util.js';\nimport dayjs from 'dayjs';\nimport { formatDate } from './format-date.util.js';\nimport { getNow } from './now.util.js';\nimport { throwException } from './throw-exception.util.js';\nvar ECalendarEventType;\n(function (ECalendarEventType) {\n  ECalendarEventType[\"subscription\"] = \"subscription\";\n  ECalendarEventType[\"order\"] = \"order\";\n})(ECalendarEventType || (ECalendarEventType = {}));\nvar getStep = function getStep(_ref) {\n  var billing_period = _ref.billing_period,\n    billing_period_unit = _ref.billing_period_unit,\n    isNewSubscription = _ref.isNewSubscription;\n  if (billing_period_unit === 'week') {\n    return isNewSubscription ? 7 * Math.min(1, billing_period) : 7 * billing_period;\n  } else if (billing_period_unit === 'day') {\n    return billing_period;\n  }\n  throwException('Not implemented (get step)');\n};\nvar EUpcomingDeliverySubType;\n(function (EUpcomingDeliverySubType) {\n  EUpcomingDeliverySubType[\"upcomingDelivery\"] = \"upcomingDelivery\";\n  EUpcomingDeliverySubType[\"pause\"] = \"pause\";\n  EUpcomingDeliverySubType[\"skippedButPauseRemoved\"] = \"skippedButPauseRemoved\";\n  EUpcomingDeliverySubType[\"blockedForUpdate\"] = \"blockedForUpdate\";\n})(EUpcomingDeliverySubType || (EUpcomingDeliverySubType = {}));\nvar isSameOrAfter = function isSameOrAfter(day1, day2) {\n  return day1.isSame(day2, 'days') || day1.isAfter(day2, 'days');\n};\nvar isSameOrBefore = function isSameOrBefore(day1, day2) {\n  return day1.isSame(day2, 'days') || day1.isBefore(day2, 'days');\n};\nfunction getEventsFromOrders(_ref2) {\n  var rangeStartDate = _ref2.rangeStartDate,\n    rangeEndDate = _ref2.rangeEndDate,\n    orders = _ref2.orders,\n    addAdditionalMinutesForBlockUIInMinutes = _ref2.addAdditionalMinutesForBlockUIInMinutes;\n  var res = [];\n  orders.forEach(function (order) {\n    var orderDate = dayjs(order.orderDate);\n    if (isSameOrAfter(orderDate, rangeStartDate) && isSameOrBefore(orderDate, rangeEndDate)) {\n      var _order$order_line_ite;\n      res.push({\n        id: generateId('event'),\n        title: t('Order ') + \" (\".concat(order === null || order === void 0 ? void 0 : order.payment_status, \") \") + (order === null || order === void 0 ? void 0 : (_order$order_line_ite = order.order_line_items) === null || _order$order_line_ite === void 0 ? void 0 : _order$order_line_ite.map(function (i) {\n          return i.description;\n        }).join(', ')),\n        allDay: true,\n        editable: false,\n        start: orderDate.toDate(),\n        metadata: {\n          type: ECalendarEventType.order,\n          orderObj: {\n            order: order,\n            subscriptionBillingDate: orderDate.toDate(),\n            subscriptionBillingDate_blockedOnUI: dayjs(orderDate).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate()\n          }\n        },\n        extraDate: orderDate.toDate()\n      });\n    }\n  });\n  return res;\n}\nfunction getEventsFromSubscriptions(today, subscriptions, rangeStartDate, rangeEndDate, orderDates, addAdditionalMinutesForBlockUIInMinutes) {\n  var res = [];\n  var activeSubscriptions = subscriptions.filter(function (s) {\n    return s.status !== 'cancelled' && !s.deleted;\n  });\n  activeSubscriptions.forEach(function (subscription) {\n    res = [].concat(_toConsumableArray(res), _toConsumableArray(getEventsFromSubscription({\n      today: today,\n      subscription: subscription,\n      rangeStartDate: rangeStartDate,\n      rangeEndDate: rangeEndDate,\n      orderDates: orderDates,\n      addAdditionalMinutesForBlockUIInMinutes: addAdditionalMinutesForBlockUIInMinutes\n    })));\n  });\n  return res;\n}\nfunction getEventsFromSubscription(_ref3) {\n  var _subscription$cutoffT, _subscription$cutoffT2;\n  var today = _ref3.today,\n    subscription = _ref3.subscription,\n    rangeStartDate = _ref3.rangeStartDate,\n    rangeEndDate = _ref3.rangeEndDate,\n    orderDates = _ref3.orderDates,\n    addAdditionalMinutesForBlockUIInMinutes = _ref3.addAdditionalMinutesForBlockUIInMinutes;\n  var res = [];\n  var todayM = dayjs(today);\n  var cutOff = subscription.cutOff;\n  // const subscriptionStartDate = subscription.pause\n  //     ? subscription.startDate\n  // \t: subscription.nextBillingAtDate || subscription.startDate;\n\n  // Warning!!! don't change to startDate - not working in a lot of cases!!!\n  var subscriptionStartDate = subscription.nextBillingAtDate;\n  // modify day of week\n  subscriptionStartDate = dayjs(subscriptionStartDate).set('day', subscription.cutOffDayOfWeekFromDC).toDate();\n  var step = getStep({\n    billing_period: subscription.billing_period || 0,\n    billing_period_unit: subscription.billing_period_unit,\n    isNewSubscription: false\n  }) || Number.MAX_VALUE;\n  // should coming from subscription or delivery configuration\n  var current = dayjs(subscriptionStartDate); //.set('hours', 10).set('minutes', 0);\n  current = current.set('hours', Number((_subscription$cutoffT = subscription.cutoffTime) === null || _subscription$cutoffT === void 0 ? void 0 : _subscription$cutoffT.getHours()));\n  current = current.set('minutes', Number((_subscription$cutoffT2 = subscription.cutoffTime) === null || _subscription$cutoffT2 === void 0 ? void 0 : _subscription$cutoffT2.getMinutes()));\n  current = current.set('seconds', 0);\n  while (current.isAfter(rangeStartDate)) {\n    var prevTick = current.subtract(step, 'd');\n    if (prevTick.isSame(subscription.startDate, 'd') || prevTick.isAfter(subscription.startDate)) {\n      current = current.subtract(step, 'd');\n    } else {\n      break;\n    }\n  }\n  var subscriptionEndDate = subscription.endDate;\n  var pauses = subscription.pauses || [];\n  while (isSameOrBefore(current, rangeEndDate)) {\n    var pause = pauses.find(function (pause) {\n      var pauseEndDate = dayjs(pause === null || pause === void 0 ? void 0 : pause.endDate).subtract(1, 'm');\n      return current.isSame(pause.startDate, 'd') || current.isSame(pauseEndDate) || current.isAfter(pause.startDate) && current.isBefore(pauseEndDate);\n    });\n    var haveOrder = orderDates.find(function (orderDate) {\n      return current.isSame(orderDate, 'd');\n    });\n    if (!haveOrder) {\n      if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate) && (!subscription.cancelDate || subscription.cancelDate && current.isBefore(subscription.cancelDate, 'd'))) {\n        var _subscription$subscri;\n        var currentWithAdditionalMinutesForBlockUI = dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes');\n        var subType = EUpcomingDeliverySubType.upcomingDelivery;\n        if (pause) {\n          subType = EUpcomingDeliverySubType.pause;\n        } else if (current.isBefore(subscription.nextBillingAtDate, 'day') && current.isBefore(todayM)) {\n          // if (!isSameOrAfter(current, todayM))\n          {\n            subType = EUpcomingDeliverySubType.skippedButPauseRemoved;\n            // current = current.add(step, 'd');\n            // continue;\n          }\n        } else {\n          subType = todayM.isAfter(currentWithAdditionalMinutesForBlockUI) || todayM.isSame(currentWithAdditionalMinutesForBlockUI) ? EUpcomingDeliverySubType.blockedForUpdate : EUpcomingDeliverySubType.upcomingDelivery;\n        }\n        if (subscription.has_scheduled_changes && isSameOrAfter(current, subscription.nextBillingAtDate) && (_subscription$subscri = subscription.subscription_with_scheduled_changes) !== null && _subscription$subscri !== void 0 && _subscription$subscri.id) {\n          var _subscription$subscri2, _subscription$subscri3, _subscription$subscri4;\n          res.push({\n            id: generateId('event'),\n            title: \"\".concat(subscription.id),\n            start: current.toDate(),\n            allDay: true,\n            editable: false,\n            metadata: {\n              type: ECalendarEventType.subscription,\n              subscriptionObj: {\n                subscription: subscription.subscription_with_scheduled_changes,\n                subType: subType,\n                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                subscriptionBillingDate: current.toDate(),\n                subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate(),\n                totalPrice: (subscription === null || subscription === void 0 ? void 0 : subscription.totalPrice) - (pause ? subscription.totalAddonsPrice : 0)\n              }\n            },\n            extraDate: current.toDate()\n          });\n          step = getStep({\n            billing_period: ((_subscription$subscri2 = subscription.subscription_with_scheduled_changes) === null || _subscription$subscri2 === void 0 ? void 0 : _subscription$subscri2.billing_period) || 0,\n            billing_period_unit: (_subscription$subscri3 = subscription.subscription_with_scheduled_changes) === null || _subscription$subscri3 === void 0 ? void 0 : _subscription$subscri3.billing_period_unit,\n            isNewSubscription: false\n          }) || Number.MAX_VALUE;\n          subscriptionEndDate = (_subscription$subscri4 = subscription.subscription_with_scheduled_changes) === null || _subscription$subscri4 === void 0 ? void 0 : _subscription$subscri4.endDate;\n        } else if (!isSameOrAfter(current, subscription.nextBillingAtDate) && subType == EUpcomingDeliverySubType.upcomingDelivery) ;else {\n          var title = \"\".concat(subscription.id);\n          res.push({\n            id: generateId('event'),\n            title: title,\n            start: current.toDate(),\n            allDay: true,\n            editable: false,\n            metadata: {\n              subscriptionObj: {\n                subscription: subscription,\n                subType: subType,\n                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                subscriptionBillingDate: current.toDate(),\n                subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate(),\n                totalPrice: (subscription === null || subscription === void 0 ? void 0 : subscription.totalPrice) - (pause ? subscription.totalAddonsPrice : 0)\n              },\n              type: ECalendarEventType.subscription\n            },\n            extraDate: current.toDate()\n          });\n        }\n      }\n    }\n    current = current.add(step, 'd');\n  }\n  return res;\n}\nfunction getEventsFromPrice(_ref4) {\n  var price = _ref4.price,\n    rangeStartDate = _ref4.rangeStartDate,\n    rangeEndDate = _ref4.rangeEndDate,\n    cutOff = _ref4.cutOff,\n    isNewSubscription = _ref4.isNewSubscription;\n  var res = [];\n  var current = rangeStartDate ? dayjs(rangeStartDate) : dayjs(getNow()).hour(23).minute(59).second(59);\n  var step = getStep({\n    billing_period: price.period || 0,\n    billing_period_unit: price.period_unit,\n    isNewSubscription: isNewSubscription\n  }) || Number.MAX_VALUE;\n  var subscriptionEndDate = new Date(8640000000000000);\n  while (isSameOrBefore(current, rangeEndDate)) {\n    if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate)) {\n      res.push({\n        id: generateId('event'),\n        title: formatDate(current.toDate()),\n        start: current.toDate(),\n        allDay: true,\n        editable: false,\n        metadata: {\n          type: ECalendarEventType.subscription,\n          priceObj: {\n            price: price,\n            subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n            subscriptionBillingDate: current.toDate(),\n            subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(0, 'minutes').toDate()\n          }\n\n          // subscriptionSkipObject: undefined,\n        },\n\n        extraDate: current.toDate()\n      });\n    }\n    current = current.add(step, 'd');\n  }\n  return res;\n}\nvar getAllEvents = function getAllEvents(_ref5) {\n  var today = _ref5.today,\n    subscriptions = _ref5.subscriptions,\n    range = _ref5.range,\n    orders = _ref5.orders,\n    addAdditionalMinutesForBlockUIInMinutes = _ref5.addAdditionalMinutesForBlockUIInMinutes;\n  var subscriptionEvents = getEventsFromSubscriptions(today, subscriptions || [], range === null || range === void 0 ? void 0 : range.start, range === null || range === void 0 ? void 0 : range.end, (orders === null || orders === void 0 ? void 0 : orders.map(function (o) {\n    return o.orderDate;\n  })) || [], addAdditionalMinutesForBlockUIInMinutes);\n  var orderEvents = getEventsFromOrders({\n    orders: orders || [],\n    rangeStartDate: range === null || range === void 0 ? void 0 : range.start,\n    rangeEndDate: range === null || range === void 0 ? void 0 : range.end,\n    addAdditionalMinutesForBlockUIInMinutes: addAdditionalMinutesForBlockUIInMinutes\n  });\n  return [].concat(_toConsumableArray(subscriptionEvents), _toConsumableArray(orderEvents)).sort(function (a, b) {\n    var _a$start, _b$start;\n    return a.start.getTime && b.start.getTime && ((_a$start = a.start) === null || _a$start === void 0 ? void 0 : _a$start.getTime()) > ((_b$start = b.start) === null || _b$start === void 0 ? void 0 : _b$start.getTime()) ? 1 : -1;\n  });\n};\nfunction getFirstEvent(events) {\n  var _events$filter$filter = events.filter(function (f) {\n      var _f$metadata, _f$metadata$subscript;\n      return ((_f$metadata = f.metadata) === null || _f$metadata === void 0 ? void 0 : _f$metadata.type) === ECalendarEventType.subscription && ((_f$metadata$subscript = f.metadata.subscriptionObj) === null || _f$metadata$subscript === void 0 ? void 0 : _f$metadata$subscript.subType) !== EUpcomingDeliverySubType.skippedButPauseRemoved;\n    })\n    // filter past skips\n    .filter(function (f) {\n      var _f$metadata2, _f$metadata2$subscrip, _f$metadata3, _f$metadata3$subscrip, _f$metadata4;\n      return ((_f$metadata2 = f.metadata) === null || _f$metadata2 === void 0 ? void 0 : (_f$metadata2$subscrip = _f$metadata2.subscriptionObj) === null || _f$metadata2$subscrip === void 0 ? void 0 : _f$metadata2$subscrip.subType) !== EUpcomingDeliverySubType.pause || ((_f$metadata3 = f.metadata) === null || _f$metadata3 === void 0 ? void 0 : (_f$metadata3$subscrip = _f$metadata3.subscriptionObj) === null || _f$metadata3$subscrip === void 0 ? void 0 : _f$metadata3$subscrip.subType) === EUpcomingDeliverySubType.pause && ((_f$metadata4 = f.metadata) === null || _f$metadata4 === void 0 ? void 0 : _f$metadata4.subscriptionObj.subscriptionBillingDate.getTime()) > getNow().getTime();\n    }),\n    _events$filter$filter2 = _slicedToArray(_events$filter$filter, 1),\n    firstEvent = _events$filter$filter2[0];\n  return firstEvent;\n}\nexport { ECalendarEventType, EUpcomingDeliverySubType, getAllEvents, getEventsFromPrice, getFirstEvent, getStep };","map":{"version":3,"sources":["../../../src/utils/get-events.util.ts"],"names":["ECalendarEventType","getStep","billing_period","billing_period_unit","isNewSubscription","Math","min","throwException","EUpcomingDeliverySubType","isSameOrAfter","day1","day2","isSame","isAfter","isSameOrBefore","isBefore","getEventsFromOrders","rangeStartDate","rangeEndDate","orders","addAdditionalMinutesForBlockUIInMinutes","res","forEach","order","orderDate","dayjs","push","id","generateId","title","t","payment_status","order_line_items","map","i","description","join","allDay","editable","start","toDate","metadata","type","orderObj","subscriptionBillingDate","subscriptionBillingDate_blockedOnUI","subtract","extraDate","getEventsFromSubscriptions","today","subscriptions","orderDates","activeSubscriptions","filter","s","status","deleted","subscription","getEventsFromSubscription","todayM","cutOff","subscriptionStartDate","nextBillingAtDate","set","cutOffDayOfWeekFromDC","step","Number","MAX_VALUE","current","cutoffTime","getHours","getMinutes","prevTick","startDate","subscriptionEndDate","endDate","pauses","pause","find","pauseEndDate","haveOrder","cancelDate","currentWithAdditionalMinutesForBlockUI","subType","upcomingDelivery","skippedButPauseRemoved","blockedForUpdate","has_scheduled_changes","subscription_with_scheduled_changes","subscriptionObj","subscriptionDeliveryDate","add","totalPrice","totalAddonsPrice","getEventsFromPrice","price","getNow","hour","minute","second","period","period_unit","Date","formatDate","priceObj","getAllEvents","range","subscriptionEvents","end","o","orderEvents","sort","a","b","getTime","getFirstEvent","events","firstEvent","f"],"mappings":"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","sourcesContent":["import { CustomEventInput, ICalendarDateRange } from '@common/general-ui/full-calendar/full-calendar.component';\nimport { t } from '@common/hooks/use-t.hook';\nimport { IIdObject } from '@common/interfaces/id-object.interface';\nimport { generateId } from '@common/utils/generate-id.util';\nimport dayjs from 'dayjs';\nimport { formatDate } from './format-date.util';\nimport { getNow } from './now.util';\nimport { throwException } from './throw-exception.util';\n\nexport enum ECalendarEventType {\n    subscription = 'subscription',\n    order = 'order',\n}\n\nexport interface IPauseCommon {\n    pauseBillingDate: Date;\n    resumeBillingDate: Date;\n}\n\nexport interface ISubscriptionCommon extends IIdObject {\n    status?: string;\n    deleted?: boolean;\n    cutOff: number;\n    cutoffTime: Date | undefined;\n    cutOffDayOfWeekFromDC: number;\n    nextBillingAtDate?: Date;\n    subscription_items?: Array<{ item_price_id?: string }>;\n    startDate?: Date;\n    endDate?: Date;\n    cancelDate?: Date;\n    has_scheduled_changes?: boolean;\n    subscription_with_scheduled_changes?: ISubscriptionCommon;\n    pauses: IDayRangeCommon[] | undefined;\n    totalPrice: number;\n    totalAddonsPrice: number;\n    billing_period?: number;\n    billing_period_unit?: string;\n}\n\nexport interface IItemPriceCommon {\n    period?: number;\n    period_unit?: string;\n}\n\nexport interface IDayRangeCommon {\n    startDate?: Date;\n    endDate?: Date;\n}\n\nexport interface IOrderCommon {\n    orderDate: Date;\n    payment_status?: string;\n    order_line_items?: { description?: string }[];\n}\n\nexport const getStep = ({\n    billing_period,\n    billing_period_unit,\n    isNewSubscription,\n}: {\n    billing_period: number;\n    billing_period_unit: string | undefined;\n    isNewSubscription: boolean;\n}): number | void => {\n    if (billing_period_unit === 'week') {\n        return isNewSubscription ? 7 * Math.min(1, billing_period) : 7 * billing_period;\n    } else if (billing_period_unit === 'day') {\n        return billing_period;\n    }\n    throwException('Not implemented (get step)');\n};\n\nexport enum EUpcomingDeliverySubType {\n    upcomingDelivery = 'upcomingDelivery',\n    pause = 'pause',\n    skippedButPauseRemoved = 'skippedButPauseRemoved',\n    blockedForUpdate = 'blockedForUpdate',\n}\n\nexport interface ICalendarMetaData<\n    TSubscription extends ISubscriptionCommon = ISubscriptionCommon,\n    TPrice extends IItemPriceCommon = IItemPriceCommon,\n    TOrder extends IOrderCommon = IOrderCommon,\n> {\n    type: ECalendarEventType;\n    subscriptionObj?: {\n        subType: EUpcomingDeliverySubType | undefined;\n        subscription?: TSubscription;\n        // subscriptionSkipObject: ICbSubscriptionSkip | undefined;\n        subscriptionDeliveryDate: Date;\n        subscriptionBillingDate_blockedOnUI: Date;\n        subscriptionBillingDate: Date;\n        totalPrice: number;\n    };\n    priceObj?: {\n        price?: TPrice;\n        subscriptionDeliveryDate: Date | undefined;\n        subscriptionBillingDate_blockedOnUI: Date | undefined;\n        subscriptionBillingDate: Date | undefined;\n    };\n    orderObj?: {\n        order: TOrder | undefined;\n        subscriptionBillingDate: Date | undefined;\n        subscriptionBillingDate_blockedOnUI: Date | undefined;\n    };\n}\n\nconst isSameOrAfter = (day1: dayjs.Dayjs, day2: Date | dayjs.Dayjs | undefined): boolean => {\n    return day1.isSame(day2, 'days') || day1.isAfter(day2, 'days');\n};\nconst isSameOrBefore = (day1: dayjs.Dayjs, day2: Date | dayjs.Dayjs | undefined): boolean => {\n    return day1.isSame(day2, 'days') || day1.isBefore(day2, 'days');\n};\nexport type ICalendarEventCommon<\n    TSubsr extends ISubscriptionCommon = ISubscriptionCommon,\n    TPrice extends IItemPriceCommon = IItemPriceCommon,\n    TOrder extends IOrderCommon = IOrderCommon,\n> = CustomEventInput<ICalendarMetaData<TSubsr, TPrice, TOrder>> & IIdObject;\n\nfunction getEventsFromOrders({\n    rangeStartDate,\n    rangeEndDate,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    orders: IOrderCommon[];\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    orders.forEach((order) => {\n        const orderDate = dayjs(order.orderDate);\n\n        if (isSameOrAfter(orderDate, rangeStartDate) && isSameOrBefore(orderDate, rangeEndDate)) {\n            res.push({\n                id: generateId('event'),\n                title:\n                    t('Order ') +\n                    ` (${order?.payment_status}) ` +\n                    order?.order_line_items?.map((i) => i.description).join(', '),\n                allDay: true,\n                editable: false,\n                start: orderDate.toDate(),\n                metadata: {\n                    type: ECalendarEventType.order,\n                    orderObj: {\n                        order,\n                        subscriptionBillingDate: orderDate.toDate(),\n                        subscriptionBillingDate_blockedOnUI: dayjs(orderDate)\n                            .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                            .toDate(),\n                    },\n                },\n                extraDate: orderDate.toDate(),\n            });\n        }\n    });\n    return res;\n}\n\nfunction getEventsFromSubscriptions(\n    today: Date,\n    subscriptions: ISubscriptionCommon[],\n    rangeStartDate: Date | undefined,\n    rangeEndDate: Date | undefined,\n    orderDates: Date[],\n    addAdditionalMinutesForBlockUIInMinutes: number,\n): ICalendarEventCommon[] {\n    let res: ICalendarEventCommon[] = [];\n\n    const activeSubscriptions = subscriptions.filter((s) => s.status !== 'cancelled' && !s.deleted);\n\n    activeSubscriptions.forEach((subscription) => {\n        res = [\n            ...res,\n\n            ...getEventsFromSubscription({\n                today,\n                subscription,\n                rangeStartDate,\n                rangeEndDate,\n                orderDates,\n                addAdditionalMinutesForBlockUIInMinutes,\n            }),\n        ];\n    });\n\n    return res;\n}\n\nfunction getEventsFromSubscription({\n    today,\n    subscription,\n    rangeStartDate,\n    rangeEndDate,\n    orderDates,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    today: Date;\n    subscription: ISubscriptionCommon;\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    orderDates: Date[];\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    const todayM = dayjs(today);\n    const cutOff = subscription.cutOff;\n    // const subscriptionStartDate = subscription.pause\n    //     ? subscription.startDate\n    // \t: subscription.nextBillingAtDate || subscription.startDate;\n\n    // Warning!!! don't change to startDate - not working in a lot of cases!!!\n    let subscriptionStartDate = subscription.nextBillingAtDate;\n    // modify day of week\n    subscriptionStartDate = dayjs(subscriptionStartDate)\n        .set('day', subscription.cutOffDayOfWeekFromDC as number)\n        .toDate();\n\n    let step =\n        getStep({\n            billing_period: subscription.billing_period || 0,\n            billing_period_unit: subscription.billing_period_unit,\n            isNewSubscription: false,\n        }) || Number.MAX_VALUE;\n    // should coming from subscription or delivery configuration\n    let current = dayjs(subscriptionStartDate); //.set('hours', 10).set('minutes', 0);\n    current = current.set('hours', Number(subscription.cutoffTime?.getHours()));\n    current = current.set('minutes', Number(subscription.cutoffTime?.getMinutes()));\n    current = current.set('seconds', 0);\n    while (current.isAfter(rangeStartDate)) {\n        const prevTick = current.subtract(step, 'd');\n        if (prevTick.isSame(subscription.startDate, 'd') || prevTick.isAfter(subscription.startDate)) {\n            current = current.subtract(step, 'd');\n        } else {\n            break;\n        }\n    }\n\n    let subscriptionEndDate = subscription.endDate;\n\n    const pauses = subscription.pauses || [];\n\n    while (isSameOrBefore(current, rangeEndDate)) {\n        const pause = pauses.find((pause) => {\n            const pauseEndDate = dayjs(pause?.endDate).subtract(1, 'm');\n            return (\n                current.isSame(pause.startDate, 'd') ||\n                current.isSame(pauseEndDate) ||\n                (current.isAfter(pause.startDate) && current.isBefore(pauseEndDate))\n            );\n        });\n\n        const haveOrder = orderDates.find((orderDate) => current.isSame(orderDate, 'd'));\n        if (!haveOrder) {\n            if (\n                isSameOrAfter(current, rangeStartDate) &&\n                isSameOrBefore(current, subscriptionEndDate) &&\n                (!subscription.cancelDate || (subscription.cancelDate && current.isBefore(subscription.cancelDate, 'd')))\n            ) {\n                const currentWithAdditionalMinutesForBlockUI = dayjs(current).subtract(\n                    addAdditionalMinutesForBlockUIInMinutes,\n                    'minutes',\n                );\n\n                let subType: EUpcomingDeliverySubType = EUpcomingDeliverySubType.upcomingDelivery;\n                if (pause) {\n                    subType = EUpcomingDeliverySubType.pause;\n                } else if (current.isBefore(subscription.nextBillingAtDate, 'day') && current.isBefore(todayM)) {\n                    // if (!isSameOrAfter(current, todayM))\n                    {\n                        subType = EUpcomingDeliverySubType.skippedButPauseRemoved;\n                        // current = current.add(step, 'd');\n                        // continue;\n                    }\n                } else {\n                    subType =\n                        todayM.isAfter(currentWithAdditionalMinutesForBlockUI) ||\n                        todayM.isSame(currentWithAdditionalMinutesForBlockUI)\n                            ? EUpcomingDeliverySubType.blockedForUpdate\n                            : EUpcomingDeliverySubType.upcomingDelivery;\n                }\n                if (\n                    subscription.has_scheduled_changes &&\n                    isSameOrAfter(current, subscription.nextBillingAtDate) &&\n                    subscription.subscription_with_scheduled_changes?.id\n                ) {\n                    res.push({\n                        id: generateId('event'),\n                        title: `${subscription.id}`,\n                        start: current.toDate(),\n                        allDay: true,\n                        editable: false,\n                        metadata: {\n                            type: ECalendarEventType.subscription,\n                            subscriptionObj: {\n                                subscription: subscription.subscription_with_scheduled_changes,\n                                subType,\n                                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                                subscriptionBillingDate: current.toDate(),\n                                subscriptionBillingDate_blockedOnUI: dayjs(current)\n                                    .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                                    .toDate(),\n                                totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0),\n                            },\n                        },\n                        extraDate: current.toDate(),\n                    });\n\n                    step =\n                        getStep({\n                            billing_period: subscription.subscription_with_scheduled_changes?.billing_period || 0,\n                            billing_period_unit: subscription.subscription_with_scheduled_changes?.billing_period_unit,\n                            isNewSubscription: false,\n                        }) || Number.MAX_VALUE;\n                    subscriptionEndDate = subscription.subscription_with_scheduled_changes?.endDate;\n                } else if (\n                    !isSameOrAfter(current, subscription.nextBillingAtDate) &&\n                    subType == EUpcomingDeliverySubType.upcomingDelivery\n                ) {\n                    // do nothing it's not possible\n                    // upcoming delivery will be available only after nextBillingAt or in the same day\n                } else {\n                    const title = `${subscription.id}`;\n                    res.push({\n                        id: generateId('event'),\n                        title,\n                        start: current.toDate(),\n                        allDay: true,\n                        editable: false,\n                        metadata: {\n                            subscriptionObj: {\n                                subscription,\n                                subType,\n                                subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                                subscriptionBillingDate: current.toDate(),\n                                subscriptionBillingDate_blockedOnUI: dayjs(current)\n                                    .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                                    .toDate(),\n                                totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0),\n                            },\n\n                            type: ECalendarEventType.subscription,\n                        },\n                        extraDate: current.toDate(),\n                    });\n                }\n            }\n        }\n        current = current.add(step, 'd');\n    }\n\n    return res;\n}\n\nexport function getEventsFromPrice({\n    price,\n    rangeStartDate,\n    rangeEndDate,\n    cutOff,\n    isNewSubscription,\n}: {\n    price: IItemPriceCommon;\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    cutOff: number;\n    isNewSubscription: boolean;\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    let current = rangeStartDate ? dayjs(rangeStartDate) : dayjs(getNow()).hour(23).minute(59).second(59);\n    const step =\n        getStep({ billing_period: price.period || 0, billing_period_unit: price.period_unit, isNewSubscription }) ||\n        Number.MAX_VALUE;\n    const subscriptionEndDate = new Date(8640000000000000);\n\n    while (isSameOrBefore(current, rangeEndDate)) {\n        if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate)) {\n            res.push({\n                id: generateId('event'),\n                title: formatDate(current.toDate()),\n                start: current.toDate(),\n                allDay: true,\n                editable: false,\n                metadata: {\n                    type: ECalendarEventType.subscription,\n                    priceObj: {\n                        price,\n                        subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                        subscriptionBillingDate: current.toDate(),\n                        subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(0, 'minutes').toDate(),\n                    },\n\n                    // subscriptionSkipObject: undefined,\n                },\n                extraDate: current.toDate(),\n            });\n        }\n        current = current.add(step, 'd');\n    }\n\n    return res;\n}\n\nexport const getAllEvents = ({\n    today,\n    subscriptions,\n    range,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    today: Date;\n    range: ICalendarDateRange | undefined;\n    subscriptions: ISubscriptionCommon[] | undefined;\n    orders: IOrderCommon[] | undefined;\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] => {\n    const subscriptionEvents = getEventsFromSubscriptions(\n        today,\n        subscriptions || [],\n        range?.start,\n        range?.end,\n        orders?.map((o) => o.orderDate) || [],\n        addAdditionalMinutesForBlockUIInMinutes,\n    );\n\n    const orderEvents = getEventsFromOrders({\n        orders: orders || [],\n        rangeStartDate: range?.start,\n        rangeEndDate: range?.end,\n        addAdditionalMinutesForBlockUIInMinutes,\n    });\n    return [...subscriptionEvents, ...orderEvents].sort((a, b) =>\n        (a.start as Date).getTime && (b.start as Date).getTime && (a.start as Date)?.getTime() > (b.start as Date)?.getTime()\n            ? 1\n            : -1,\n    );\n};\n\nexport function getFirstEvent<T extends ICalendarEventCommon>(events: ICalendarEventCommon[]): T | undefined {\n    const [firstEvent] = events\n        .filter(\n            (f) =>\n                f.metadata?.type === ECalendarEventType.subscription &&\n                f.metadata.subscriptionObj?.subType !== EUpcomingDeliverySubType.skippedButPauseRemoved,\n        )\n        // filter past skips\n        .filter(\n            (f) =>\n                f.metadata?.subscriptionObj?.subType !== EUpcomingDeliverySubType.pause ||\n                (f.metadata?.subscriptionObj?.subType === EUpcomingDeliverySubType.pause &&\n                    f.metadata?.subscriptionObj.subscriptionBillingDate.getTime() > getNow().getTime()),\n        );\n    return firstEvent as T;\n}\n"]},"metadata":{},"sourceType":"module"}
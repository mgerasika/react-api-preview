{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar equals_util = require('./equals.util.js');\nfunction removeUndefined(obj) {\n  return removeRecursive(obj, arg => arg.value === undefined) || {};\n}\nfunction removeUndefinedAndEmptyString(obj) {\n  return removeRecursive(obj, arg => arg.value === undefined || arg.value === '') || {};\n}\nfunction removeDuplicate(obj1, obj2) {\n  return removeRecursive(obj1, arg => {\n    return equals_util.equals(arg.value, obj2 ? obj2[arg.name] : undefined);\n  }) || {};\n}\nfunction removeDuplicateAndUndefined(obj1, obj2) {\n  const res1 = obj1 && obj2 ? removeDuplicate(obj1, obj2) : obj1;\n  return removeUndefined(res1) || {};\n}\nfunction removeRecursive(obj, canRemove) {\n  if (obj) {\n    if (Array.isArray(obj)) {\n      return obj.map(v => removeRecursive(v, canRemove)).filter(f => f !== undefined);\n    }\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || obj instanceof Date) {\n      return obj;\n    }\n    const keys = Object.keys(obj);\n    const res = {};\n    keys.forEach(key => {\n      const val = obj[key];\n      if (!canRemove({\n        name: key,\n        value: val\n      })) {\n        if (Array.isArray(val)) {\n          const arrayValues = val.map(v => removeRecursive(v, canRemove)).filter(f => f !== undefined);\n          res[key] = arrayValues;\n        } else if (typeof val === 'object' && val !== null && Object.keys(val).length > 0) {\n          const tmpVal = removeRecursive(val, canRemove);\n          if (!canRemove({\n            name: key,\n            value: tmpVal\n          })) {\n            res[key] = tmpVal;\n          }\n        } else {\n          res[key] = val;\n        }\n      }\n    });\n    return Object.keys(res).length == 0 ? undefined : res;\n  }\n  return undefined;\n}\nexports.removeDuplicate = removeDuplicate;\nexports.removeDuplicateAndUndefined = removeDuplicateAndUndefined;\nexports.removeUndefined = removeUndefined;\nexports.removeUndefinedAndEmptyString = removeUndefinedAndEmptyString;","map":{"version":3,"sources":["../../../src/utils/remove-undefined.util.ts"],"names":["removeUndefined","obj","removeRecursive","arg","value","undefined","removeUndefinedAndEmptyString","removeDuplicate","obj1","obj2","equals","name","removeDuplicateAndUndefined","res1","canRemove","Array","isArray","map","v","filter","f","Date","keys","Object","res","forEach","key","val","arrayValues","length","tmpVal"],"mappings":"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","sourcesContent":["import { IDictionary } from '@common/interfaces/dictionary.interface';\nimport { equals } from './equals.util';\n\nexport function removeUndefined<T>(obj: T): T {\n    return removeRecursive(obj, (arg: { name: string; value: unknown }): boolean => arg.value === undefined) || ({} as T);\n}\n\nexport function removeUndefinedAndEmptyString<T>(obj: T): T {\n    return (\n        removeRecursive(\n            obj,\n            (arg: { name: string; value: unknown }): boolean => arg.value === undefined || arg.value === '',\n        ) || ({} as T)\n    );\n}\nexport function removeDuplicate<T>(obj1: T, obj2?: T): T {\n    return (\n        removeRecursive(obj1, (arg: { name: string; value: unknown }): boolean => {\n            return equals(arg.value, obj2 ? obj2[arg.name] : undefined);\n        }) || ({} as T)\n    );\n}\n\nexport function removeDuplicateAndUndefined<T>(obj1: T, obj2?: T): T {\n    const res1 = obj1 && obj2 ? removeDuplicate(obj1, obj2) : obj1;\n    return removeUndefined(res1) || ({} as T);\n}\n\nfunction removeRecursive<T>(obj: T, canRemove: (arg: { name: string; value: unknown }) => boolean): T {\n    if (obj) {\n        if (Array.isArray(obj)) {\n            return obj.map((v) => removeRecursive(v, canRemove)).filter((f) => f !== undefined) as unknown as T;\n        }\n        if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || obj instanceof Date) {\n            return obj;\n        }\n        const keys = Object.keys(obj);\n        const res = {} as IDictionary;\n        keys.forEach((key) => {\n            const val = obj[key];\n            if (!canRemove({ name: key, value: val })) {\n                if (Array.isArray(val)) {\n                    const arrayValues = val.map((v) => removeRecursive(v, canRemove)).filter((f) => f !== undefined);\n                    res[key] = arrayValues;\n                } else if (typeof val === 'object' && val !== null && Object.keys(val).length > 0) {\n                    const tmpVal = removeRecursive(val, canRemove);\n                    if (!canRemove({ name: key, value: tmpVal })) {\n                        res[key] = tmpVal;\n                    }\n                } else {\n                    res[key] = val;\n                }\n            }\n        });\n\n        return Object.keys(res).length == 0 ? (undefined as unknown as T) : (res as unknown as T);\n    }\n    return undefined as unknown as T;\n}\n"]},"metadata":{},"sourceType":"script"}
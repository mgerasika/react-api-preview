{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nvar ParseErrorCode = {\n  SyntaxError: \"BABEL_PARSER_SYNTAX_ERROR\",\n  SourceTypeModuleError: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n};\nconst reflect = function (keys) {\n  let last = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keys.length - 1;\n  return {\n    get() {\n      return keys.reduce((object, key) => object[key], this);\n    },\n    set(value) {\n      keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);\n    }\n  };\n};\nconst instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map(key => [key, descriptors[key]]).filter(_ref3 => {\n  let [, descriptor] = _ref3;\n  return !!descriptor;\n}).map(_ref4 => {\n  let [key, descriptor] = _ref4;\n  return [key, typeof descriptor === \"function\" ? {\n    value: descriptor,\n    enumerable: false\n  } : typeof descriptor.reflect === \"string\" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split(\".\"))) : descriptor];\n}).reduce((instance, _ref5) => {\n  let [key, descriptor] = _ref5;\n  return Object.defineProperty(instance, key, Object.assign({\n    configurable: true\n  }, descriptor));\n}, Object.assign(new constructor(), properties));\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code: ParseErrorCode.SourceTypeModuleError\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code: ParseErrorCode.SourceTypeModuleError\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = _ref6 => {\n  let {\n    type,\n    prefix\n  } = _ref6;\n  return type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];\n};\nvar StandardErrors = {\n  AccessorIsGenerator: _ref7 => {\n    let {\n      kind\n    } = _ref7;\n    return `A ${kind}ter cannot be a generator.`;\n  },\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accesor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accesor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accesor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: _ref8 => {\n    let {\n      kind\n    } = _ref8;\n    return `Missing initializer in ${kind} declaration.`;\n  },\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: _ref9 => {\n    let {\n      exportName\n    } = _ref9;\n    return `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`;\n  },\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: _ref10 => {\n    let {\n      localName,\n      exportName\n    } = _ref10;\n    return `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`;\n  },\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: _ref11 => {\n    let {\n      type\n    } = _ref11;\n    return `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`;\n  },\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: _ref12 => {\n    let {\n      type\n    } = _ref12;\n    return `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`;\n  },\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportBindingIsString: _ref13 => {\n    let {\n      importName\n    } = _ref13;\n    return `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`;\n  },\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: _ref14 => {\n    let {\n      maxArgumentCount\n    } = _ref14;\n    return `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`;\n  },\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: _ref15 => {\n    let {\n      radix\n    } = _ref15;\n    return `Expected number in radix ${radix}.`;\n  },\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: _ref16 => {\n    let {\n      reservedWord\n    } = _ref16;\n    return `Escape sequence in keyword ${reservedWord}.`;\n  },\n  InvalidIdentifier: _ref17 => {\n    let {\n      identifierName\n    } = _ref17;\n    return `Invalid identifier ${identifierName}.`;\n  },\n  InvalidLhs: _ref18 => {\n    let {\n      ancestor\n    } = _ref18;\n    return `Invalid left-hand side in ${toNodeDescription(ancestor)}.`;\n  },\n  InvalidLhsBinding: _ref19 => {\n    let {\n      ancestor\n    } = _ref19;\n    return `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`;\n  },\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: _ref20 => {\n    let {\n      unexpected\n    } = _ref20;\n    return `Unexpected character '${unexpected}'.`;\n  },\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: _ref21 => {\n    let {\n      identifierName\n    } = _ref21;\n    return `Private name #${identifierName} is not defined.`;\n  },\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: _ref22 => {\n    let {\n      labelName\n    } = _ref22;\n    return `Label '${labelName}' is already declared.`;\n  },\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: _ref23 => {\n    let {\n      missingPlugin\n    } = _ref23;\n    return `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`;\n  },\n  MissingOneOfPlugins: _ref24 => {\n    let {\n      missingPlugin\n    } = _ref24;\n    return `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`;\n  },\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: _ref25 => {\n    let {\n      key\n    } = _ref25;\n    return `Duplicate key \"${key}\" is not allowed in module attributes.`;\n  },\n  ModuleExportNameHasLoneSurrogate: _ref26 => {\n    let {\n      surrogateCharCode\n    } = _ref26;\n    return `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`;\n  },\n  ModuleExportUndefined: _ref27 => {\n    let {\n      localName\n    } = _ref27;\n    return `Export '${localName}' is not defined.`;\n  },\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: _ref28 => {\n    let {\n      identifierName\n    } = _ref28;\n    return `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`;\n  },\n  PrivateNameRedeclaration: _ref29 => {\n    let {\n      identifierName\n    } = _ref29;\n    return `Duplicate private name #${identifierName}.`;\n  },\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: _ref30 => {\n    let {\n      keyword\n    } = _ref30;\n    return `Unexpected keyword '${keyword}'.`;\n  },\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: _ref31 => {\n    let {\n      reservedWord\n    } = _ref31;\n    return `Unexpected reserved word '${reservedWord}'.`;\n  },\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: _ref32 => {\n    let {\n      expected,\n      unexpected\n    } = _ref32;\n    return `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`;\n  },\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: _ref33 => {\n    let {\n      target,\n      onlyValidPropertyName\n    } = _ref33;\n    return `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`;\n  },\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: _ref34 => {\n    let {\n      identifierName\n    } = _ref34;\n    return `Identifier '${identifierName}' has already been declared.`;\n  },\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: _ref35 => {\n    let {\n      referenceName\n    } = _ref35;\n    return `Assigning to '${referenceName}' in strict mode.`;\n  },\n  StrictEvalArgumentsBinding: _ref36 => {\n    let {\n      bindingName\n    } = _ref36;\n    return `Binding '${bindingName}' in strict mode.`;\n  },\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: _ref37 => {\n    let {\n      token\n    } = _ref37;\n    return `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`;\n  },\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: _ref38 => {\n    let {\n      type\n    } = _ref38;\n    return `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n      type\n    })}; please wrap it in parentheses.`;\n  },\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n};\nconst _excluded$1 = [\"toMessage\"],\n  _excluded2$1 = [\"message\"];\nfunction toParseErrorConstructor(_ref) {\n  let {\n      toMessage\n    } = _ref,\n    properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n  return function constructor(_ref39) {\n    let {\n      loc,\n      details\n    } = _ref39;\n    return instantiate(SyntaxError, Object.assign({}, properties, {\n      loc\n    }), {\n      clone() {\n        let overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const loc = overrides.loc || {};\n        return constructor({\n          loc: new Position(\"line\" in loc ? loc.line : this.loc.line, \"column\" in loc ? loc.column : this.loc.column, \"index\" in loc ? loc.index : this.loc.index),\n          details: Object.assign({}, this.details, overrides.details)\n        });\n      },\n      details: {\n        value: details,\n        enumerable: false\n      },\n      message: {\n        get() {\n          return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;\n        },\n        set(value) {\n          Object.defineProperty(this, \"message\", {\n            value\n          });\n        }\n      },\n      pos: {\n        reflect: \"loc.index\",\n        enumerable: true\n      },\n      missingPlugin: \"missingPlugin\" in details && {\n        reflect: \"details.missingPlugin\",\n        enumerable: true\n      }\n    });\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref2 = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref2,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: ParseErrorCode.SyntaxError,\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral(_ref40) {\n    let {\n      pattern,\n      flags\n    } = _ref40;\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = \"Literal\";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = \"ExpressionStatement\";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n    classBody.body.push(method);\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression) {\n    let isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {\n    let inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    return this.finishNode(node, \"MethodDefinition\");\n  }\n  parseClassProperty() {\n    const propertyNode = super.parseClassProperty(...arguments);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n  parseClassPrivateProperty() {\n    const propertyNode = super.parseClassPrivateProperty(...arguments);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node) {\n    let isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, {\n        at: prop.key\n      });\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      if (this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$;\n        node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n      }\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n    return node;\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node) {\n    let endLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEndLoc;\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label) {\n    let conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 130;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 130;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 134;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 127 && token <= 129;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 119 && token <= 121;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 122 && token <= 128;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[140].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nconst SCOPE_OTHER = 0b000000000,\n  SCOPE_PROGRAM = 0b000000001,\n  SCOPE_FUNCTION = 0b000000010,\n  SCOPE_ARROW = 0b000000100,\n  SCOPE_SIMPLE_CATCH = 0b000001000,\n  SCOPE_SUPER = 0b000010000,\n  SCOPE_DIRECT_SUPER = 0b000100000,\n  SCOPE_CLASS = 0b001000000,\n  SCOPE_STATIC_BLOCK = 0b010000000,\n  SCOPE_TS_MODULE = 0b100000000,\n  SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n  BIND_KIND_TYPE = 0b000000000010,\n  BIND_SCOPE_VAR = 0b000000000100,\n  BIND_SCOPE_LEXICAL = 0b000000001000,\n  BIND_SCOPE_FUNCTION = 0b000000010000,\n  BIND_FLAGS_NONE = 0b0000001000000,\n  BIND_FLAGS_CLASS = 0b0000010000000,\n  BIND_FLAGS_TS_ENUM = 0b0000100000000,\n  BIND_FLAGS_TS_CONST_ENUM = 0b0001000000000,\n  BIND_FLAGS_TS_EXPORT_ONLY = 0b0010000000000,\n  BIND_FLAGS_FLOW_DECLARE_FN = 0b0100000000000,\n  BIND_FLAGS_TS_IMPORT = 0b1000000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n  BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n  BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n  BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n  BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n  BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n  BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n  BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n  BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n  BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n  BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n  BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n  BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT,\n  BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n  CLASS_ELEMENT_KIND_GETTER = 0b010,\n  CLASS_ELEMENT_KIND_SETTER = 0b001,\n  CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n  CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n  CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n  CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n  CLASS_ELEMENT_OTHER = 0;\nclass Scope {\n  constructor(flags) {\n    this.var = new Set();\n    this.lexical = new Set();\n    this.functions = new Set();\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & SCOPE_PROGRAM) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & SCOPE_STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);\n    }\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);\n    }\n    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & SCOPE_VAR) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor() {\n    super(...arguments);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.hasFlowComment = false;\n    this.isAmbientContext = false;\n    this.inAbstractClass = false;\n    this.inDisallowConditionalTypesContext = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.comments = [];\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 137;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.context = [types.brace];\n    this.canStartJSXElement = true;\n    this.containsEsc = false;\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  init(_ref41) {\n    let {\n      strictMode,\n      sourceType,\n      startLine,\n      startColumn\n    } = _ref41;\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n      state[key] = val;\n    }\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nconst _excluded = [\"at\"],\n  _excluded2 = [\"at\"];\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery) return false;\n        this.raise(Errors.InvalidDigit, {\n          at: buildPosition(pos, lineStart, curLine),\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n          at: buildPosition(pos, lineStart, curLine)\n        });\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, {\n          at: buildPosition(pos - 1, lineStart, curLine)\n        });\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, {\n          at: buildPosition(pos, lineStart, curLine)\n        });\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(_ref42 => {\n        let [toParseError, at] = _ref42;\n        return this.raise(toParseError, {\n          at\n        });\n      });\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(137);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition()\n      });\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {\n          at: this.state.curPosition()\n        });\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(136, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(136, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        throw this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          this.expectPlugin(\"regexpUnicodeSets\", nextPos());\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, {\n            at: nextPos()\n          });\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, {\n          at: nextPos()\n        });\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(135, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len) {\n    let forceLen = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let allowNumSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, {\n        at: startLoc\n      });\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(133, str);\n      return;\n    }\n    this.finishToken(132, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, {\n        at: this.state.curPosition()\n      });\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {\n        at: startLoc\n      });\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos)\n          });\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, {\n          at: startLoc\n        });\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, {\n          at: startLoc\n        });\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, {\n          at: startLoc\n        });\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(133, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(134, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(132, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(131, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, _ref43) {\n    let {\n      at\n    } = _ref43;\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, {\n        at\n      });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition()\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, {\n              at: escStart\n            });\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(130, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, raiseProperties) {\n    const {\n        at\n      } = raiseProperties,\n      details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError({\n      loc,\n      details\n    });\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, raiseProperties) {\n    const {\n        at\n      } = raiseProperties,\n      details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError({\n          loc,\n          details\n        });\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, raiseProperties);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, {\n        at: buildPosition(pos, lineStart, curLine)\n      });\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n          at: loc,\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n}\nconst kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3;\nclass ExpressionScope {\n  constructor() {\n    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : kExpression;\n    this.type = void 0;\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, _ref44) {\n    let {\n      at\n    } = _ref44;\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, _ref45) {\n    let {\n      at: node\n    } = _ref45;\n    const origin = {\n      at: node.loc.start\n    };\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParemeterBindingError(error, _ref46) {\n    let {\n      at: node\n    } = _ref46;\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = {\n      at: node.loc.start\n    };\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(_ref47) {\n    let {\n      at\n    } = _ref47;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {\n          at\n        });\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(_ref48 => {\n      let [toParseError, loc] = _ref48;\n      this.parser.raise(toParseError, {\n        at: loc\n      });\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nconst PARAM = 0b0000,\n  PARAM_YIELD = 0b0001,\n  PARAM_AWAIT = 0b0010,\n  PARAM_RETURN = 0b0100,\n  PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value) {\n    let enumerable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, {\n          at: this.state.startLoc\n        });\n      }\n      throw this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon() {\n    let allowAsi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, {\n      at: this.state.lastTokEndLoc\n    });\n  }\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n  tryParse(fn) {\n    let oldState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn(function () {\n        let node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc\n      });\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, {\n        at: doubleProtoLoc\n      });\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, {\n        at: privateKeyLoc\n      });\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes() {\n    let inModule = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.sourceType === \"module\";\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node) {\n    let endLoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEndLoc;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: _ref49 => {\n    let {\n      reservedType\n    } = _ref49;\n    return `Cannot overwrite reserved type ${reservedType}.`;\n  },\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: _ref50 => {\n    let {\n      memberName,\n      enumName\n    } = _ref50;\n    return `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`;\n  },\n  EnumDuplicateMemberName: _ref51 => {\n    let {\n      memberName,\n      enumName\n    } = _ref51;\n    return `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`;\n  },\n  EnumInconsistentMemberValues: _ref52 => {\n    let {\n      enumName\n    } = _ref52;\n    return `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;\n  },\n  EnumInvalidExplicitType: _ref53 => {\n    let {\n      invalidEnumType,\n      enumName\n    } = _ref53;\n    return `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`;\n  },\n  EnumInvalidExplicitTypeUnknownSupplied: _ref54 => {\n    let {\n      enumName\n    } = _ref54;\n    return `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`;\n  },\n  EnumInvalidMemberInitializerPrimaryType: _ref55 => {\n    let {\n      enumName,\n      memberName,\n      explicitType\n    } = _ref55;\n    return `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`;\n  },\n  EnumInvalidMemberInitializerSymbolType: _ref56 => {\n    let {\n      enumName,\n      memberName\n    } = _ref56;\n    return `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`;\n  },\n  EnumInvalidMemberInitializerUnknownType: _ref57 => {\n    let {\n      enumName,\n      memberName\n    } = _ref57;\n    return `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`;\n  },\n  EnumInvalidMemberName: _ref58 => {\n    let {\n      enumName,\n      memberName,\n      suggestion\n    } = _ref58;\n    return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`;\n  },\n  EnumNumberMemberNotInitialized: _ref59 => {\n    let {\n      enumName,\n      memberName\n    } = _ref59;\n    return `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`;\n  },\n  EnumStringMemberInconsistentlyInitailized: _ref60 => {\n    let {\n      enumName\n    } = _ref60;\n    return `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`;\n  },\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: _ref61 => {\n    let {\n      reservedType\n    } = _ref61;\n    return `Unexpected reserved type ${reservedType}.`;\n  },\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: _ref62 => {\n    let {\n      unsupportedExportKind,\n      suggestion\n    } = _ref62;\n    return `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`;\n  },\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nfunction isMaybeDefaultImport(type) {\n  return tokenIsKeywordOrIdentifier(type) && type !== 97;\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor() {\n    super(...arguments);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n  finishToken(type, val) {\n    if (type !== 131 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    return super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    return super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(108);\n    if (this.state.lastTokStart > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n        at: moduloLoc\n      });\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(125)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(128)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(127)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n    if (this.match(131)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(128) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n      body.push(bodyNode);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n            at: bodyElement\n          });\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n          at: this.state.startLoc,\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n    throw this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(109);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node) {\n    let isClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (this.isContextual(115)) {\n      this.next();\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    if (this.isContextual(111)) {\n      this.next();\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n        at: this.state.startLoc\n      });\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {\n      at: startLoc,\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(128);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter() {\n    let requireDefault = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, {\n          at: nodeStartLoc\n        });\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(140)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(127);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType(_ref63) {\n    let {\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact\n    } = _ref63;\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(116)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(104)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(98) || this.isContextual(103)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n          at: inexactStartLoc\n        });\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, {\n            at: this.state.lastTokStartLoc\n          });\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, {\n            at: variance\n          });\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, {\n          at: this.state.lastTokStartLoc\n        });\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, {\n          at: variance\n        });\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, {\n            at: node.value.this\n          });\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {\n        at: property.value.this\n      });\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: property\n      });\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: property\n      });\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    var _startLoc;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node\n        });\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n            at: node\n          });\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 10:\n        this.next();\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 131:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(132)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(133)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n            at: this.state.startLoc\n          });\n        }\n        throw this.unexpected();\n      case 132:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 133:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(127)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    throw this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 130 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody) {\n    let isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type) {\n    let isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.isContextual(127)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(124)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatement(context, topLevel);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(124)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, {\n          at: state.startLoc\n        });\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return node;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExport(node, decorators) {\n    const decl = super.parseExport(node, decorators);\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n    return decl;\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(128)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(127)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(124)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(128) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(123)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, {\n          at: startLoc\n        });\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, {\n          at: member.value\n        });\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, {\n        at: this.state.curPosition(),\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(130, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      return this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        return this.finishOp(18, 2);\n      }\n      return this.finishOp(17, 1);\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      return this.readIterator();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node) {\n    let isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, {\n          at: expr.typeAnnotation\n        });\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    if (this.isContextual(111)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, {\n          at: param\n        });\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, {\n          at: param\n        });\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n          at: param\n        });\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, {\n        at: param\n      });\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, {\n        at: param\n      });\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, {\n        at: node.typeAnnotation\n      });\n    }\n    return node;\n  }\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n    return isMaybeDefaultImport(this.state.type);\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, {\n        at: node.specifiers[0].loc.start\n      });\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n    if (this.match(87)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(128)) {\n      kind = \"type\";\n    }\n    if (kind) {\n      const lh = this.lookahead();\n      const {\n        type\n      } = lh;\n      if (kind === \"type\" && type === 55) {\n        this.unexpected(null, lh.type);\n      }\n      if (isMaybeDefaultImport(type) || type === 5 || type === 55) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, {\n            at: specifier,\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n        at: specifier\n      });\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, allowModifiers);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(140) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {\n              at: typeParameters\n            });\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n        at: typeParameters\n      });\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    let strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node.params[i]\n        });\n      }\n    }\n    return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, {\n        at: this.state.curPosition()\n      });\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, {\n          at: this.state.startLoc\n        });\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, _ref64) {\n    let {\n      enumName,\n      memberName\n    } = _ref64;\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n      at: loc,\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({\n      at: loc\n    }, enumContext));\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, _ref65) {\n    let {\n      enumName,\n      memberName\n    } = _ref65;\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n      at: loc,\n      enumName,\n      memberName\n    });\n  }\n  flowEnumErrorStringMemberInconsistentlyInitailized(node, _ref66) {\n    let {\n      enumName\n    } = _ref66;\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {\n      at: node,\n      enumName\n    });\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 132:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 131:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers(_ref67) {\n    let {\n      enumName,\n      explicitType\n    } = _ref67;\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, {\n          at: id,\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, {\n          at: id,\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, _ref68) {\n    let {\n      enumName\n    } = _ref68;\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType(_ref69) {\n    let {\n      enumName\n    } = _ref69;\n    if (!this.eatContextual(101)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n        at: this.state.startLoc,\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, {\n        at: this.state.startLoc,\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: _ref70 => {\n    let {\n      openingTagName\n    } = _ref70;\n    return `Expected corresponding JSX closing tag for <${openingTagName}>.`;\n  },\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: _ref71 => {\n    let {\n      unexpected,\n      HTMLEntity\n    } = _ref71;\n    return `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`;\n  },\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, {\n          at: this.state.startLoc\n        });\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              return this.finishToken(140);\n            }\n            return super.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(139, out);\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, {\n          at: this.state.startLoc\n        });\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(131, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    return this.finishToken(138, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(138)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, {\n            at: node\n          });\n        }\n        return node;\n      case 140:\n      case 131:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, {\n          at: this.state.startLoc\n        });\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(141)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(141)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(141);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(141)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(141);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 140:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 139:\n            children.push(this.parseExprAtom());\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            throw this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, {\n          at: closingElement\n        });\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, {\n          at: closingElement,\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n        at: this.state.startLoc\n      });\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(139)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(140)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(140);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      return this.jsxReadToken();\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(141);\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(140);\n    }\n    return super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 140) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 140) {\n      context.push(types.j_oTag);\n    } else if (type === 141) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor() {\n    super(...arguments);\n    this.types = new Set();\n    this.enums = new Set();\n    this.constEnums = new Set();\n    this.classes = new Set();\n    this.exportOnlyBindings = new Set();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor() {\n    super(...arguments);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags == SCOPE_TS_MODULE) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags == SCOPE_TS_MODULE) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & BIND_FLAGS_TS_IMPORT) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, {\n          at: loc,\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      scope.types.add(name);\n    }\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.has(name)) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;\n    }\n    super.checkLocalExport(id);\n  }\n}\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: _ref72 => {\n    let {\n      methodName\n    } = _ref72;\n    return `Method '${methodName}' cannot have an implementation because it is marked abstract.`;\n  },\n  AbstractPropertyHasInitializer: _ref73 => {\n    let {\n      propertyName\n    } = _ref73;\n    return `Property '${propertyName}' cannot have an initializer because it is marked abstract.`;\n  },\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: _ref74 => {\n    let {\n      kind\n    } = _ref74;\n    return `'declare' is not allowed in ${kind}ters.`;\n  },\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: _ref75 => {\n    let {\n      modifier\n    } = _ref75;\n    return `Accessibility modifier already seen.`;\n  },\n  DuplicateModifier: _ref76 => {\n    let {\n      modifier\n    } = _ref76;\n    return `Duplicate modifier: '${modifier}'.`;\n  },\n  EmptyHeritageClauseType: _ref77 => {\n    let {\n      token\n    } = _ref77;\n    return `'${token}' list cannot be empty.`;\n  },\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: _ref78 => {\n    let {\n      modifiers\n    } = _ref78;\n    return `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`;\n  },\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: _ref79 => {\n    let {\n      modifier\n    } = _ref79;\n    return `Index signatures cannot have an accessibility modifier ('${modifier}').`;\n  },\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: _ref80 => {\n    let {\n      modifier\n    } = _ref80;\n    return `'${modifier}' modifier cannot appear on a type member.`;\n  },\n  InvalidModifierOnTypeParameter: _ref81 => {\n    let {\n      modifier\n    } = _ref81;\n    return `'${modifier}' modifier cannot appear on a type parameter.`;\n  },\n  InvalidModifierOnTypeParameterPositions: _ref82 => {\n    let {\n      modifier\n    } = _ref82;\n    return `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`;\n  },\n  InvalidModifiersOrder: _ref83 => {\n    let {\n      orderedModifiers\n    } = _ref83;\n    return `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`;\n  },\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: _ref84 => {\n    let {\n      modifier\n    } = _ref84;\n    return `Private elements cannot have an accessibility modifier ('${modifier}').`;\n  },\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: _ref85 => {\n    let {\n      typeParameterName\n    } = _ref85;\n    return `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`;\n  },\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: _ref86 => {\n    let {\n      type\n    } = _ref86;\n    return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`;\n  }\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers(_ref87) {\n    let {\n      modified,\n      allowedModifiers,\n      disallowedModifiers,\n      stopOnStartOfClassStaticBlock,\n      errorTemplate = TSErrors.InvalidModifierOnTypeMember\n    } = _ref87;\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, {\n          at: loc,\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, {\n          at: loc,\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, {\n          at: startLoc,\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n    throw new Error(\"Unreachable\");\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStart;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(131)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, {\n        at: this.state.startLoc\n      });\n    }\n    node.argument = super.parseExprAtom();\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseEntityName() {\n    let allowReservedWords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let entity = this.parseIdentifier(allowReservedWords);\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseInOutModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  tsParseNoneModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n  }\n  tsParseTypeParameter() {\n    let parseModifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tsParseNoneModifiers.bind(this);\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(140)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, {\n        at: node\n      });\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    return super.parseBindingList(11, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n          at: pattern,\n          type: pattern.type\n        });\n      }\n      return pattern;\n    });\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, {\n          at: node\n        });\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n          at: this.state.curPosition()\n        });\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, {\n            at: this.state.curPosition()\n          });\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, {\n            at: this.state.curPosition()\n          });\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n              at: this.state.curPosition()\n            });\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n            at: method[returnTypeKey]\n          });\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    });\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(120);\n    }\n    if (this.isContextual(120)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(120);\n    } else if (this.eatContextual(120)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, {\n          at: elementNode\n        });\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n      let checkType = type;\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        checkType = elementNode.type;\n      }\n      const isLabeled = checkType === \"TSNamedTupleMember\";\n      (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;\n      if (labeledElements !== isLabeled) {\n        this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {\n          at: elementNode\n        });\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const {\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let type = this.tsParseType();\n    const optional = this.eat(17);\n    const labeled = this.eat(14);\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(TSErrors.InvalidTupleMemberLabel, {\n          at: type\n        });\n        labeledNode.label = type;\n      }\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    node.literal = (() => {\n      switch (this.state.type) {\n        case 132:\n        case 133:\n        case 131:\n        case 85:\n        case 86:\n          return super.parseExprAtom();\n        default:\n          throw this.unexpected();\n      }\n    })();\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 131:\n      case 132:\n      case 133:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 132 && nextToken.type !== 133) {\n            throw this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    throw this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, {\n          at: node\n        });\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(113);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;\n  }\n  tsTryParseTypeAnnotation() {\n    return this.match(14) ? this.tsParseTypeAnnotation() : undefined;\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 107) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.lastTokStartLoc,\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation() {\n    let eatColon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(122) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, {\n        at: this.state.startLoc\n      });\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, {\n        at: originalStartLoc,\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node) {\n    let properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(127);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BIND_TS_INTERFACE);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, {\n        at: this.state.startLoc\n      });\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_TS_TYPE);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n      this.expect(29);\n      if (this.isContextual(112) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node) {\n    let properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(124);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node) {\n    let nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, BIND_TS_NAMESPACE);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(110)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(131)) {\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, {\n        at: moduleReference\n      });\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(117) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(117);\n    this.expect(10);\n    if (!this.match(131)) {\n      throw this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let starttype = this.state.type;\n    let kind;\n    if (this.isContextual(99)) {\n      starttype = 74;\n      kind = \"let\";\n    }\n    return this.tsInAmbientContext(() => {\n      if (starttype === 68) {\n        nany.declare = true;\n        return super.parseFunctionStatement(nany, false, true);\n      }\n      if (starttype === 80) {\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n      }\n      if (starttype === 124) {\n        return this.tsParseEnumDeclaration(nany, {\n          declare: true\n        });\n      }\n      if (starttype === 110) {\n        return this.tsParseAmbientExternalModuleDeclaration(nany);\n      }\n      if (starttype === 75 || starttype === 74) {\n        if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n          nany.declare = true;\n          return this.parseVarStatement(nany, kind || this.state.value, true);\n        }\n        this.expect(75);\n        return this.tsParseEnumDeclaration(nany, {\n          const: true,\n          declare: true\n        });\n      }\n      if (starttype === 127) {\n        const result = this.tsParseInterfaceDeclaration(nany, {\n          declare: true\n        });\n        if (result) return result;\n      }\n      if (tokenIsIdentifier(starttype)) {\n        return this.tsParseDeclaration(nany, this.state.value, true, null);\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n          break;\n        }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(131)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) {\n      return undefined;\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) {\n      return undefined;\n    }\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) {\n      return undefined;\n    }\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, {\n        at: node\n      });\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n    let override = false;\n    if (allowModifiers !== undefined) {\n      const modified = {};\n      this.tsParseModifiers({\n        modified,\n        allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n      });\n      accessibility = modified.accessibility;\n      override = modified.override;\n      readonly = modified.readonly;\n      if (allowModifiers === false && (accessibility || readonly || override)) {\n        this.raise(TSErrors.UnexpectedParameterModifier, {\n          at: startLoc\n        });\n      }\n    }\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, {\n          at: pp\n        });\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  parseFunctionBodyAndFinish(node, type) {\n    let isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, {\n        at: node\n      });\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, {\n          at: node.typeAnnotation\n        });\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11, false);\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {\n            at: this.state.startLoc\n          });\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, {\n              at: this.state.startLoc,\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, {\n        at: node.specifiers[0].loc.start\n      });\n    }\n  }\n  checkDuplicateExports() {}\n  parseImport(node) {\n    node.importKind = \"value\";\n    if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {\n      let ahead = this.lookahead();\n      if (this.isContextual(128) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {\n        node.importKind = \"type\";\n        this.next();\n        ahead = this.lookahead();\n      }\n      if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n    }\n    const importNode = super.parseImport(node);\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n        at: importNode\n      });\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      this.next();\n      if (this.isContextual(128) && this.lookaheadCharCode() !== 61) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(126);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(128) && this.lookahead().type === 5) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(122) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(127)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind) {\n    let allowMissingInitializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n          at: init\n        });\n      } else if (init.type !== \"StringLiteral\" && init.type !== \"BooleanLiteral\" && init.type !== \"NumericLiteral\" && init.type !== \"BigIntLiteral\" && (init.type !== \"TemplateLiteral\" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {\n          at: init\n        });\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(context, topLevel, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(124)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(127)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseStatementContent(context, topLevel, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(104) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      modified: member,\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n            at: this.state.curPosition()\n          });\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, {\n          at: member\n        });\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, {\n          at: member,\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, {\n          at: member\n        });\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, {\n          at: member\n        });\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n        at: member\n      });\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, {\n          at: member\n        });\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, {\n        at: methodOrProp\n      });\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, {\n        at: methodOrProp\n      });\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n      return expr;\n    }\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(123)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(123);\n    if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n        at: this.state.startLoc\n      });\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(111)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(35)) {\n      node.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n        at: this.state.startLoc\n      });\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, {\n        at: this.state.startLoc,\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, {\n        at: node\n      });\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, {\n        at: node,\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, {\n        at: typeParameters\n      });\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, {\n        at: method,\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && !node.value.body) return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(111)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(140) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n    if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, {\n        at: node\n      });\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n    }\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\" && !this.state.isAmbientContext && !this.state.inType) {\n        this.raise(TSErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node) {\n    let isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSSatisfiesExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    } else {\n      return super.checkCommaAfterRest(close);\n    }\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, {\n        at: node.typeAnnotation\n      });\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        return this.finishOp(48, 1);\n      }\n      if (code === 60) {\n        return this.finishOp(47, 1);\n      }\n    }\n    return super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(127)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n          at: node\n        });\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, {\n          at: method,\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {\n        at: loc\n      });\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\") return false;\n  if (expression.computed) return false;\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(142)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(142);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(142, 2);\n    }\n    return super.getTokenFromCode(code);\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  hasFollowingIdentifier(context) {\n    if (super.hasFollowingIdentifier(context)) {\n      return true;\n    }\n    if (context) return false;\n    const nextToken = this.lookahead();\n    if (nextToken.type === 142) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(142) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n          at: this.state.startLoc\n        });\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(97);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return plugin[1][option];\n  }\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n    const allowCallParenthesized = getPluginOption(plugins, \"decorators\", \"allowCallParenthesized\");\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (hasPlugin(plugins, \"recordAndTuple\") && getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true\n};\nfunction getOptions(opts) {\n  const options = {};\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n  return options;\n}\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node) {\n    let isLHS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, {\n          at: node\n        });\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc\n            });\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, {\n            at: node.left.loc.end\n          });\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, {\n          at: prop\n        });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, {\n            at: elt\n          });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, {\n            at: trailingCommaLoc\n          });\n        }\n      }\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc\n          });\n        }\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 136) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    var _startLoc, _left;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    }, type);\n  }\n  checkLVal(expression, _ref88) {\n    let {\n      in: ancestor,\n      binding = BIND_NONE,\n      checkClashes = false,\n      strictModeChanged = false,\n      allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),\n      hasParenthesizedAncestor = false\n    } = _ref88;\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    if (type === \"MemberExpression\") {\n      if (binding !== BIND_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, {\n          at: expression\n        });\n      }\n      return;\n    }\n    if (expression.type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, {\n            at: expression\n          });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, {\n        at: expression,\n        ancestor: ancestor.type === \"UpdateExpression\" ? {\n          type: \"UpdateExpression\",\n          prefix: ancestor.prefix\n        } : {\n          type: ancestor.type\n        }\n      });\n      return;\n    }\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = expression.type === \"ArrayPattern\" || expression.type === \"ObjectPattern\" || expression.type === \"ParenthesizedExpression\" ? expression : ancestor;\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          allowingSloppyLetBinding,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n  checkIdentifier(at, bindingType) {\n    let strictModeChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let allowLetBinding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !(bindingType & BIND_SCOPE_LEXICAL);\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === BIND_NONE) {\n        this.raise(Errors.StrictEvalArguments, {\n          at,\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name\n        });\n      }\n    }\n    if (!allowLetBinding && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, {\n        at\n      });\n    }\n    if (!(bindingType & BIND_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, {\n          at: node\n        });\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {\n      at: this.state.startLoc\n    });\n    return true;\n  }\n}\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, {\n          at: key\n        });\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, {\n            at: key\n          });\n        }\n      }\n      protoRef.used = true;\n    }\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(137)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(106)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc\n            });\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc\n          });\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(106)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc\n                });\n              }\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, {\n        at: startLoc\n      });\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument\n      });\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, {\n            at: node\n          });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, {\n            at: node\n          });\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {\n          at: startLoc\n        });\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\")\n      });\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node, \"UpdateExpression\")\n      });\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(136)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, {\n          at: startLoc\n        });\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, {\n        at: startLoc\n      });\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount: this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, {\n              at: arg\n            });\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (!this.match(10)) {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        return this.finishNode(node, \"Import\");\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 132:\n        return this.parseNumericLiteral(this.state.value);\n      case 133:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseDecimalLiteral(this.state.value);\n      case 131:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, {\n              at: callee\n            });\n          }\n        }\n      case 136:\n        {\n          this.raise(Errors.PrivateInExpectedIn, {\n            at: this.state.startLoc,\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          } else {\n            throw this.unexpected();\n          }\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n            break;\n          } else {\n            throw this.unexpected();\n          }\n        }\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      throw this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" : \"TopicReference\";\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {\n          at: startLoc\n        });\n      }\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, {\n          at: startLoc\n        });\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition()\n      });\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, {\n        at: node\n      });\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, {\n        at: node\n      });\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, {\n        at: node\n      });\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(102)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n    if (this.isContextual(100)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, {\n          at: id\n        });\n      }\n      this.sawUnambiguousESM = true;\n    }\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(Errors.UnexpectedNewTarget, {\n          at: metaProp\n        });\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    node.callee = this.parseNoCallExpr();\n    if (node.callee.type === \"Import\") {\n      this.raise(Errors.ImportCallNotNewExpression, {\n        at: node.callee\n      });\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.lastTokEndLoc\n      });\n    } else if (this.eat(18)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.startLoc\n      });\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)\n        });\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, {\n          at: prop\n        });\n      }\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc\n        });\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: method\n      });\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: method\n      });\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc\n          });\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 132:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 131:\n            key = this.parseStringLiteral(value);\n            break;\n          case 133:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 134:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case 136:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, {\n                  at: privateKeyLoc\n                });\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            throw this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 136) {\n        prop.computed = false;\n      }\n    }\n    return prop.key;\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type) {\n    let inClassScope = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type) {\n    let isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression) {\n    let isMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, {\n            at: (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node\n          });\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    let strictModeChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BIND_VAR,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc\n        });\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(130);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc\n        });\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError({\n        at: startLoc\n      });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, {\n          at: startLoc\n        });\n        return;\n      }\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word\n      });\n    }\n  }\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {\n      at: node\n    });\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, {\n        at: node\n      });\n    }\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 135 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {\n      at: node\n    });\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 137:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc\n        });\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, {\n        at: this.state.startLoc\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, {\n        at: startLoc\n      });\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: \"loop\"\n  },\n  switchLabel = {\n    kind: \"switch\"\n  };\nconst FUNC_NO_FLAGS = 0b000,\n  FUNC_STATEMENT = 0b001,\n  FUNC_HANGING_STATEMENT = 0b010,\n  FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 136) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(130),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program) {\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 137;\n    let sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.options.sourceType;\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, {\n          at,\n          localName\n        });\n      }\n    }\n    let finishedProgram;\n    if (end === 137) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet(context) {\n    if (!this.isContextual(99)) {\n      return false;\n    }\n    return this.hasFollowingIdentifier(context);\n  }\n  hasFollowingIdentifier(context) {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    if (nextCh === 92 || nextCh === 91) {\n      return true;\n    }\n    if (context) return false;\n    if (nextCh === 123) return true;\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  startsUsingForOf() {\n    const lookahead = this.lookahead();\n    if (lookahead.type === 101 && !lookahead.containsEsc) {\n      return false;\n    } else {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n  parseStatement(context, topLevel) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(context, topLevel, decorators);\n  }\n  parseStatementContent(context, topLevel, decorators) {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (context) {\n          if (this.state.strict) {\n            this.raise(Errors.StrictFunction, {\n              at: this.state.startLoc\n            });\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(Errors.SloppyFunction, {\n              at: this.state.startLoc\n            });\n          }\n        }\n        return this.parseFunctionStatement(node, false, !context);\n      case 80:\n        if (context) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 105:\n        if (this.hasFollowingLineBreak()) {\n          break;\n        }\n      case 99:\n        if (this.state.containsEsc || !this.hasFollowingIdentifier(context)) {\n          break;\n        }\n      case 75:\n      case 74:\n        {\n          const kind = this.state.value;\n          if (kind === \"using\") {\n            this.expectPlugin(\"explicitResourceManagement\");\n            if (!this.scope.inModule && this.scope.inTopLevel) {\n              this.raise(Errors.UnexpectedUsingDeclaration, {\n                at: this.state.startLoc\n              });\n            }\n          }\n          if (context && kind !== \"var\") {\n            this.raise(Errors.UnexpectedLexicalDeclaration, {\n              at: this.state.startLoc\n            });\n          }\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, {\n              at: this.state.startLoc\n            });\n          }\n          this.next();\n          let result;\n          if (starttype === 83) {\n            result = this.parseImport(node);\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node, decorators);\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n                at: this.state.startLoc\n              });\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, {\n        at: node\n      });\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && !!this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\");\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      classNode.decorators = maybeDecorators;\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, {\n          at: this.state.startLoc\n        });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {\n            at: paramsStartLoc\n          });\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(136)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, {\n        at: node,\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(99);\n    const startsWithUsing = this.isContextual(105) && !this.hasFollowingLineBreak();\n    const isLetOrUsing = startsWithLet && this.hasFollowingIdentifier() || startsWithUsing && this.hasFollowingIdentifier() && this.startsUsingForOf();\n    if (this.match(74) || this.match(75) || isLetOrUsing) {\n      const initNode = this.startNode();\n      const kind = this.state.value;\n      this.next();\n      this.parseVar(initNode, true, kind);\n      const init = this.finishNode(initNode, \"VariableDeclaration\");\n      const isForIn = this.match(58);\n      if (isForIn && startsWithUsing) {\n        this.raise(Errors.ForInUsing, {\n          at: init\n        });\n      }\n      if ((isForIn || this.isContextual(101)) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, init);\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(101);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, {\n          at: init\n        });\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, {\n          at: init\n        });\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(66) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, {\n        at: this.state.startLoc\n      });\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: BIND_LEXICAL,\n      allowingSloppyLetBinding: true\n    });\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, {\n        at: node\n      });\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind) {\n    let allowMissingInitializer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, {\n        at: this.state.startLoc\n      });\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? \"loop\" : this.match(71) ? \"switch\" : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock() {\n    let allowDirectives = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let createNewLexicalScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let afterBlockParse = arguments.length > 2 ? arguments[2] : undefined;\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind) {\n    let allowMissingInitializer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(101)))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(101))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\"\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" && id.type !== \"Identifier\") {\n      this.raise(Errors.UsingDeclarationHasBindingPattern, {\n        at: id\n      });\n    }\n    this.checkLVal(id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? BIND_VAR : BIND_LEXICAL\n    });\n    decl.id = id;\n  }\n  parseFunction(node) {\n    let statement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FUNC_NO_FLAGS;\n    let isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n    if (this.match(55) && isHangingStatement) {\n      this.raise(Errors.GeneratorInSingleStatementContext, {\n        at: this.state.startLoc\n      });\n    }\n    node.generator = this.eat(55);\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc\n            });\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, {\n            at: member\n          });\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(104);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(136);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key\n        });\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(136);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, {\n            at: key\n          });\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, {\n            at: key\n          });\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(136);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, {\n            at: publicMethod.key\n          });\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate = this.match(136);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, {\n            at: publicMethod.key\n          });\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(136);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 130 || type === 131) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, {\n        at: this.state.startLoc\n      });\n    }\n    if (type === 136) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc\n        });\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    return this.parsePropertyName(member);\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, {\n        at: member\n      });\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, {\n        at: prop.key\n      });\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, {\n          at: key\n        });\n      }\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId) {\n    let bindingType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BIND_CLASS;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, {\n          at: this.state.startLoc\n        });\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, 5);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      this.checkExport(node2, true, true);\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    throw this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n    if (this.match(68) || isAsync) {\n      this.next();\n      if (isAsync) {\n        this.next();\n      }\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(Errors.DecoratorBeforeExport, {\n          at: this.state.startLoc\n        });\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc\n      });\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatement(null);\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 99) {\n        return false;\n      }\n      if ((type === 128 || type === 127) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(97)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n      if (assertions) {\n        node.assertions = assertions;\n        this.checkJSONModuleImport(node);\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          throw this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc\n          });\n        }\n        return true;\n      }\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration\n            });\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, {\n          at: node\n        });\n      } else {\n        this.raise(Errors.DuplicateExport, {\n          at: node,\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(128);\n      const isString = this.match(131);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(131)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(_ref89 => {\n        let {\n          key,\n          value\n        } = _ref89;\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    if (node.module) {\n      var _node$assertions;\n      if (node.specifiers.length !== 1 || node.specifiers[0].type !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, {\n          at: node.specifiers[0].loc.start\n        });\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, {\n          at: node.specifiers[0].loc.start\n        });\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start\n          });\n        }\n      }\n    }\n  }\n  parseMaybeImportReflection(node) {\n    let isImportReflection = false;\n    if (this.isContextual(125)) {\n      const lookahead = this.lookahead();\n      if (tokenIsIdentifier(lookahead.type)) {\n        if (lookahead.type !== 97) {\n          isImportReflection = true;\n        } else {\n          const nextNextTokenFirstChar = this.input.charCodeAt(this.nextTokenStartSince(lookahead.end));\n          if (nextNextTokenFirstChar === 102) {\n            isImportReflection = true;\n          }\n        }\n      } else {\n        isImportReflection = true;\n      }\n    }\n    if (isImportReflection) {\n      this.expectPlugin(\"importReflection\");\n      this.next();\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n  }\n  parseImport(node) {\n    node.specifiers = [];\n    if (!this.match(131)) {\n      this.parseMaybeImportReflection(node);\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(12);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(97);\n    }\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n      const attributes = this.maybeParseModuleAttributes();\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(131)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  shouldParseDefaultImport(node) {\n    return tokenIsIdentifier(this.state.type);\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type) {\n    let bindingType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BIND_LEXICAL;\n    this.checkLVal(specifier.local, {\n      in: specifier,\n      binding: bindingType\n    });\n    return this.finishNode(specifier, type);\n  }\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(131)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(131)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseModuleAttributes() {\n    if (this.match(76) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key\n        });\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(131)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAssertions() {\n    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n    this.eat(5);\n    const attrs = this.parseAssertEntries();\n    this.eat(8);\n    return attrs;\n  }\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc\n          });\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(131);\n      const isMaybeTypeOnly = this.isContextual(128);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n}\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n  return new cls(options, input);\n}\nconst parserClassCache = {};\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","keys","key","i","length","indexOf","Position","constructor","line","col","index","column","SourceLocation","start","end","filename","identifierName","createPositionWithColumnOffset","position","columnOffset","ParseErrorCode","SyntaxError","SourceTypeModuleError","reflect","last","get","reduce","object","set","item","instantiate","properties","descriptors","map","filter","descriptor","enumerable","assign","split","instance","configurable","ModuleErrors","ImportMetaOutsideModule","message","code","ImportOutsideModule","NodeDescriptions","ArrayPattern","AssignmentExpression","AssignmentPattern","ArrowFunctionExpression","ConditionalExpression","CatchClause","ForOfStatement","ForInStatement","ForStatement","FormalParameters","Identifier","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","ObjectPattern","ParenthesizedExpression","RestElement","UpdateExpression","true","false","VariableDeclarator","YieldExpression","toNodeDescription","type","prefix","String","StandardErrors","AccessorIsGenerator","kind","ArgumentsInClass","AsyncFunctionInSingleStatementContext","AwaitBindingIdentifier","AwaitBindingIdentifierInStaticBlock","AwaitExpressionFormalParameter","AwaitNotInAsyncContext","AwaitNotInAsyncFunction","BadGetterArity","BadSetterArity","BadSetterRestParameter","ConstructorClassField","ConstructorClassPrivateField","ConstructorIsAccessor","ConstructorIsAsync","ConstructorIsGenerator","DeclarationMissingInitializer","DecoratorArgumentsOutsideParentheses","DecoratorBeforeExport","DecoratorConstructor","DecoratorExportClass","DecoratorSemicolon","DecoratorStaticBlock","DeletePrivateField","DestructureNamedImport","DuplicateConstructor","DuplicateDefaultExport","DuplicateExport","exportName","DuplicateProto","DuplicateRegExpFlags","ElementAfterRest","EscapedCharNotAnIdentifier","ExportBindingIsString","localName","ExportDefaultFromAsIdentifier","ForInOfLoopInitializer","ForInUsing","ForOfAsync","ForOfLet","GeneratorInSingleStatementContext","IllegalBreakContinue","IllegalLanguageModeDirective","IllegalReturn","ImportBindingIsString","importName","ImportCallArgumentTrailingComma","ImportCallArity","maxArgumentCount","ImportCallNotNewExpression","ImportCallSpreadArgument","ImportJSONBindingNotDefault","ImportReflectionHasAssertion","ImportReflectionNotBinding","IncompatibleRegExpUVFlags","InvalidBigIntLiteral","InvalidCodePoint","InvalidCoverInitializedName","InvalidDecimal","InvalidDigit","radix","InvalidEscapeSequence","InvalidEscapeSequenceTemplate","InvalidEscapedReservedWord","reservedWord","InvalidIdentifier","InvalidLhs","ancestor","InvalidLhsBinding","InvalidNumber","InvalidOrMissingExponent","InvalidOrUnexpectedToken","unexpected","InvalidParenthesizedAssignment","InvalidPrivateFieldResolution","InvalidPropertyBindingPattern","InvalidRecordProperty","InvalidRestAssignmentPattern","LabelRedeclaration","labelName","LetInLexicalBinding","LineTerminatorBeforeArrow","MalformedRegExpFlags","MissingClassName","MissingEqInAssignment","MissingSemicolon","MissingPlugin","missingPlugin","name","JSON","stringify","join","MissingOneOfPlugins","MissingUnicodeEscape","MixingCoalesceWithLogical","ModuleAttributeDifferentFromType","ModuleAttributeInvalidValue","ModuleAttributesWithDuplicateKeys","ModuleExportNameHasLoneSurrogate","surrogateCharCode","toString","ModuleExportUndefined","MultipleDefaultsInSwitch","NewlineAfterThrow","NoCatchOrFinally","NumberIdentifier","NumericSeparatorInEscapeSequence","ObsoleteAwaitStar","OptionalChainingNoNew","OptionalChainingNoTemplate","OverrideOnConstructor","ParamDupe","PatternHasAccessor","PatternHasMethod","PrivateInExpectedIn","PrivateNameRedeclaration","RecordExpressionBarIncorrectEndSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","RecordExpressionHashIncorrectStartSyntaxType","RecordNoProto","RestTrailingComma","SloppyFunction","StaticPrototype","SuperNotAllowed","SuperPrivateField","TrailingDecorator","TupleExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","UnexpectedArgumentPlaceholder","UnexpectedAwaitAfterPipelineBody","UnexpectedDigitAfterHash","UnexpectedImportExport","UnexpectedKeyword","keyword","UnexpectedLeadingDecorator","UnexpectedLexicalDeclaration","UnexpectedNewTarget","UnexpectedNumericSeparator","UnexpectedPrivateField","UnexpectedReservedWord","UnexpectedSuper","UnexpectedToken","expected","UnexpectedTokenUnaryExponentiation","UnexpectedUsingDeclaration","UnsupportedBind","UnsupportedDecoratorExport","UnsupportedDefaultExport","UnsupportedImport","UnsupportedMetaProperty","onlyValidPropertyName","UnsupportedParameterDecorator","UnsupportedPropertyDecorator","UnsupportedSuper","UnterminatedComment","UnterminatedRegExp","UnterminatedString","UnterminatedTemplate","UsingDeclarationHasBindingPattern","VarRedeclaration","YieldBindingIdentifier","YieldInParameter","ZeroDigitNumericSeparator","StrictModeErrors","StrictDelete","StrictEvalArguments","referenceName","StrictEvalArgumentsBinding","bindingName","StrictFunction","StrictNumericEscape","StrictOctalLiteral","StrictWith","UnparenthesizedPipeBodyDescriptions","Set","PipelineOperatorErrors","PipeBodyIsTighter","PipeTopicRequiresHackPipes","PipeTopicUnbound","PipeTopicUnconfiguredToken","token","PipeTopicUnused","PipeUnparenthesizedBody","PipelineBodyNoArrow","PipelineBodySequenceExpression","PipelineHeadSequenceExpression","PipelineTopicUnused","PrimaryTopicNotAllowed","PrimaryTopicRequiresSmartPipeline","_excluded$1","_excluded2$1","toParseErrorConstructor","_ref","toMessage","loc","details","clone","overrides","pos","ParseErrorEnum","argument","syntaxPlugin","Array","isArray","parseErrorTemplates","ParseErrorConstructors","reasonCode","template","_ref2","rest","Errors","toUnenumerable","toESTreeLocation","node","estree","superClass","ESTreeParserMixin","parse","file","options","tokens","parseRegExpLiteral","pattern","flags","regex","RegExp","e","estreeParseLiteral","parseBigIntLiteral","bigInt","BigInt","_unused","bigint","parseDecimalLiteral","decimal","parseLiteral","parseStringLiteral","parseNumericLiteral","parseNullLiteral","parseBooleanLiteral","directiveToStmt","directive","expression","raw","extra","expressionValue","stmt","rawValue","initFunction","isAsync","checkDeclaration","isObjectProperty","getObjectOrClassMethodParams","method","params","isValidDirective","_stmt$expression$extr","parenthesized","parseBlockBody","allowDirectives","topLevel","afterBlockParse","directiveStatements","directives","d","body","concat","pushClassMethod","classBody","isGenerator","isConstructor","allowsDirectSuper","parseMethod","typeParameters","push","parsePrivateName","getPluginOption","convertPrivateNameToPrivateIdentifier","getPrivateNameSV","id","isPrivateName","parseFunctionBody","allowExpression","isMethod","allowDirectSuper","inClassScope","funcNode","startNode","computed","finishNode","parseClassProperty","propertyNode","parseClassPrivateProperty","parseObjectMethod","prop","isPattern","isAccessor","shorthand","parseObjectProperty","startLoc","refExpressionErrors","isValidLVal","isUnparenthesizedInAssign","binding","isAssignable","isBinding","toAssignable","isLHS","classScope","usePrivateName","toAssignableObjectExpressionProp","isLast","raise","at","finishCallExpression","unfinished","optional","callee","arguments","hasPlugin","_node$arguments$","attributes","toReferencedArguments","parseExport","decorators","exportStartLoc","state","lastTokStartLoc","exported","specifiers","_declaration$decorato","declaration","resetStartLocation","parseSubscript","base","noCalls","optionalChainMember","substring","stop","chain","startNodeAtNode","hasPropertyAsPrivateName","isOptionalChain","isObjectMethod","finishNodeAt","endLoc","resetEndLocation","lastTokEndLoc","TokContext","preserveSpace","types","brace","j_oTag","j_cTag","j_expr","beforeExpr","startsExpr","isLoop","isAssign","postfix","ExportedTokenType","label","conf","rightAssociative","binop","updateContext","keywords$1","Map","createKeyword","createToken","createBinop","tokenTypeCounter","tokenTypes","tokenLabels","tokenBinops","tokenBeforeExprs","tokenStartsExprs","tokenPrefixes","_options$binop","_options$beforeExpr","_options$startsExpr","_options$prefix","createKeywordLike","_options$binop2","_options$beforeExpr2","_options$startsExpr2","_options$prefix2","tt","bracketL","bracketHashL","bracketBarL","bracketR","bracketBarR","braceL","braceBarL","braceHashL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","ellipsis","backQuote","dollarBraceL","templateTail","templateNonTail","hash","interpreterDirective","eq","slashAssign","xorAssign","moduloAssign","incDec","bang","tilde","doubleCaret","doubleAt","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","lt","gt","relational","bitShift","bitShiftL","bitShiftR","plusMin","modulo","star","slash","exponent","_in","_instanceof","_break","_case","_catch","_continue","_debugger","_default","_else","_finally","_function","_if","_return","_switch","_throw","_try","_var","_const","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_typeof","_void","_delete","_do","_for","_while","_as","_assert","_async","_await","_from","_get","_let","_meta","_of","_sent","_set","_static","_using","_yield","_asserts","_checks","_exports","_global","_implements","_intrinsic","_infer","_is","_mixins","_proto","_require","_satisfies","_keyof","_readonly","_unique","_abstract","_declare","_enum","_module","_namespace","_interface","_type","_opaque","string","num","regexp","privateName","eof","jsxName","jsxText","jsxTagStart","jsxTagEnd","placeholder","tokenIsIdentifier","tokenKeywordOrIdentifierIsKeyword","tokenIsKeywordOrIdentifier","tokenIsLiteralPropertyName","tokenComesBeforeExpression","tokenCanStartExpression","tokenIsAssignment","tokenIsFlowInterfaceOrTypeOrOpaque","tokenIsLoop","tokenIsKeyword","tokenIsOperator","tokenIsPostfix","tokenIsPrefix","tokenIsTSTypeOperator","tokenIsTSDeclarationStart","tokenLabelName","tokenOperatorPrecedence","tokenIsRightAssociative","tokenIsTemplate","getExportedToken","context","pop","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","isIdentifierStart","test","fromCharCode","isIdentifierChar","reservedWords","strict","strictBind","keywords","reservedWordsStrictSet","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindOnlyReservedWord","isStrictBindReservedWord","isKeyword","isIteratorStart","current","next","next2","reservedWordLikeSet","canBeReservedWord","SCOPE_OTHER","SCOPE_PROGRAM","SCOPE_FUNCTION","SCOPE_ARROW","SCOPE_SIMPLE_CATCH","SCOPE_SUPER","SCOPE_DIRECT_SUPER","SCOPE_CLASS","SCOPE_STATIC_BLOCK","SCOPE_TS_MODULE","SCOPE_VAR","BIND_KIND_VALUE","BIND_KIND_TYPE","BIND_SCOPE_VAR","BIND_SCOPE_LEXICAL","BIND_SCOPE_FUNCTION","BIND_FLAGS_NONE","BIND_FLAGS_CLASS","BIND_FLAGS_TS_ENUM","BIND_FLAGS_TS_CONST_ENUM","BIND_FLAGS_TS_EXPORT_ONLY","BIND_FLAGS_FLOW_DECLARE_FN","BIND_FLAGS_TS_IMPORT","BIND_CLASS","BIND_LEXICAL","BIND_VAR","BIND_FUNCTION","BIND_TS_INTERFACE","BIND_TS_TYPE","BIND_TS_ENUM","BIND_TS_AMBIENT","BIND_NONE","BIND_OUTSIDE","BIND_TS_CONST_ENUM","BIND_TS_NAMESPACE","BIND_TS_TYPE_IMPORT","BIND_FLOW_DECLARE_FN","CLASS_ELEMENT_FLAG_STATIC","CLASS_ELEMENT_KIND_GETTER","CLASS_ELEMENT_KIND_SETTER","CLASS_ELEMENT_KIND_ACCESSOR","CLASS_ELEMENT_STATIC_GETTER","CLASS_ELEMENT_STATIC_SETTER","CLASS_ELEMENT_INSTANCE_GETTER","CLASS_ELEMENT_INSTANCE_SETTER","CLASS_ELEMENT_OTHER","Scope","var","lexical","functions","ScopeHandler","parser","scopeStack","undefinedExports","inTopLevel","currentScope","inFunction","currentVarScopeFlags","allowSuper","currentThisScopeFlags","inClass","inClassAndNotInNonArrowFunction","inStaticBlock","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","createScope","enter","exit","scope","declareName","bindingType","checkRedeclarationInScope","add","maybeExportDefined","delete","isRedeclaredInScope","values","checkLocalExport","topLevelScope","FlowScope","declareFunctions","FlowScopeHandler","BaseParser","sawUnambiguousESM","ambiguousScriptDifferentAst","pluginConfig","plugins","pluginName","pluginOptions","actualOptions","plugin","_this$plugins$get","setTrailingComments","comments","trailingComments","undefined","unshift","setLeadingComments","leadingComments","setInnerComments","innerComments","adjustInnerComments","elements","commentWS","lastElement","CommentsParser","addComment","comment","processComment","commentStack","commentStackLength","lastCommentWS","leadingNode","nodeStart","commentEnd","containingNode","finalizeComment","splice","trailingNode","commentStart","input","charCodeAt","finalizeRemainingComments","resetPreviousNodeTrailingComments","takeSurroundingComments","lineBreak","lineBreakG","isNewLine","skipWhiteSpace","skipWhiteSpaceInLine","skipWhiteSpaceToLineBreak","isWhitespace","State","curLine","lineStart","errors","potentialArrowAt","noArrowAt","noArrowParamsConversionAt","maybeInArrowParameters","inType","noAnonFunctionType","hasFlowComment","isAmbientContext","inAbstractClass","inDisallowConditionalTypesContext","topicContext","maxNumOfResolvableTopics","maxTopicIndex","soloAwait","inFSharpPipelineDirectBody","labels","lastTokStart","canStartJSXElement","containsEsc","firstInvalidTemplateEscapePos","strictErrors","tokensLength","init","strictMode","sourceType","startLine","startColumn","curPosition","skipArrays","val","slice","_isDigit","isDigit","forbiddenNumericSeparatorSiblings","decBinOct","hex","isAllowedNumericSeparatorSibling","bin","ch","oct","dec","readStringContents","initialPos","initialLineStart","initialCurLine","out","firstInvalidLoc","chunkStart","unterminated","isStringEnd","res","readEscapedChar","str","containsInvalid","inTemplate","throwOnInvalid","readHexChar","readCodePoint","fromCodePoint","strictNumericEscape","startPos","match","octalStr","octal","parseInt","len","forceLen","n","readInt","invalidEscapeSequence","allowNumSeparator","bailOnError","forbiddenSiblings","isAllowedSibling","invalid","total","Infinity","prev","numericSeparatorInEscapeSequence","Number","isNaN","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","_excluded","_excluded2","buildPosition","VALID_REGEX_FLAGS","Token","Tokenizer","isLookahead","errorHandlers_readInt","errorRecovery","errorBuilder","errorHandlers_readCodePoint","errorHandlers_readStringContents_string","recordStrictModeErrors","errorHandlers_readStringContents_template","pushToken","checkKeywordEscapes","nextToken","eat","createLookaheadState","curContext","lookahead","old","curr","nextTokenStart","nextTokenStartSince","lastIndex","lookaheadCharCode","codePointAtPos","cp","trail","setStrict","forEach","toParseError","clear","skipSpace","finishToken","getTokenFromCode","skipBlockComment","skipLineComment","startSkip","spaceStart","loop","attachComment","commentWhitespace","prevType","replaceToken","readToken_numberSign","readToken_interpreter","nextPos","expectPlugin","readWord1","finishOp","readToken_dot","readNumber","readToken_slash","readToken_mult_modulo","width","readToken_pipe_amp","readToken_caret","proposal","topicToken","lookaheadCh","codePointAt","readToken_atSign","readToken_plus_min","readToken_lt","readToken_gt","size","readToken_eq_excl","readToken_question","readTemplateToken","readRadixNumber","readString","readWord","readRegexp","escaped","content","mods","char","includes","isBigInt","replace","startsWithDot","isFloat","isDecimal","hasExponent","isOctal","hasLeadingZero","integer","underscorePos","parseFloat","quote","readTemplateContinuation","opening","firstCode","escStart","identifierCheck","esc","raiseProperties","error","raiseOverwrite","expectOnePlugin","pluginNames","some","ClassScope","privateNames","loneAccessors","undefinedPrivateNames","ClassScopeHandler","stack","oldClassScope","from","declarePrivateName","elementType","redefined","accessor","oldStatic","newStatic","oldKind","newKind","kExpression","kMaybeArrowParameterDeclaration","kMaybeAsyncArrowParameterDeclaration","kParameterDeclaration","ExpressionScope","canBeArrowParameterDeclaration","isCertainlyParameterDeclaration","ArrowHeadParsingScope","declarationErrors","recordDeclarationError","ParsingErrorClass","clearDeclarationError","iterateErrors","iterator","ExpressionScopeHandler","recordParameterInitializerError","origin","recordArrowParemeterBindingError","recordAsyncArrowParametersError","validateAsPattern","newParameterDeclarationScope","newArrowHeadScope","newAsyncArrowScope","newExpressionScope","PARAM","PARAM_YIELD","PARAM_AWAIT","PARAM_RETURN","PARAM_IN","ProductionParameterHandler","stacks","currentFlags","hasAwait","hasYield","hasReturn","hasIn","functionFlags","UtilParser","addExtra","isContextual","isUnparsedContextual","nameStart","nameEnd","nextCh","isLookaheadContextual","eatContextual","expectContextual","canInsertSemicolon","hasPrecedingLineBreak","hasFollowingLineBreak","isLineTerminator","semicolon","allowAsi","expect","tryParse","fn","oldState","abortSignal","failState","thrown","aborted","checkExpressionErrors","andThrow","shorthandAssignLoc","doubleProtoLoc","privateKeyLoc","optionalParametersLoc","hasErrors","isLiteralPropertyName","property","initializeScopes","oldLabels","oldExportedIdentifiers","exportedIdentifiers","oldInModule","oldScope","getScopeHandler","oldProdParam","prodParam","oldExpressionScope","expressionScope","enterInitialScopes","paramFlags","checkDestructuringPrivate","ExpressionErrors","Node","ranges","range","NodePrototype","prototype","__clone","newNode","clonePlaceholder","cloneIdentifier","cloned","create","expectedNode","cloneStringLiteral","NodeUtils","startNodeAt","resetStartLocationFromNode","locationNode","reservedTypes","FlowErrors","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","reservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","memberName","enumName","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","invalidEnumType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","explicitType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","suggestion","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","GetterMayNotHaveThisParam","ImportReflectionHasImportType","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","PatternIsOptional","SetterMayNotHaveThisParam","SpreadVariance","ThisParamAnnotationRequired","ThisParamBannedInConstructor","ThisParamMayNotBeOptional","ThisParamMustBeFirst","ThisParamNoDefault","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","unsupportedExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","isEsModuleType","bodyElement","hasTypeImportKind","importKind","isMaybeDefaultImport","exportSuggestions","const","let","interface","partition","list","list1","list2","FLOW_PRAGMA_REGEX","flow","FlowParserMixin","flowPragma","shouldParseTypes","shouldParseEnums","matches","exec","Error","flowParseTypeInitialiser","tok","oldInType","flowParseType","flowParsePredicate","moduloLoc","parseExpression","flowParseTypeAndPredicateInitialiser","predicate","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","parseIdentifier","typeNode","typeContainer","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","this","returnType","typeAnnotation","flowParseDeclare","insideModule","flowParseDeclareVariable","flowParseDeclareModuleExports","flowParseDeclareModule","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","parseExprAtom","bodyNode","parseImport","hasModuleExport","default","isLet","exportKind","flowParseTypeAnnotation","finished","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","checkReservedType","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStartLoc","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","oldNoAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","flowParseObjectTypeInternalSlot","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","callProperties","indexers","internalSlots","endDelim","exact","inexact","protoStartLoc","inexactStartLoc","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","isInexactToken","proto","flowCheckGetterSetterParams","paramCount","_startLoc","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","first","lh","isThis","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","parseLiteralAtNode","createIdentifier","flowParsePostfixType","seenOptionalIndexedAccess","objectType","indexType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatement","flowParseEnumDeclaration","parseExpressionStatement","expr","shouldParseExportDeclaration","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","setOptionalParametersError","originalNoArrowAt","consequent","failed","tryParseConditionalConsequent","valid","getArrowLikeExpressions","alternate","parseMaybeAssign","parseMaybeAssignAllowIn","disallowInvalid","arrows","finishArrowValidation","every","_node$extra","toAssignableList","trailingCommaLoc","checkParams","result","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","parseClassMember","member","parseClassMemberFromModifier","isIterator","readIterator","fullWord","left","exprList","toReferencedList","isParenthesizedExpr","_expr$extra","parseArrayLike","close","canBePattern","isTuple","isParenthesized","isClassMethod","isClassProperty","isNonstaticConstructor","isThisParam","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","checkGetterSetterParams","parsePropertyNamePrefixOperator","parseObjPropValue","parseAssignableListItemTypes","parseMaybeDefault","shouldParseDefaultImport","checkImportReflection","module","parseImportSpecifierLocal","specifier","local","finishImportSpecifier","maybeParseDefaultImportSpecifier","parseImportSpecifier","importedIsString","isInTypeOnlyImport","isMaybeTypeOnly","firstIdent","imported","specifierTypeKind","as_ident","specifierIsTypeImport","checkReservedWord","parseBindingAtom","parseFunctionParams","allowModifiers","parseVarId","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","_jsx","jsx","currentContext","_jsx2","_jsx3","abort","_arrowExpression$extr","arrowExpression","maybeUnwrapTypeCastExpression","async","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","strictModeChanged","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","subscriptState","isLookaheadToken_lt","typeArguments","parseNewCallee","targs","parseArrowExpression","parseTopLevel","program","fileNode","skipFlowComment","hasFlowCommentCompletion","commentSkip","shiftToFirstNonWhiteSpace","ch2","ch3","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorInvalidMemberInitializer","enumContext","flowEnumErrorNumberMemberNotInitialized","flowEnumErrorStringMemberInconsistentlyInitailized","flowEnumMemberInit","endOfInit","literal","flowEnumMemberRaw","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","hasUnknownMembers","memberNode","toUpperCase","flowEnumStringMembers","initializedMembers","flowEnumParseExplicitType","flowEnumBody","nameLoc","empty","boolsLen","numsLen","strsLen","defaultedLen","afterNext","entities","__proto__","quot","amp","apos","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","JsxErrors","AttributeIsEmpty","MissingClosingTagElement","openingTagName","MissingClosingTagFragment","UnexpectedSequenceExpression","HTMLEntity","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","isFragment","getQualifiedJSXName","namespace","JSXParserMixin","jsxReadToken","jsxReadEntity","jsxReadNewLine","normalizeCRLF","jsxReadString","codePoint","count","desc","entity","jsxReadWord","jsxParseIdentifier","jsxParseNamespacedName","jsxParseElementName","jsxParseAttributeValue","setContext","jsxParseExpressionContainer","jsxParseEmptyExpression","jsxParseSpreadChild","previousContext","jsxParseAttribute","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","openingFragment","closingFragment","jsxParseElement","newContext","TypeScriptScope","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","importsStack","hasImport","allowShadow","isConst","wasConst","getOwn$1","hasOwnProperty","nonNull","x","assert","TSErrors","AbstractMethodHasImplementation","methodName","AbstractPropertyHasInitializer","propertyName","AccesorCannotDeclareThisParameter","AccesorCannotHaveTypeParameters","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference","ConstructorHasTypeParameters","DeclareAccessor","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateAccessibilityModifier","modifier","DuplicateModifier","EmptyHeritageClauseType","EmptyTypeArguments","EmptyTypeParameters","ExpectedAmbientAfterExportDeclare","ImportAliasHasImportType","IncompatibleModifiers","modifiers","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasDeclare","IndexSignatureHasOverride","IndexSignatureHasStatic","InitializerNotAllowedInAmbientContext","InvalidModifierOnTypeMember","InvalidModifierOnTypeParameter","InvalidModifierOnTypeParameterPositions","InvalidModifiersOrder","orderedModifiers","InvalidPropertyAccessAfterInstantiationExpression","InvalidTupleMemberLabel","MissingInterfaceName","MixedLabeledAndUnlabeledElements","NonAbstractClassHasAbstractMethod","NonClassMethodPropertyHasAbstractModifer","OptionalTypeBeforeRequired","OverrideNotInSubClass","PrivateElementHasAbstract","PrivateElementHasAccessibility","ReadonlyForMethodSignature","ReservedArrowTypeParam","ReservedTypeAssertion","SetAccesorCannotHaveOptionalParameter","SetAccesorCannotHaveRestParameter","SetAccesorCannotHaveReturnType","SingleTypeParameterWithoutTrailingComma","typeParameterName","StaticBlockCannotHaveModifier","TypeAnnotationAfterAssign","TypeImportCannotSpecifyDefaultAndNamed","TypeModifierIsUsedInTypeExports","TypeModifierIsUsedInTypeImports","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","keywordTypeFromName","tsIsAccessModifier","tsIsVarianceAnnotations","typescript","TypeScriptParserMixin","tsIsIdentifier","tsTokenCanFollowModifier","tsNextTokenCanFollowModifier","tsParseModifier","allowedModifiers","stopOnStartOfClassStaticBlock","tsIsStartOfStaticBlocks","tsTryParse","bind","tsParseModifiers","modified","disallowedModifiers","errorTemplate","enforceOrder","before","after","incompatible","mod1","mod2","accessibility","tsIsListTerminator","tsParseList","parseElement","tsParseDelimitedList","refTrailingCommaPos","tsParseDelimitedListWorker","expectSuccess","trailingCommaPos","element","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","tsParseTypeAnnotation","asserts","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseInOutModifiers","tsParseNoneModifiers","tsParseTypeParameter","parseModifiers","tsParseTypeParameterName","constraint","tsEatThenParseType","tsTryParseTypeParameters","tsParseTypeParameters","tsFillSignature","returnToken","signature","returnTokenRequired","paramsKey","returnTypeKey","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsParseTypeMemberSemicolon","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","parameters","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","nodeAny","firstParameter","tsParseTypeMember","idx","parsePropertyName","tsParseTypeLiteral","tsParseObjectTypeMembers","tsIsStartOfMappedType","tsParseMappedTypeParameter","tsExpectThenParseType","tsParseMappedType","nameType","tsParseType","tsTryParseType","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","labeledElements","elementNode","_labeledElements","checkType","isLabeled","labeled","labeledNode","optionalTypeNode","restNode","tsParseParenthesizedType","tsParseFunctionOrConstructorType","abstract","tsInAllowConditionalTypesContext","tsParseLiteralTypeNode","tsParseTemplateLiteralType","parseTemplate","parseTemplateSubstitution","tsParseThisTypeOrThisTypePredicate","thisKeyword","tsParseNonArrayType","parseMaybeUnary","nodeType","tsParseArrayTypeOrHigher","tsParseTypeOperator","operator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","tsParseConstraintForInferType","tsInDisallowConditionalTypesContext","isTypeOperator","tsParseUnionOrIntersectionType","parseConstituentType","hasLeadingOperator","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","previousErrorCount","parseObjectLike","_unused2","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","eatColon","tsParseNonConditionalType","extendsType","trueType","falseType","isAbstractConstructorSignature","tsParseTypeAssertion","tsParseHeritageClause","originalStartLoc","delimitedList","tsParseInterfaceDeclaration","checkIdentifier","tsParseTypeAliasDeclaration","tsInNoContext","cb","oldContext","oldInDisallowConditionalTypesContext","tsNextThenParseType","tsDoThenParseType","tsParseEnumMember","initializer","tsParseEnumDeclaration","tsParseModuleBlock","parseBlockOrModuleBlockBody","tsParseModuleOrNamespaceDeclaration","nested","inner","tsParseAmbientExternalModuleDeclaration","global","tsParseImportEqualsDeclaration","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","tsTryParseAndCatch","tsTryParseDeclare","nany","starttype","tsInAmbientContext","parseFunctionStatement","parseClass","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","mod","tsCheckLineTerminator","tsParseAbstractDeclaration","tsTryParseGenericAsyncArrowFunction","oldMaybeInArrowParameters","tsParseTypeArgumentsInExpression","reScan_lt","tsIsDeclarationStart","parseAssignableListItem","override","elt","pp","parameter","isSimpleParameter","bodilessType","registerFunctionStatementId","tsCheckForInvalidTypeCasts","items","isInParens","nonNullExpression","isOptionalCall","missingParenErrorLoc","atPossibleAsyncArrow","asyncArrowFn","parseTaggedTemplateExpression","tokenType","_callee$extra","parseExprOp","leftStartLoc","minPrec","isSatisfies","reScan_lt_gt","checkKeywords","checkDuplicateExports","ahead","importNode","isAbstractClass","cls","allowMissingInitializer","declarations","expressions","isPossiblyLiteralEnum","parseStatementContent","parseAccessModifier","tsHasSomeModifiers","callParseClassMemberWithIsStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","hadSuperClass","parsePostMemberNameModifiers","methodOrProp","isDeclare","isIdentifier","parseClassPropertyAnnotation","definite","declareClassPrivateMethodInScope","_typeCast","_typeCast2","_jsx4","_typeCast3","typeCast","_typeParameters","reportReservedArrowTypeParam","trailingComma","sawUnary","toAssignableParenthesizedExpression","checkToRestConversion","allowPattern","TSTypeCastExpression","TSParameterProperty","TSNonNullExpression","TSAsExpression","TSSatisfiesExpression","TSTypeAssertion","parseMaybeDecoratorArguments","checkCommaAfterRest","canHaveLeadingDecorator","getGetterSetterExpectedParamCount","baseCount","firstParam","hasContextParam","parseCatchClauseParam","oldIsAmbientContext","oldInAbstractClass","maybeTakeDecorators","hasBody","shouldParseAsAmbientContext","getExpression","parseExportSpecifier","isString","isInTypeExport","parseTypeOnlyImportExportSpecifier","isImport","isInTypeOnlyImportExport","leftOfAsKey","rightOfAsKey","leftOfAs","rightOfAs","hasTypeSpecifier","canParseAsKeyword","firstAs","secondAs","parseModuleExportName","kindKey","isUncomputedMemberExpressionChain","PlaceholderErrors","ClassNameIsRequired","UnexpectedSpace","placeholders","PlaceholdersParserMixin","parsePlaceholder","assertNoSpace","finishPlaceholder","isFinished","hasFollowingIdentifier","verifyBreakContinue","isBreak","parseBlock","createNewLexicalScope","parseFunctionId","requireId","oldStrict","parseClassBody","startsWith","maybeParseExportDefaultSpecifier","checkExport","hasStarImport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","v8intrinsic","V8IntrinsicMixin","parseV8Intrinsic","v8IntrinsicStartLoc","parseIdentifierName","identifier","expectedConfig","expectedName","expectedOptions","expectedKeys","expectedOptionsIsEmpty","p","option","find","PIPELINE_PROPOSALS","TOPIC_TOKENS","RECORD_AND_TUPLE_SYNTAX_TYPES","validatePlugins","decoratorsBeforeExport","allowCallParenthesized","proposalList","tupleSyntaxIsHash","syntaxType","tokenList","moduleAttributesVersionPluginOption","missingPlugins","mixinPlugins","mixinPluginNames","defaultOptions","sourceFilename","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","allowUndeclaredExports","createParenthesizedExpressions","getOptions","opts","getOwn","unwrapParenthesizedExpression","LValParser","_node$extra3","_node$extra2","arg","toReferencedListDeep","parseSpread","parseRestBinding","closeCharCode","allowEmpty","elts","parseDecorator","parseBindingRestProperty","parseBindingProperty","_left","ObjectProperty","checkLVal","in","checkClashes","allowingSloppyLetBinding","hasParenthesizedAncestor","_expression$extra","validity","ParseErrorClass","isParenthesizedExpression","nextAncestor","child","allowLetBinding","declareNameFromIdentifier","ExpressionParser","checkProto","isRecord","protoRef","used","shouldExitDescending","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","parseMaybeAssignDisallowIn","resultError","_resultError$loc","parseYield","ownExpressionErrors","parseMaybeConditional","startIndex","parseExprOps","parseMaybeUnaryOrPrivate","op","prec","checkPipelineAtInfixOperator","logical","coalesce","parseExprOpRightExpr","finishedNode","nextOp","withTopicBindingContext","parseHackPipeBody","parseSmartPipelineBodyInStyle","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","_body$extra","requiredParentheses","topicReferenceWasUsedInCurrentContext","checkExponentialAfterUnary","isAwait","isAwaitAllowed","parseAwait","update","isDelete","parseUpdate","isAmbiguousAwait","updateExpressionNode","parseExprSubscripts","maybeAsyncArrow","parseBind","parseCoverCallAndAsyncArrowHead","parseMember","parseNoCallExpr","tag","quasi","dynamicImport","allowPlaceholder","nodeForExtra","oldInFSharpPipelineDirectBody","addTrailingCommaExtraToNode","parseExprListItem","_call$extra","parseSuper","parseImportMetaProperty","parseDo","parseFunctionOrFunctionSent","parseDecorators","parseNewOrNewTarget","parseTopicReferenceThenEqualsSign","parseTopicReference","pipeProposal","parseModuleExpression","parseFunction","parseAsyncArrowUnaryFunction","topicTokenType","topicTokenValue","finishTopicReference","testTopicReferenceConfiguration","topicReferenceIsAllowedInCurrentContext","registerTopicReference","meta","parseMetaProperty","innerStartLoc","spreadStartLoc","optionalCommaStartLoc","spreadNodeStartLoc","innerEndLoc","arrowNode","wrapParenthesis","parenExpression","metaProp","parseNew","args","parseExprList","parseTemplateElement","isTagged","elemStart","elem","isTail","endOffset","elemEnd","cooked","tail","curElt","quasis","propHash","parsePropertyDefinition","maybeAsyncOrAccessorProp","keyName","_params","finishedProp","generator","isExpression","hasStrictModeDirective","nonSimple","isSimpleParamList","formalParameters","reservedTest","delegating","delegate","childExpr","isSimpleReference","checkSmartPipeTopicBodyEarlyErrors","callback","outerContextTopicState","withSmartMixTopicForbiddingContext","outerContextSoloAwaitState","prodParamToSet","prodParamToClear","ret","revertScopes","parseProgram","loopLabel","switchLabel","FUNC_NO_FLAGS","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","loneSurrogate","keywordRelationalOperator","babel7CompatTokens","hashEndPos","hashEndLoc","backquoteEnd","backquoteEndLoc","startToken","templateValue","templateElementEnd","templateElementEndLoc","endToken","StatementParser","interpreter","parseInterpreterDirective","finishedProgram","stmtToDirective","directiveLiteral","endCh","startsUsingForOf","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","nextTokenCharCode","isAsyncFunction","maybeName","parseLabeledStatement","decoratorsEnabledBeforeExport","maybeDecorators","classNode","exportNode","allowExport","paramsStartLoc","lab","parseHeaderExpression","awaitAt","parseFor","startsWithLet","startsWithUsing","isLetOrUsing","initNode","parseVar","isForIn","parseForIn","startsWithAsync","isForOf","declarationPosition","discriminant","cases","cur","sawDefault","isCase","simple","block","handler","clause","finalizer","statementStart","parsedNonDirective","await","isFor","statement","isHangingStatement","hadConstructor","publicMethod","privateMethod","publicProp","privateProp","accessorProp","publicMember","parseClassElementName","isPrivate","maybeQuestionTokenStartLoc","pushClassPrivateProperty","pushClassProperty","pushClassAccessorProperty","_member$decorators","parseClassAccessorProperty","parseInitializer","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","_node2$declaration","isTypeExport","assertions","nextType","hasFrom","nextAfterFrom","maybeParseImportAssertions","checkJSONModuleImport","checkNames","isDefault","isFrom","_declaration$extra","nodes","surrogate","isJSONModuleImport","_node$assertions","nonDefaultNamedSpecifier","parseMaybeImportReflection","isImportReflection","nextNextTokenFirstChar","parseNext","maybeParseModuleAttributes","parseAssertEntries","attrs","attrNames","importSpecifier","Parser","pluginsMap","pluginMap","_options","getParser","ast","moduleError","generateExportedTokenTypes","internalTokenTypes","tokTypes","getParserClass","parserClassCache","pluginsFromOptions","pluginList"],"sources":["/home/mgerasika/Documents/git/oddbox/oddbox-frontend-npm-usage-example/node_modules/@babel/parser/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\n\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\n\nvar ParseErrorCode = {\n  SyntaxError: \"BABEL_PARSER_SYNTAX_ERROR\",\n  SourceTypeModuleError: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n};\nconst reflect = (keys, last = keys.length - 1) => ({\n  get() {\n    return keys.reduce((object, key) =>\n    object[key], this);\n  },\n  set(value) {\n    keys.reduce(\n    (item, key, i) => i === last ? item[key] = value : item[key], this);\n  }\n});\nconst instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map(key => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === \"function\" ? {\n  value: descriptor,\n  enumerable: false\n} : typeof descriptor.reflect === \"string\" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split(\".\"))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({\n  configurable: true\n}, descriptor)), Object.assign(new constructor(), properties));\n\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code: ParseErrorCode.SourceTypeModuleError\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code: ParseErrorCode.SourceTypeModuleError\n  }\n};\n\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = ({\n  type,\n  prefix\n}) => type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];\n\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accesor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accesor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accesor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({\n    maxArgumentCount\n  }) => `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script`.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\n\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\n\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`,\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n};\n\nconst _excluded$1 = [\"toMessage\"],\n  _excluded2$1 = [\"message\"];\nfunction toParseErrorConstructor(_ref) {\n  let {\n      toMessage\n    } = _ref,\n    properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n  return function constructor({\n    loc,\n    details\n  }) {\n    return instantiate(SyntaxError, Object.assign({}, properties, {\n      loc\n    }), {\n      clone(overrides = {}) {\n        const loc = overrides.loc || {};\n        return constructor({\n          loc: new Position(\"line\" in loc ? loc.line : this.loc.line, \"column\" in loc ? loc.column : this.loc.column, \"index\" in loc ? loc.index : this.loc.index),\n          details: Object.assign({}, this.details, overrides.details)\n        });\n      },\n      details: {\n        value: details,\n        enumerable: false\n      },\n      message: {\n        get() {\n          return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;\n        },\n        set(value) {\n          Object.defineProperty(this, \"message\", {\n            value\n          });\n        }\n      },\n      pos: {\n        reflect: \"loc.index\",\n        enumerable: true\n      },\n      missingPlugin: \"missingPlugin\" in details && {\n        reflect: \"details.missingPlugin\",\n        enumerable: true\n      }\n    });\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref2 = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref2,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: ParseErrorCode.SyntaxError,\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\n\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = (superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {\n    }\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = \"Literal\";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = \"ExpressionStatement\";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n    classBody.body.push(method);\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(\n    funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    return this.finishNode(\n    node, \"MethodDefinition\");\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, {\n        at: prop.key\n      });\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      if (this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$;\n        node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n      }\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node\n  ) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 &&\n        node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 &&\n          declaration.start === node.start) {\n            this.resetStartLocation(node,\n            exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n    return node;\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n});\n\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n\n{\n  types.template = new TokContext(\"`\", true);\n}\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\n\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\n\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 130;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 130;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 134;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 127 && token <= 129;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 119 && token <= 121;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 122 && token <= 128;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[140].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\n\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\n\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\n\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\",\n\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\",\n\"eval\", \"arguments\",\n\"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\n\nconst SCOPE_OTHER = 0b000000000,\n  SCOPE_PROGRAM = 0b000000001,\n  SCOPE_FUNCTION = 0b000000010,\n  SCOPE_ARROW = 0b000000100,\n  SCOPE_SIMPLE_CATCH = 0b000001000,\n  SCOPE_SUPER = 0b000010000,\n  SCOPE_DIRECT_SUPER = 0b000100000,\n  SCOPE_CLASS = 0b001000000,\n  SCOPE_STATIC_BLOCK = 0b010000000,\n  SCOPE_TS_MODULE = 0b100000000,\n  SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_STATIC_BLOCK | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n  BIND_KIND_TYPE = 0b000000000010,\n  BIND_SCOPE_VAR = 0b000000000100,\n  BIND_SCOPE_LEXICAL = 0b000000001000,\n  BIND_SCOPE_FUNCTION = 0b000000010000,\n  BIND_FLAGS_NONE = 0b0000001000000,\n  BIND_FLAGS_CLASS = 0b0000010000000,\n  BIND_FLAGS_TS_ENUM = 0b0000100000000,\n  BIND_FLAGS_TS_CONST_ENUM = 0b0001000000000,\n  BIND_FLAGS_TS_EXPORT_ONLY = 0b0010000000000,\n  BIND_FLAGS_FLOW_DECLARE_FN = 0b0100000000000,\n  BIND_FLAGS_TS_IMPORT = 0b1000000000000;\n\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n  BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n  BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n  BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n  BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n  BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n  BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n  BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n  BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n  BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n  BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n  BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n  BIND_TS_TYPE_IMPORT = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_TS_IMPORT,\n  BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n  CLASS_ELEMENT_KIND_GETTER = 0b010,\n  CLASS_ELEMENT_KIND_SETTER = 0b001,\n  CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\n\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n  CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n  CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n  CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n  CLASS_ELEMENT_OTHER = 0;\n\nclass Scope {\n\n  constructor(flags) {\n    this.var = new Set();\n    this.lexical = new Set();\n    this.functions = new Set();\n    this.flags = flags;\n  }\n}\n\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & SCOPE_PROGRAM) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & SCOPE_STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);\n    }\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);\n    }\n    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) &&\n    !topLevelScope.functions.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & SCOPE_VAR) {\n        return flags;\n      }\n    }\n  }\n\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {\n        return flags;\n      }\n    }\n  }\n}\n\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\n\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\n\nconst skipWhiteSpaceToLineBreak = new RegExp(\n\"(?=(\" +\nskipWhiteSpaceInLine.source + \"))\\\\1\" +\n/(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\n\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.hasFlowComment = false;\n    this.isAmbientContext = false;\n    this.inAbstractClass = false;\n    this.inDisallowConditionalTypesContext = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.comments = [];\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 137;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.context = [types.brace];\n    this.canStartJSXElement = true;\n    this.containsEsc = false;\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  init({\n    strictMode,\n    sourceType,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n    return state;\n  }\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\n\nconst _excluded = [\"at\"],\n  _excluded2 = [\"at\"];\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\n\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\n\nclass Tokenizer extends CommentsParser {\n\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery) return false;\n        this.raise(Errors.InvalidDigit, {\n          at: buildPosition(pos, lineStart, curLine),\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n          at: buildPosition(pos, lineStart, curLine)\n        });\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, {\n          at: buildPosition(pos - 1, lineStart, curLine)\n        });\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, {\n          at: buildPosition(pos, lineStart, curLine)\n        });\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {\n        at\n      }));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(137);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    if (this.isLookahead) return;\n\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + commentEnd.length,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition()\n      });\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {\n          at: this.state.curPosition()\n        });\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(136, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(136, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    }\n    else if (next === 94 &&\n    this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        throw this.unexpected();\n      }\n    }\n    else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    }\n    else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () =>\n    createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          this.expectPlugin(\"regexpUnicodeSets\", nextPos());\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, {\n            at: nextPos()\n          });\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, {\n          at: nextPos()\n        });\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(135, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, {\n        at: startLoc\n      });\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(133, str);\n      return;\n    }\n    this.finishToken(132, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, {\n        at: this.state.curPosition()\n      });\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {\n        at: startLoc\n      });\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos)\n          });\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, {\n          at: startLoc\n        });\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, {\n          at: startLoc\n        });\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, {\n          at: startLoc\n        });\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(133, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(134, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(132, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1,\n    this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(131, str);\n  }\n\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1,\n    this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, {\n    at\n  }) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, {\n        at\n      });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition()\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, {\n              at: escStart\n            });\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(130, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n\n  raise(toParseError, raiseProperties) {\n    const {\n        at\n      } = raiseProperties,\n      details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError({\n      loc,\n      details\n    });\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n\n  raiseOverwrite(toParseError, raiseProperties) {\n    const {\n        at\n      } = raiseProperties,\n      details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError({\n          loc,\n          details\n        });\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, raiseProperties);\n  }\n\n  updateContext(prevType) {}\n\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, {\n        at: buildPosition(pos, lineStart, curLine)\n      });\n    };\n  }\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n\n    const current = this.current();\n\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n          at: loc,\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n}\n\nconst kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3;\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, {\n    at\n  }) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(toParseError, {\n    at: node\n  }) {\n    const origin = {\n      at: node.loc.start\n    };\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n\n  recordArrowParemeterBindingError(error, {\n    at: node\n  }) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = {\n      at: node.loc.start\n    };\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError({\n    at\n  }) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {\n          at\n        });\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, {\n        at: loc\n      });\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nconst\n  PARAM = 0b0000,\n  PARAM_YIELD = 0b0001,\n  PARAM_AWAIT = 0b0010,\n  PARAM_RETURN = 0b0100,\n  PARAM_IN = 0b1000;\n\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nclass UtilParser extends Tokenizer {\n\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) ||\n      (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, {\n          at: this.state.startLoc\n        });\n      }\n      throw this.unexpected(null, token);\n    }\n  }\n\n  canInsertSemicolon() {\n    return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, {\n      at: this.state.lastTokEndLoc\n    });\n  }\n\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc\n      });\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, {\n        at: doubleProtoLoc\n      });\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, {\n        at: privateKeyLoc\n      });\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\n\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\n\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitailized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nfunction isMaybeDefaultImport(type) {\n  return tokenIsKeywordOrIdentifier(type) && type !== 97;\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\nvar flow = (superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n  finishToken(type, val) {\n    if (type !== 131 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    return super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    return super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(108);\n    if (this.state.lastTokStart > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n        at: moduloLoc\n      });\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(125)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(128)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(127)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n    if (this.match(131)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(128) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(123, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n      body.push(bodyNode);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n            at: bodyElement\n          });\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n          at: this.state.startLoc,\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) ||\n      this.match(68) ||\n      this.match(80) ||\n      this.isContextual(129)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) ||\n      this.match(5) ||\n      this.isContextual(127) ||\n      this.isContextual(128) ||\n      this.isContextual(129)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n    throw this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(109);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (this.isContextual(115)) {\n      this.next();\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    if (this.isContextual(111)) {\n      this.next();\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n        at: this.state.startLoc\n      });\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {\n      at: startLoc,\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(128);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, {\n          at: nodeStartLoc\n        });\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.match(47) || this.match(140)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(127);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(116)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(104)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(98) || this.isContextual(103)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n          at: inexactStartLoc\n        });\n      }\n    }\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, {\n            at: this.state.lastTokStartLoc\n          });\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, {\n            at: variance\n          });\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, {\n          at: this.state.lastTokStartLoc\n        });\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, {\n          at: variance\n        });\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, {\n            at: node.value.this\n          });\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {\n        at: property.value.this\n      });\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: property\n      });\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: property\n      });\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    var _startLoc;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node\n        });\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n            at: node\n          });\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 10:\n        this.next();\n\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      case 131:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(132)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(133)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n            at: this.state.startLoc\n          });\n        }\n        throw this.unexpected();\n      case 132:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 133:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(127)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    throw this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(\n          node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(\n          node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 130 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation,\n      node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.isContextual(127)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(124)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatement(context, topLevel);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 124) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(124)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 ||\n      nextCh === 61 ||\n      nextCh === 58 ||\n      nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, {\n          at: state.startLoc\n        });\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(\n    node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return node;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExport(node, decorators) {\n    const decl = super.parseExport(node, decorators);\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n    return decl;\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(128)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(127)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(124)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(128) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(123)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, {\n          at: startLoc\n        });\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, {\n          at: member.value\n        });\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, {\n        at: this.state.curPosition(),\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(130, fullWord);\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      return this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        return this.finishOp(18, 2);\n      }\n      return this.finishOp(17, 1);\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      return this.readIterator();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, {\n          at: expr.typeAnnotation\n        });\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    } else if (\n    method.type === \"MethodDefinition\" && isConstructor &&\n    method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    if (this.isContextual(111)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, {\n          at: param\n        });\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, {\n          at: param\n        });\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n          at: param\n        });\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, {\n        at: param\n      });\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, {\n        at: param\n      });\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, {\n        at: node.typeAnnotation\n      });\n    }\n    return node;\n  }\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n    return isMaybeDefaultImport(this.state.type);\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, {\n        at: node.specifiers[0].loc.start\n      });\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n    if (this.match(87)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(128)) {\n      kind = \"type\";\n    }\n    if (kind) {\n      const lh = this.lookahead();\n      const {\n        type\n      } = lh;\n\n      if (kind === \"type\" && type === 55) {\n        this.unexpected(null, lh.type);\n      }\n      if (isMaybeDefaultImport(type) || type === 5 || type === 55) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport,\n  isMaybeTypeOnly,\n  bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, {\n            at: specifier,\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n        at: specifier\n      });\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(140) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n\n      if (!jsx.error) return jsx.node;\n\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node &&\n      this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {\n              at: typeParameters\n            });\n          }\n          return arrow.node;\n        }\n\n        arrowExpression = arrow.node;\n      }\n\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n        at: typeParameters\n      });\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation,\n        node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n\n      if (result.error) this.state = result.failState;\n\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node.params[i]\n        });\n      }\n    }\n    return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startLoc.index) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, {\n        at: this.state.curPosition()\n      });\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, {\n          at: this.state.startLoc\n        });\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(\n    this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n      at: loc,\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({\n      at: loc\n    }, enumContext));\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n      at: loc,\n      enumName,\n      memberName\n    });\n  }\n  flowEnumErrorStringMemberInconsistentlyInitailized(node, {\n    enumName\n  }) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {\n      at: node,\n      enumName\n    });\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 132:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 131:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, {\n          at: id,\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, {\n          at: id,\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(101)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n        at: this.state.startLoc,\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, {\n        at: this.state.startLoc,\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n});\n\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = (superClass => class JSXParserMixin extends superClass {\n\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, {\n          at: this.state.startLoc\n        });\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              return this.finishToken(140);\n            }\n            return super.getTokenFromCode(ch);\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(139, out);\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, {\n          at: this.state.startLoc\n        });\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(131, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n\n    this.state.pos = startPos;\n    return \"&\";\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    return this.finishToken(138, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(138)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, {\n            at: node\n          });\n        }\n        return node;\n      case 140:\n      case 131:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, {\n          at: this.state.startLoc\n        });\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(141)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(141)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(141);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(141)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(141);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 140:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 139:\n            children.push(this.parseExprAtom());\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            throw this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, {\n          at: closingElement\n        });\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, {\n          at: closingElement,\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n        at: this.state.startLoc\n      });\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(139)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(140)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(140);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      return this.jsxReadToken();\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(141);\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(140);\n    }\n    return super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 140) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 140) {\n      context.push(types.j_oTag);\n    } else if (type === 141) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n});\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = new Set();\n    this.enums = new Set();\n    this.constEnums = new Set();\n    this.classes = new Set();\n    this.exportOnlyBindings = new Set();\n  }\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags == SCOPE_TS_MODULE) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags == SCOPE_TS_MODULE) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & BIND_FLAGS_TS_IMPORT) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, {\n          at: loc,\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      scope.types.add(name);\n    }\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.has(name)) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      if (scope.types.has(name) || scope.exportOnlyBindings.has(name)) return;\n    }\n    super.checkLocalExport(id);\n  }\n}\n\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier:\n  ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = (superClass => class TypeScriptParserMixin extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n\n  tsParseModifiers({\n    modified,\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, {\n          at: loc,\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, {\n          at: loc,\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, {\n          at: startLoc,\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n    throw new Error(\"Unreachable\");\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStart;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(131)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.argument = super.parseExprAtom();\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseInOutModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n\n  tsParseNoneModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n  }\n  tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(140)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\",\n    this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, {\n        at: node\n      });\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    return super.parseBindingList(11, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n          at: pattern,\n          type: pattern.type\n        });\n      }\n      return pattern;\n    });\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, {\n          at: node\n        });\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n          at: this.state.curPosition()\n        });\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, {\n            at: this.state.curPosition()\n          });\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, {\n            at: this.state.curPosition()\n          });\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n              at: this.state.curPosition()\n            });\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n            at: method[returnTypeKey]\n          });\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    });\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(120);\n    }\n    if (this.isContextual(120)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(120);\n    } else if (this.eatContextual(120)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, {\n          at: elementNode\n        });\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n\n      let checkType = type;\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        checkType = elementNode.type;\n      }\n      const isLabeled = checkType === \"TSNamedTupleMember\";\n      (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;\n      if (labeledElements !== isLabeled) {\n        this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {\n          at: elementNode\n        });\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n\n    const {\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let type = this.tsParseType();\n    const optional = this.eat(17);\n    const labeled = this.eat(14);\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(TSErrors.InvalidTupleMemberLabel, {\n          at: type\n        });\n        labeledNode.label = type;\n      }\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    node.literal = (() => {\n      switch (this.state.type) {\n        case 132:\n        case 133:\n        case 131:\n        case 85:\n        case 86:\n          return super.parseExprAtom();\n        default:\n          throw this.unexpected();\n      }\n    })();\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 131:\n      case 132:\n      case 133:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 132 && nextToken.type !== 133) {\n            throw this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    throw this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(\n      node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, {\n          at: node\n        });\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(113);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;\n  }\n  tsTryParseTypeAnnotation() {\n    return this.match(14) ? this.tsParseTypeAnnotation() : undefined;\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(114) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 107) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.lastTokStartLoc,\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(122) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, {\n        at: this.state.startLoc\n      });\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, {\n        at: originalStartLoc,\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(127);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BIND_TS_INTERFACE);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, {\n        at: this.state.startLoc\n      });\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_TS_TYPE);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n      this.expect(29);\n      if (this.isContextual(112) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(124);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, BIND_TS_NAMESPACE);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(110)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(131)) {\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_FLAGS_TS_IMPORT);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, {\n        at: moduleReference\n      });\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(117) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(117);\n    this.expect(10);\n    if (!this.match(131)) {\n      throw this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort =>\n    f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let starttype = this.state.type;\n    let kind;\n    if (this.isContextual(99)) {\n      starttype = 74;\n      kind = \"let\";\n    }\n\n    return this.tsInAmbientContext(() => {\n      if (starttype === 68) {\n        nany.declare = true;\n        return super.parseFunctionStatement(nany, false, true);\n      }\n      if (starttype === 80) {\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n      }\n      if (starttype === 124) {\n        return this.tsParseEnumDeclaration(nany, {\n          declare: true\n        });\n      }\n      if (starttype === 110) {\n        return this.tsParseAmbientExternalModuleDeclaration(nany);\n      }\n      if (starttype === 75 || starttype === 74) {\n        if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n          nany.declare = true;\n          return this.parseVarStatement(nany, kind || this.state.value, true);\n        }\n\n        this.expect(75);\n        return this.tsParseEnumDeclaration(nany, {\n          const: true,\n          declare: true\n        });\n      }\n      if (starttype === 127) {\n        const result = this.tsParseInterfaceDeclaration(nany, {\n          declare: true\n        });\n        if (result) return result;\n      }\n      if (tokenIsIdentifier(starttype)) {\n        return this.tsParseDeclaration(nany, this.state.value, true, null);\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n          break;\n        }\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(131)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) {\n      return undefined;\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) {\n      return undefined;\n    }\n    return super.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) {\n      return undefined;\n    }\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() =>\n    this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, {\n        at: node\n      });\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n    let override = false;\n    if (allowModifiers !== undefined) {\n      const modified = {};\n      this.tsParseModifiers({\n        modified,\n        allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n      });\n      accessibility = modified.accessibility;\n      override = modified.override;\n      readonly = modified.readonly;\n      if (allowModifiers === false && (accessibility || readonly || override)) {\n        this.raise(TSErrors.UnexpectedParameterModifier, {\n          at: startLoc\n        });\n      }\n    }\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, {\n          at: pp\n        });\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, {\n        at: node\n      });\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, {\n          at: node.typeAnnotation\n        });\n      }\n    });\n  }\n  toReferencedList(exprList,\n  isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11, false);\n\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (\n        tokenType === 48 ||\n        tokenType === 52 ||\n        tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {\n            at: this.state.startLoc\n          });\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(118)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, {\n              at: this.state.startLoc,\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(\n      node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, {\n        at: node.specifiers[0].loc.start\n      });\n    }\n  }\n\n  checkDuplicateExports() {}\n  parseImport(node) {\n    node.importKind = \"value\";\n    if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {\n      let ahead = this.lookahead();\n      if (this.isContextual(128) &&\n      ahead.type !== 12 &&\n      ahead.type !== 97 &&\n      ahead.type !== 29) {\n        node.importKind = \"type\";\n        this.next();\n        ahead = this.lookahead();\n      }\n      if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n    }\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" &&\n    importNode.specifiers.length > 1 &&\n    importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n        at: importNode\n      });\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      this.next();\n      if (this.isContextual(128) && this.lookaheadCharCode() !== 61) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(126);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(128) && this.lookahead().type === 5) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(122) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n\n    if (this.match(127)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n          at: init\n        });\n      } else if (init.type !== \"StringLiteral\" && init.type !== \"BooleanLiteral\" && init.type !== \"NumericLiteral\" && init.type !== \"BigIntLiteral\" && (init.type !== \"TemplateLiteral\" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {\n          at: init\n        });\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(context, topLevel, decorators) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(124)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(127)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseStatementContent(context, topLevel, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(104) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      modified: member,\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n            at: this.state.curPosition()\n          });\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, {\n          at: member\n        });\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, {\n          at: member,\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, {\n          at: member\n        });\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, {\n          at: member\n        });\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n        at: member\n      });\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, {\n          at: member\n        });\n      }\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, {\n        at: methodOrProp\n      });\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, {\n        at: methodOrProp\n      });\n    }\n  }\n\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === \"Identifier\" ?\n    this.tsParseExpressionStatement(node, expr, decorators) : undefined;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n      return expr;\n    }\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startLoc) {\n    node = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(123)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(123);\n    if (isDeclare && (this.isContextual(123) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n        at: this.state.startLoc\n      });\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId,\n  bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(111)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(35)) {\n      node.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n        at: this.state.startLoc\n      });\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, {\n        at: this.state.startLoc,\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, {\n        at: node\n      });\n    }\n\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, {\n        at: node,\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, {\n        at: typeParameters\n      });\n    }\n\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, {\n        at: method,\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && !node.value.body) return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(111)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(140) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n\n      if (!jsx.error) return jsx.node;\n\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n    if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, {\n        at: node\n      });\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n    }\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\" && !this.state.isAmbientContext && !this.state.inType) {\n        this.raise(TSErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSSatisfiesExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    } else {\n      return super.checkCommaAfterRest(close);\n    }\n  }\n\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, {\n        at: node.typeAnnotation\n      });\n    }\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        return this.finishOp(48, 1);\n      }\n      if (code === 60) {\n        return this.finishOp(47, 1);\n      }\n    }\n    return super.getTokenFromCode(code);\n  }\n\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() =>\n      this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(127)) {\n\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n          at: node\n        });\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ?\n      !!method.value.body : !!method.body;\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, {\n          at: method,\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly,\n  bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {\n        at: loc\n      });\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? BIND_TS_TYPE_IMPORT : BIND_FLAGS_TS_IMPORT);\n    }\n  }\n});\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\") return false;\n  if (expression.computed) return false;\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\n\nvar placeholders = (superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(142)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(142);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(142, 2);\n    }\n    return super.getTokenFromCode(code);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n\n  hasFollowingIdentifier(context) {\n    if (super.hasFollowingIdentifier(context)) {\n      return true;\n    }\n    if (context) return false;\n\n    const nextToken = this.lookahead();\n    if (nextToken.type === 142) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(142) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n          at: this.state.startLoc\n        });\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(142), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(\n      node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(97);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n  }\n});\n\nvar v8intrinsic = (superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n});\n\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n      if (pluginName !== expectedName) {\n        return false;\n      }\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n  if (plugin && Array.isArray(plugin) && plugin.length > 1) {\n    return plugin[1][option];\n  }\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n    const allowCallParenthesized = getPluginOption(plugins, \"decorators\", \"allowCallParenthesized\");\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n      }\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n  if (hasPlugin(plugins, \"recordAndTuple\") && getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n}\n\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true\n};\n\nfunction getOptions(opts) {\n  const options = {};\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n  return options;\n}\n\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, {\n          at: node\n        });\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc\n            });\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, {\n            at: node.left.loc.end\n          });\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, {\n          at: prop\n        });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, {\n            at: elt\n          });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, {\n            at: trailingCommaLoc\n          });\n        }\n      }\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n\n  toReferencedList(exprList,\n  isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc\n          });\n        }\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n    return elts;\n  }\n\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 136) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startLoc, left) {\n    var _startLoc, _left;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type,\n  isUnparenthesizedInAssign,\n  binding) {\n    return getOwn({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    },\n    type);\n  }\n\n  checkLVal(expression, {\n    in: ancestor,\n    binding = BIND_NONE,\n    checkClashes = false,\n    strictModeChanged = false,\n    allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),\n    hasParenthesizedAncestor = false\n  }) {\n    var _expression$extra;\n    const type = expression.type;\n\n    if (this.isObjectMethod(expression)) return;\n    if (type === \"MemberExpression\") {\n      if (binding !== BIND_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, {\n          at: expression\n        });\n      }\n      return;\n    }\n    if (expression.type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, {\n            at: expression\n          });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, {\n        at: expression,\n        ancestor: ancestor.type === \"UpdateExpression\" ? {\n          type: \"UpdateExpression\",\n          prefix: ancestor.prefix\n        } : {\n          type: ancestor.type\n        }\n      });\n      return;\n    }\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = expression.type === \"ArrayPattern\" || expression.type === \"ObjectPattern\" || expression.type === \"ParenthesizedExpression\" ? expression : ancestor;\n\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          allowingSloppyLetBinding,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === BIND_NONE) {\n        this.raise(Errors.StrictEvalArguments, {\n          at,\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name\n        });\n      }\n    }\n    if (!allowLetBinding && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, {\n        at\n      });\n    }\n    if (!(bindingType & BIND_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, {\n          at: node\n        });\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {\n      at: this.state.startLoc\n    });\n    return true;\n  }\n}\n\nclass ExpressionParser extends LValParser {\n\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed ||\n    prop.shorthand) {\n      return;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, {\n          at: key\n        });\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, {\n            at: key\n          });\n        }\n      }\n      protoRef.used = true;\n    }\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(137)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(106)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc,\n  refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc\n            });\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc\n          });\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(106)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc\n                });\n              }\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(\n    body.type);\n\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, {\n        at: startLoc\n      });\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument\n      });\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, {\n            at: node\n          });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, {\n            at: node\n          });\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(\n    node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {\n          at: startLoc\n        });\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\")\n      });\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node, \"UpdateExpression\")\n      });\n    }\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(136)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, {\n          at: startLoc\n        });\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\",\n      node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, {\n        at: startLoc\n      });\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() &&\n    base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount: this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, {\n              at: arg\n            });\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (!this.match(10)) {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n        return this.finishNode(node, \"Import\");\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 132:\n        return this.parseNumericLiteral(this.state.value);\n      case 133:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseDecimalLiteral(this.state.value);\n      case 131:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, {\n              at: callee\n            });\n          }\n        }\n      case 136:\n        {\n          this.raise(Errors.PrivateInExpectedIn, {\n            at: this.state.startLoc,\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          } else {\n            throw this.unexpected();\n          }\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) ||\n          lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n            break;\n          } else {\n            throw this.unexpected();\n          }\n        }\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n    }\n  }\n\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n\n    this.next();\n\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" :\n      \"TopicReference\";\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(\n        pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed :\n        Errors.PipeTopicUnbound, {\n          at: startLoc\n        });\n      }\n\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, {\n          at: startLoc\n        });\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition()\n      });\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, {\n        at: node\n      });\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, {\n        at: node\n      });\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, {\n        at: node\n      });\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(\n    createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(102)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(100)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, {\n          at: id\n        });\n      }\n      this.sawUnambiguousESM = true;\n    }\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc,\n    val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node,\n  startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(Errors.UnexpectedNewTarget, {\n          at: metaProp\n        });\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    node.callee = this.parseNoCallExpr();\n    if (node.callee.type === \"Import\") {\n      this.raise(Errors.ImportCallNotNewExpression, {\n        at: node.callee\n      });\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.lastTokEndLoc\n      });\n    } else if (this.eat(18)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)\n        });\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(\n          node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, {\n          at: prop\n        });\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc\n        });\n      }\n\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: method\n      });\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: method\n      });\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop,\n      isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc\n          });\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 132:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 131:\n            key = this.parseStringLiteral(value);\n            break;\n          case 133:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 134:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case 136:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, {\n                  at: privateKeyLoc\n                });\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            throw this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 136) {\n        prop.computed = false;\n      }\n    }\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors,\n    node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false,\n      hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, {\n            at:\n            (node.kind === \"method\" || node.kind === \"constructor\") &&\n            !!node.key ?\n            node.key.loc.end : node\n          });\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates,\n  isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BIND_VAR,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc\n        });\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(130);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc\n        });\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError({\n        at: startLoc\n      });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, {\n          at: startLoc\n        });\n        return;\n      }\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word\n      });\n    }\n  }\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {\n      at: node\n    });\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, {\n        at: node\n      });\n    }\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return (\n      type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) ||\n      type === 135 || type === 56 ||\n      this.hasPlugin(\"v8intrinsic\") && type === 54\n    );\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {\n      at: node\n    });\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 137:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc\n        });\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, {\n        at: startLoc\n      });\n    }\n  }\n\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n\n  parsePropertyNamePrefixOperator(\n  prop) {}\n}\n\nconst loopLabel = {\n    kind: \"loop\"\n  },\n  switchLabel = {\n    kind: \"switch\"\n  };\nconst FUNC_NO_FLAGS = 0b000,\n  FUNC_STATEMENT = 0b001,\n  FUNC_HANGING_STATEMENT = 0b010,\n  FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      {\n        if (type === 136) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(130),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end = 137, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, {\n          at,\n          localName\n        });\n      }\n    }\n    let finishedProgram;\n    if (end === 137) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet(context) {\n    if (!this.isContextual(99)) {\n      return false;\n    }\n    return this.hasFollowingIdentifier(context);\n  }\n\n  hasFollowingIdentifier(context) {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    if (nextCh === 92 || nextCh === 91) {\n      return true;\n    }\n    if (context) return false;\n    if (nextCh === 123) return true;\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  startsUsingForOf() {\n    const lookahead = this.lookahead();\n    if (lookahead.type === 101 && !lookahead.containsEsc) {\n      return false;\n    } else {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n\n  parseStatement(context, topLevel) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(context, topLevel, decorators);\n  }\n  parseStatementContent(context, topLevel, decorators) {\n    const starttype = this.state.type;\n    const node = this.startNode();\n\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (context) {\n          if (this.state.strict) {\n            this.raise(Errors.StrictFunction, {\n              at: this.state.startLoc\n            });\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(Errors.SloppyFunction, {\n              at: this.state.startLoc\n            });\n          }\n        }\n        return this.parseFunctionStatement(node, false, !context);\n      case 80:\n        if (context) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 105:\n        if (this.hasFollowingLineBreak()) {\n          break;\n        }\n      case 99:\n        if (this.state.containsEsc || !this.hasFollowingIdentifier(context)) {\n          break;\n        }\n      case 75:\n      case 74:\n        {\n          const kind = this.state.value;\n          if (kind === \"using\") {\n            this.expectPlugin(\"explicitResourceManagement\");\n            if (!this.scope.inModule && this.scope.inTopLevel) {\n              this.raise(Errors.UnexpectedUsingDeclaration, {\n                at: this.state.startLoc\n              });\n            }\n          }\n          if (context && kind !== \"var\") {\n            this.raise(Errors.UnexpectedLexicalDeclaration, {\n              at: this.state.startLoc\n            });\n          }\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 ||\n          nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, {\n              at: this.state.startLoc\n            });\n          }\n          this.next();\n\n          let result;\n          if (starttype === 83) {\n            result = this.parseImport(node);\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node, decorators);\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n                at: this.state.startLoc\n              });\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName,\n      expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, {\n        at: node\n      });\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && !!this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\");\n  }\n\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      classNode.decorators = maybeDecorators;\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, {\n          at: this.state.startLoc\n        });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {\n            at: paramsStartLoc\n          });\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(136)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, {\n        at: node,\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    node.body =\n    this.withSmartMixTopicForbiddingContext(() =>\n    this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(99);\n    const startsWithUsing = this.isContextual(105) && !this.hasFollowingLineBreak();\n    const isLetOrUsing = startsWithLet && this.hasFollowingIdentifier() || startsWithUsing && this.hasFollowingIdentifier() && this.startsUsingForOf();\n    if (this.match(74) || this.match(75) || isLetOrUsing) {\n      const initNode = this.startNode();\n      const kind = this.state.value;\n      this.next();\n      this.parseVar(initNode, true, kind);\n      const init = this.finishNode(initNode, \"VariableDeclaration\");\n      const isForIn = this.match(58);\n      if (isForIn && startsWithUsing) {\n        this.raise(Errors.ForInUsing, {\n          at: init\n        });\n      }\n      if ((isForIn || this.isContextual(101)) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, init);\n    }\n\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(101);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, {\n          at: init\n        });\n      }\n      if (\n      awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, {\n          at: init\n        });\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node,\n      init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(66) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, {\n        at: this.state.startLoc\n      });\n    }\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: BIND_LEXICAL,\n      allowingSloppyLetBinding: true\n    });\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body =\n      this.withSmartMixTopicForbiddingContext(() =>\n      this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, {\n        at: node\n      });\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    node.body =\n    this.withSmartMixTopicForbiddingContext(() =>\n    this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, {\n        at: this.state.startLoc\n      });\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    node.body =\n    this.withSmartMixTopicForbiddingContext(() =>\n    this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? \"loop\" : this.match(71) ? \"switch\" : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr,\n  decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n\n    node.body =\n    this.withSmartMixTopicForbiddingContext(() =>\n    this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n\n    node.body =\n    this.withSmartMixTopicForbiddingContext(() =>\n    this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(101)))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(101))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\"\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" && id.type !== \"Identifier\") {\n      this.raise(Errors.UsingDeclarationHasBindingPattern, {\n        at: id\n      });\n    }\n    this.checkLVal(id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? BIND_VAR : BIND_LEXICAL\n    });\n    decl.id = id;\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n    if (this.match(55) && isHangingStatement) {\n      this.raise(Errors.GeneratorInSingleStatementContext, {\n        at: this.state.startLoc\n      });\n    }\n    node.generator = this.eat(55);\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" ||\n    method.key.value === \"constructor\");\n  }\n\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc\n            });\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (\n        member.kind === \"constructor\" &&\n        member.decorators &&\n        member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, {\n            at: member\n          });\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(104);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(136);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key\n        });\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(136);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, {\n            at: key\n          });\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, {\n            at: key\n          });\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(136);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, {\n            at: publicMethod.key\n          });\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate = this.match(136);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, {\n            at: publicMethod.key\n          });\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n\n      const isPrivate = this.match(136);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 130 || type === 131) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, {\n        at: this.state.startLoc\n      });\n    }\n    if (type === 136) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc\n        });\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    return this.parsePropertyName(member);\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, {\n        at: member\n      });\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, {\n        at: prop.key\n      });\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, {\n          at: key\n        });\n      }\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n\n  parsePostMemberNameModifiers(\n  methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, {\n          at: this.state.startLoc\n        });\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node, decorators) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(\n    node);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(\n    node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(\n    node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(\n    node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, 5);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, {\n          at: node\n        });\n      }\n      this.checkExport(node2, true, true);\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    throw this.unexpected(null, 5);\n  }\n\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n    if (this.match(68) || isAsync) {\n      this.next();\n      if (isAsync) {\n        this.next();\n      }\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(Errors.DecoratorBeforeExport, {\n          at: this.state.startLoc\n        });\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc\n      });\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(\n  node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatement(null);\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 99) {\n        return false;\n      }\n      if ((type === 128 || type === 127) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(97)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n      if (assertions) {\n        node.assertions = assertions;\n        this.checkJSONModuleImport(node);\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          throw this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc\n          });\n        }\n        return true;\n      }\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 &&\n          !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration\n            });\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, {\n          at: node\n        });\n      } else {\n        this.raise(Errors.DuplicateExport, {\n          at: node,\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(128);\n      const isString = this.match(131);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString,\n  isInTypeExport, isMaybeTypeOnly\n  ) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n\n  parseModuleExportName() {\n    if (this.match(131)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    if (node.module) {\n      var _node$assertions;\n      if (node.specifiers.length !== 1 || node.specifiers[0].type !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, {\n          at: node.specifiers[0].loc.start\n        });\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, {\n          at: node.specifiers[0].loc.start\n        });\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start\n          });\n        }\n      }\n    }\n  }\n  parseMaybeImportReflection(node) {\n    let isImportReflection = false;\n    if (this.isContextual(125)) {\n      const lookahead = this.lookahead();\n      if (tokenIsIdentifier(lookahead.type)) {\n        if (lookahead.type !== 97) {\n          isImportReflection = true;\n        } else {\n          const nextNextTokenFirstChar = this.input.charCodeAt(this.nextTokenStartSince(lookahead.end));\n          if (nextNextTokenFirstChar === 102) {\n            isImportReflection = true;\n          }\n        }\n      } else {\n        isImportReflection = true;\n      }\n    }\n    if (isImportReflection) {\n      this.expectPlugin(\"importReflection\");\n      this.next();\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n    if (!this.match(131)) {\n      this.parseMaybeImportReflection(node);\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(12);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(97);\n    }\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n      const attributes = this.maybeParseModuleAttributes();\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(131)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return tokenIsIdentifier(this.state.type);\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = BIND_LEXICAL) {\n    this.checkLVal(specifier.local, {\n      in: specifier,\n      binding: bindingType\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(131)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(131)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(76) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key\n        });\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(131)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAssertions() {\n    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n    this.eat(5);\n    const attrs = this.parseAssertEntries();\n    this.eat(8);\n    return attrs;\n  }\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc\n          });\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(131);\n      const isMaybeTypeOnly = this.isContextual(128);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  parseImportSpecifier(specifier, importedIsString,\n  isInTypeOnlyImport, isMaybeTypeOnly, bindingType\n  ) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n\nclass Parser extends StatementParser {\n\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n}\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n  return new cls(options, input);\n}\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n"],"mappings":"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AAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC;AAClhE,MAAMC,qBAAqB,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,E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"},"metadata":{},"sourceType":"script"}
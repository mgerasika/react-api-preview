{"ast":null,"code":"import { __asyncGenerator, __asyncValues, __await, __generator } from \"tslib\";\nexport function getUnmarshalledStream(source, options) {\n  var _a;\n  return _a = {}, _a[Symbol.asyncIterator] = function () {\n    return __asyncGenerator(this, arguments, function () {\n      var source_1, source_1_1, chunk, message, messageType, unmodeledError, code, exception, deserializedException, error, event, deserialized, e_1_1;\n      var _a, _b;\n      var e_1, _c;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            _d.trys.push([0, 12, 13, 18]);\n            source_1 = __asyncValues(source);\n            _d.label = 1;\n          case 1:\n            return [4 /*yield*/, __await(source_1.next())];\n          case 2:\n            if (!(source_1_1 = _d.sent(), !source_1_1.done)) return [3 /*break*/, 11];\n            chunk = source_1_1.value;\n            message = options.eventMarshaller.unmarshall(chunk);\n            messageType = message.headers[\":message-type\"].value;\n            if (!(messageType === \"error\")) return [3 /*break*/, 3];\n            unmodeledError = new Error(message.headers[\":error-message\"].value || \"UnknownError\");\n            unmodeledError.name = message.headers[\":error-code\"].value;\n            throw unmodeledError;\n          case 3:\n            if (!(messageType === \"exception\")) return [3 /*break*/, 5];\n            code = message.headers[\":exception-type\"].value;\n            exception = (_a = {}, _a[code] = message, _a);\n            return [4 /*yield*/, __await(options.deserializer(exception))];\n          case 4:\n            deserializedException = _d.sent();\n            if (deserializedException.$unknown) {\n              error = new Error(options.toUtf8(message.body));\n              error.name = code;\n              throw error;\n            }\n            throw deserializedException[code];\n          case 5:\n            if (!(messageType === \"event\")) return [3 /*break*/, 9];\n            event = (_b = {}, _b[message.headers[\":event-type\"].value] = message, _b);\n            return [4 /*yield*/, __await(options.deserializer(event))];\n          case 6:\n            deserialized = _d.sent();\n            if (deserialized.$unknown) return [3 /*break*/, 10];\n            return [4 /*yield*/, __await(deserialized)];\n          case 7:\n            return [4 /*yield*/, _d.sent()];\n          case 8:\n            _d.sent();\n            return [3 /*break*/, 10];\n          case 9:\n            throw Error(\"Unrecognizable event type: \" + message.headers[\":event-type\"].value);\n          case 10:\n            return [3 /*break*/, 1];\n          case 11:\n            return [3 /*break*/, 18];\n          case 12:\n            e_1_1 = _d.sent();\n            e_1 = {\n              error: e_1_1\n            };\n            return [3 /*break*/, 18];\n          case 13:\n            _d.trys.push([13,, 16, 17]);\n            if (!(source_1_1 && !source_1_1.done && (_c = source_1.return))) return [3 /*break*/, 15];\n            return [4 /*yield*/, __await(_c.call(source_1))];\n          case 14:\n            _d.sent();\n            _d.label = 15;\n          case 15:\n            return [3 /*break*/, 17];\n          case 16:\n            if (e_1) throw e_1.error;\n            return [7 /*endfinally*/];\n          case 17:\n            return [7 /*endfinally*/];\n          case 18:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, _a;\n}","map":{"version":3,"sources":["../../src/getUnmarshalledStream.ts"],"names":[],"mappings":";AASA,OAAM,SAAU,qBAAqB,CACnC,MAAiC,EACjC,OAAqC,EAAA;;EAErC,OAAA,EAAA,GAAA,CAAA,CAAA,EACE,EAAA,CAAC,MAAM,CAAC,aAAa,CAAA,GAAG,YAAA;;;;;;;;;YACI,QAAA,GAAA,aAAA,CAAA,MAAM,CAAA;;;;;;YAAf,KAAK,GAAA,UAAA,CAAA,KAAA;YACd,OAAO,GAAG,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,KAAK,CAAC;YAC1C,WAAW,GAAK,OAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAA,KAArC;gBACtB,EAAA,WAAW,KAAK,OAAO,CAAA,EAAvB,OAAA,CAAA,CAAA,CAAA,WAAA,CAAA,CAAA;YAEI,cAAc,GAAG,IAAI,KAAK,CAAE,OAAO,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,KAAgB,IAAI,cAAc,CAAC;YACvG,cAAc,CAAC,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,KAAe;YACpE,MAAM,cAAc;;gBACX,EAAA,WAAW,KAAK,WAAW,CAAA,EAA3B,OAAA,CAAA,CAAA,CAAA,WAAA,CAAA,CAAA;YAEH,IAAI,GAAG,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC,KAAe;YACzD,SAAS,IAAA,EAAA,GAAA,CAAA,CAAA,EAAK,EAAA,CAAC,IAAI,CAAA,GAAG,OAAO,EAAA,EAAA,CAAE;YAEP,OAAA,CAAA,CAAA,CAAA,WAAA,OAAA,CAAM,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,CAAA,CAAA;;YAA7D,qBAAqB,GAAG,EAAA,CAAA,IAAA,EAAqC;YACnE,IAAI,qBAAqB,CAAC,QAAQ,EAAE;cAE5B,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;cACrD,KAAK,CAAC,IAAI,GAAG,IAAI;cACjB,MAAM,KAAK;YACZ;YACD,MAAM,qBAAqB,CAAC,IAAI,CAAC;;gBACxB,EAAA,WAAW,KAAK,OAAO,CAAA,EAAvB,OAAA,CAAA,CAAA,CAAA,WAAA,CAAA,CAAA;YACH,KAAK,IAAA,EAAA,GAAA,CAAA,CAAA,EACT,EAAA,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,KAAe,CAAA,GAAG,OAAO,E,GAC1D;YACoB,OAAA,CAAA,CAAA,CAAA,WAAA,OAAA,CAAM,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA,CAAA;;YAAhD,YAAY,GAAG,EAAA,CAAA,IAAA,EAAiC;YACtD,IAAI,YAAY,CAAC,QAAQ,EAAE,OAAA,CAAA,CAAA,CAAA,WAAA,EAAA,CAAA;yCACrB,YAAY,CAAA,CAAA;;YAAlB,OAAA,CAAA,CAAA,CAAA,WAAA,EAAA,CAAA,IAAA,EAAA,CAAA;;YAAA,EAAA,CAAA,IAAA,EAAkB;;;YAElB,MAAM,KAAK,CAAC,6BAAA,GAA8B,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,KAAO,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAGtF,E,EACD;AACJ","sourcesContent":["import { EventStreamMarshaller as EventMarshaller } from \"@aws-sdk/eventstream-marshaller\";\nimport { Encoder, Message } from \"@aws-sdk/types\";\n\nexport type UnmarshalledStreamOptions<T> = {\n  eventMarshaller: EventMarshaller;\n  deserializer: (input: { [name: string]: Message }) => Promise<T>;\n  toUtf8: Encoder;\n};\n\nexport function getUnmarshalledStream<T extends { [key: string]: any }>(\n  source: AsyncIterable<Uint8Array>,\n  options: UnmarshalledStreamOptions<T>\n): AsyncIterable<T> {\n  return {\n    [Symbol.asyncIterator]: async function* () {\n      for await (const chunk of source) {\n        const message = options.eventMarshaller.unmarshall(chunk);\n        const { value: messageType } = message.headers[\":message-type\"];\n        if (messageType === \"error\") {\n          // Unmodeled exception in event\n          const unmodeledError = new Error((message.headers[\":error-message\"].value as string) || \"UnknownError\");\n          unmodeledError.name = message.headers[\":error-code\"].value as string;\n          throw unmodeledError;\n        } else if (messageType === \"exception\") {\n          // For modeled exception, push it to deserializer and throw after deserializing\n          const code = message.headers[\":exception-type\"].value as string;\n          const exception = { [code]: message };\n          // Get parsed exception event in key(error code) value(structured error) pair.\n          const deserializedException = await options.deserializer(exception);\n          if (deserializedException.$unknown) {\n            //this is an unmodeled exception then try parsing it with best effort\n            const error = new Error(options.toUtf8(message.body));\n            error.name = code;\n            throw error;\n          }\n          throw deserializedException[code];\n        } else if (messageType === \"event\") {\n          const event = {\n            [message.headers[\":event-type\"].value as string]: message,\n          };\n          const deserialized = await options.deserializer(event);\n          if (deserialized.$unknown) continue;\n          yield deserialized;\n        } else {\n          throw Error(`Unrecognizable event type: ${message.headers[\":event-type\"].value}`);\n        }\n      }\n    },\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
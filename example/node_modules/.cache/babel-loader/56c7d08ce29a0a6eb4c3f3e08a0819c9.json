{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\nvar _generated = require(\"../../validators/generated\");\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\nfunction removeTypeDuplicates(nodes) {\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n    if ((0, _generated.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n    if ((0, _generated.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _generated.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {\n      const name = getQualifiedName(node.typeName);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}","map":{"version":3,"sources":["../../../src/modifications/typescript/removeTypeDuplicates.ts"],"names":["getQualifiedName","node","name","right","left","removeTypeDuplicates","nodes","generics","Map","bases","typeGroups","Set","types","i","length","indexOf","set","type","has","push","add","typeParameters","typeName","existing","get","params","concat","baseType","genericName"],"mappings":"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","sourcesContent":["import {\n  isIdentifier,\n  isTSAnyKeyword,\n  isTSTypeReference,\n  isTSUnionType,\n  isTSBaseType,\n} from \"../../validators/generated\";\nimport type * as t from \"../..\";\n\nfunction getQualifiedName(node: t.TSTypeReference[\"typeName\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodes: Array<t.TSType>,\n): Array<t.TSType> {\n  const generics = new Map<string, t.TSTypeReference>();\n  const bases = new Map<t.TSBaseType[\"type\"], t.TSBaseType>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.TSType[]>();\n\n  const types: t.TSType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isTSAnyKeyword(node)) {\n      return [node];\n    }\n\n    // Analogue of FlowBaseAnnotation\n    if (isTSBaseType(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isTSUnionType(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // todo: support merging tuples: number[]\n    if (isTSTypeReference(node) && node.typeParameters) {\n      const name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        let existing: t.TypeScript = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params.concat(node.typeParameters.params),\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n"]},"metadata":{},"sourceType":"script"}
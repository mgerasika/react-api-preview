{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\nconst p = require('path');\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\nconst macrosRegex = /[./]macro(\\.js)?$/;\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n}\nlet _configExplorer = null;\nfunction getConfigExporer() {\n  return _configExplorer = _configExplorer ||\n  // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\nfunction createMacro(macro) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n    return macro(args);\n  }\n}\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\nfunction macrosPlugin(babel) {\n  let _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n      require: _require = require,\n      resolvePath = nodeResolvePath,\n      isMacrosName = testMacrosRegex\n    } = _ref,\n    options = (0, _objectWithoutPropertiesLoose2.default)(_ref, [\"require\", \"resolvePath\", \"isMacrosName\"]);\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n            if (!isMacros) {\n              return;\n            }\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n        });\n      }\n    }\n  };\n} // eslint-disable-next-line complexity\n\nfunction applyMacros(_ref2) {\n  let {\n    path,\n    imports,\n    source,\n    state,\n    babel,\n    interopRequire,\n    resolvePath,\n    options\n  } = _ref2;\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, _ref3) => {\n    let {\n      importedName,\n      localName\n    } = _ref3;\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n  const config = getConfig(macro, filename, source, options);\n  let result;\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n    error.message = `${source}: ${error.message}`;\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace(\n      // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n    throw error;\n  }\n  return result;\n}\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExporer().search(filename);\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n  return {};\n}\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n  return {};\n}\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n    return (0, _extends2.default)({}, optionsConfig.options, {}, fileConfig.options);\n  }\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n  return p.join(process.cwd(), filename);\n}\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});","map":{"version":3,"names":["_interopRequireDefault","require","_extends2","_objectWithoutPropertiesLoose2","p","resolve","macrosRegex","testMacrosRegex","v","test","MacroError","Error","constructor","message","name","captureStackTrace","stack","_configExplorer","getConfigExporer","cosmiconfigSync","searchPlaces","packageProp","createMacro","macro","options","configName","macroWrapper","isBabelMacro","args","source","isBabelMacrosCall","nodeResolvePath","basedir","sync","paths","__dirname","macrosPlugin","babel","_ref","_require","resolvePath","isMacrosName","default","interopRequire","path","o","__esModule","visitor","Program","progPath","state","traverse","ImportDeclaration","isMacros","looksLike","node","value","imports","specifiers","map","s","localName","local","importedName","type","imported","result","applyMacros","keepImports","remove","VariableDeclaration","child","init","callee","arguments","length","get","filter","forEach","id","properties","property","key","call","file","opts","filename","hasReferences","referencePathsByImportName","reduce","byName","binding","scope","getBinding","referencePaths","Boolean","isRelative","indexOf","requirePath","dirname","getFullFilename","config","getConfig","Identifier","references","error","replace","getConfigFromFile","loaded","search","filepath","e","getConfigFromOptions","hasOwnProperty","console","fileConfig","optionsConfig","undefined","isAbsolute","join","process","cwd","a","b","Object","keys","every","bKey","bVal","aVal","isPrimitive","val","module","exports","assign"],"sources":["/home/mgerasika/Documents/git/oddbox/oddbox-frontend-npm-usage-example/node_modules/babel-plugin-macros/dist/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nconst p = require('path');\n\nconst resolve = require('resolve'); // const printAST = require('ast-pretty-print')\n\n\nconst macrosRegex = /[./]macro(\\.js)?$/;\n\nconst testMacrosRegex = v => macrosRegex.test(v); // https://stackoverflow.com/a/32749533/971592\n\n\nclass MacroError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'MacroError';\n    /* istanbul ignore else */\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, this.constructor);\n    } else if (!this.stack) {\n      this.stack = new Error(message).stack;\n    }\n  }\n\n}\n\nlet _configExplorer = null;\n\nfunction getConfigExporer() {\n  return _configExplorer = _configExplorer || // Lazy load cosmiconfig since it is a relatively large bundle\n  require('cosmiconfig').cosmiconfigSync('babel-plugin-macros', {\n    searchPlaces: ['package.json', '.babel-plugin-macrosrc', '.babel-plugin-macrosrc.json', '.babel-plugin-macrosrc.yaml', '.babel-plugin-macrosrc.yml', '.babel-plugin-macrosrc.js', 'babel-plugin-macros.config.js'],\n    packageProp: 'babelMacros'\n  });\n}\n\nfunction createMacro(macro, options = {}) {\n  if (options.configName === 'options') {\n    throw new Error(`You cannot use the configName \"options\". It is reserved for babel-plugin-macros.`);\n  }\n\n  macroWrapper.isBabelMacro = true;\n  macroWrapper.options = options;\n  return macroWrapper;\n\n  function macroWrapper(args) {\n    const {\n      source,\n      isBabelMacrosCall\n    } = args;\n\n    if (!isBabelMacrosCall) {\n      throw new MacroError(`The macro you imported from \"${source}\" is being executed outside the context of compilation with babel-plugin-macros. ` + `This indicates that you don't have the babel plugin \"babel-plugin-macros\" configured correctly. ` + `Please see the documentation for how to configure babel-plugin-macros properly: ` + 'https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md');\n    }\n\n    return macro(args);\n  }\n}\n\nfunction nodeResolvePath(source, basedir) {\n  return resolve.sync(source, {\n    basedir,\n    // This is here to support the package being globally installed\n    // read more: https://github.com/kentcdodds/babel-plugin-macros/pull/138\n    paths: [p.resolve(__dirname, '../../')]\n  });\n}\n\nfunction macrosPlugin(babel, _ref = {}) {\n  let {\n    require: _require = require,\n    resolvePath = nodeResolvePath,\n    isMacrosName = testMacrosRegex\n  } = _ref,\n      options = (0, _objectWithoutPropertiesLoose2.default)(_ref, [\"require\", \"resolvePath\", \"isMacrosName\"]);\n\n  function interopRequire(path) {\n    // eslint-disable-next-line import/no-dynamic-require\n    const o = _require(path);\n\n    return o && o.__esModule && o.default ? o.default : o;\n  }\n\n  return {\n    name: 'macros',\n    visitor: {\n      Program(progPath, state) {\n        progPath.traverse({\n          ImportDeclaration(path) {\n            const isMacros = looksLike(path, {\n              node: {\n                source: {\n                  value: v => isMacrosName(v)\n                }\n              }\n            });\n\n            if (!isMacros) {\n              return;\n            }\n\n            const imports = path.node.specifiers.map(s => ({\n              localName: s.local.name,\n              importedName: s.type === 'ImportDefaultSpecifier' ? 'default' : s.imported.name\n            }));\n            const source = path.node.source.value;\n            const result = applyMacros({\n              path,\n              imports,\n              source,\n              state,\n              babel,\n              interopRequire,\n              resolvePath,\n              options\n            });\n\n            if (!result || !result.keepImports) {\n              path.remove();\n            }\n          },\n\n          VariableDeclaration(path) {\n            const isMacros = child => looksLike(child, {\n              node: {\n                init: {\n                  callee: {\n                    type: 'Identifier',\n                    name: 'require'\n                  },\n                  arguments: args => args.length === 1 && isMacrosName(args[0].value)\n                }\n              }\n            });\n\n            path.get('declarations').filter(isMacros).forEach(child => {\n              const imports = child.node.id.name ? [{\n                localName: child.node.id.name,\n                importedName: 'default'\n              }] : child.node.id.properties.map(property => ({\n                localName: property.value.name,\n                importedName: property.key.name\n              }));\n              const call = child.get('init');\n              const source = call.node.arguments[0].value;\n              const result = applyMacros({\n                path: call,\n                imports,\n                source,\n                state,\n                babel,\n                interopRequire,\n                resolvePath,\n                options\n              });\n\n              if (!result || !result.keepImports) {\n                child.remove();\n              }\n            });\n          }\n\n        });\n      }\n\n    }\n  };\n} // eslint-disable-next-line complexity\n\n\nfunction applyMacros({\n  path,\n  imports,\n  source,\n  state,\n  babel,\n  interopRequire,\n  resolvePath,\n  options\n}) {\n  /* istanbul ignore next (pretty much only useful for astexplorer I think) */\n  const {\n    file: {\n      opts: {\n        filename = ''\n      }\n    }\n  } = state;\n  let hasReferences = false;\n  const referencePathsByImportName = imports.reduce((byName, {\n    importedName,\n    localName\n  }) => {\n    const binding = path.scope.getBinding(localName);\n    byName[importedName] = binding.referencePaths;\n    hasReferences = hasReferences || Boolean(byName[importedName].length);\n    return byName;\n  }, {});\n  const isRelative = source.indexOf('.') === 0;\n  const requirePath = resolvePath(source, p.dirname(getFullFilename(filename)));\n  const macro = interopRequire(requirePath);\n\n  if (!macro.isBabelMacro) {\n    throw new Error(`The macro imported from \"${source}\" must be wrapped in \"createMacro\" ` + `which you can get from \"babel-plugin-macros\". ` + `Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`);\n  }\n\n  const config = getConfig(macro, filename, source, options);\n  let result;\n\n  try {\n    /**\n     * Other plugins that run before babel-plugin-macros might use path.replace, where a path is\n     * put into its own replacement. Apparently babel does not update the scope after such\n     * an operation. As a remedy, the whole scope is traversed again with an empty \"Identifier\"\n     * visitor - this makes the problem go away.\n     *\n     * See: https://github.com/kentcdodds/import-all.macro/issues/7\n     */\n    state.file.scope.path.traverse({\n      Identifier() {}\n\n    });\n    result = macro({\n      references: referencePathsByImportName,\n      source,\n      state,\n      babel,\n      config,\n      isBabelMacrosCall: true\n    });\n  } catch (error) {\n    if (error.name === 'MacroError') {\n      throw error;\n    }\n\n    error.message = `${source}: ${error.message}`;\n\n    if (!isRelative) {\n      error.message = `${error.message} Learn more: https://www.npmjs.com/package/${source.replace( // remove everything after package name\n      // @org/package/macro -> @org/package\n      // package/macro      -> package\n      /^((?:@[^/]+\\/)?[^/]+).*/, '$1')}`;\n    }\n\n    throw error;\n  }\n\n  return result;\n}\n\nfunction getConfigFromFile(configName, filename) {\n  try {\n    const loaded = getConfigExporer().search(filename);\n\n    if (loaded) {\n      return {\n        options: loaded.config[configName],\n        path: loaded.filepath\n      };\n    }\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n\n  return {};\n}\n\nfunction getConfigFromOptions(configName, options) {\n  if (options.hasOwnProperty(configName)) {\n    if (options[configName] && typeof options[configName] !== 'object') {\n      // eslint-disable-next-line no-console\n      console.error(`The macro plugin options' ${configName} property was not an object or null.`);\n    } else {\n      return {\n        options: options[configName]\n      };\n    }\n  }\n\n  return {};\n}\n\nfunction getConfig(macro, filename, source, options) {\n  const {\n    configName\n  } = macro.options;\n\n  if (configName) {\n    const fileConfig = getConfigFromFile(configName, filename);\n    const optionsConfig = getConfigFromOptions(configName, options);\n\n    if (optionsConfig.options === undefined && fileConfig.options === undefined && fileConfig.error !== undefined) {\n      // eslint-disable-next-line no-console\n      console.error(`There was an error trying to load the config \"${configName}\" ` + `for the macro imported from \"${source}. ` + `Please see the error thrown for more information.`);\n      throw fileConfig.error;\n    }\n\n    if (fileConfig.options !== undefined && optionsConfig.options !== undefined && typeof fileConfig.options !== 'object') {\n      throw new Error(`${fileConfig.path} specified a ${configName} config of type ` + `${typeof optionsConfig.options}, but the the macros plugin's ` + `options.${configName} did contain an object. Both configs must ` + `contain objects for their options to be mergeable.`);\n    }\n\n    return (0, _extends2.default)({}, optionsConfig.options, {}, fileConfig.options);\n  }\n\n  return undefined;\n}\n/*\n istanbul ignore next\n because this is hard to test\n and not worth it...\n */\n\n\nfunction getFullFilename(filename) {\n  if (p.isAbsolute(filename)) {\n    return filename;\n  }\n\n  return p.join(process.cwd(), filename);\n}\n\nfunction looksLike(a, b) {\n  return a && b && Object.keys(b).every(bKey => {\n    const bVal = b[bKey];\n    const aVal = a[bKey];\n\n    if (typeof bVal === 'function') {\n      return bVal(aVal);\n    }\n\n    return isPrimitive(bVal) ? bVal === aVal : looksLike(aVal, bVal);\n  });\n}\n\nfunction isPrimitive(val) {\n  // eslint-disable-next-line\n  return val == null || /^[sbn]/.test(typeof val);\n}\n\nmodule.exports = macrosPlugin;\nObject.assign(module.exports, {\n  createMacro,\n  MacroError\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}
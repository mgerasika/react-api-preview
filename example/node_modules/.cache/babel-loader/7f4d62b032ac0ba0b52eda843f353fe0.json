{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { HttpResponse } from \"@aws-sdk/protocol-http\";\n/**\n * In case of an internal error/terminated connection, S3 operations may return 200 errors. CopyObject, UploadPartCopy,\n * CompleteMultipartUpload may return empty payload or payload with only xml Preamble.\n * @internal\n */\nexport var throw200ExceptionsMiddleware = function (config) {\n  return function (next) {\n    return function (args) {\n      return __awaiter(void 0, void 0, void 0, function () {\n        var result, response, statusCode, body, bodyBytes, bodyString, err;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, next(args)];\n            case 1:\n              result = _a.sent();\n              response = result.response;\n              if (!HttpResponse.isInstance(response)) return [2 /*return*/, result];\n              statusCode = response.statusCode, body = response.body;\n              if (statusCode < 200 && statusCode >= 300) return [2 /*return*/, result];\n              return [4 /*yield*/, collectBody(body, config)];\n            case 2:\n              bodyBytes = _a.sent();\n              return [4 /*yield*/, collectBodyString(bodyBytes, config)];\n            case 3:\n              bodyString = _a.sent();\n              if (bodyBytes.length === 0) {\n                err = new Error(\"S3 aborted request\");\n                err.name = \"InternalError\";\n                throw err;\n              }\n              if (bodyString && bodyString.match(\"<Error>\")) {\n                // Set the error code to 4XX so that error deserializer can parse them\n                response.statusCode = 400;\n              }\n              // Body stream is consumed and paused at this point. So replace the response.body to the collected bytes.\n              // So that the deserializer can consume the body as normal.\n              response.body = bodyBytes;\n              return [2 /*return*/, result];\n          }\n        });\n      });\n    };\n  };\n};\n// Collect low-level response body stream to Uint8Array.\nvar collectBody = function (streamBody, context) {\n  if (streamBody === void 0) {\n    streamBody = new Uint8Array();\n  }\n  if (streamBody instanceof Uint8Array) {\n    return Promise.resolve(streamBody);\n  }\n  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());\n};\n// Encode Uint8Array data into string with utf-8.\nvar collectBodyString = function (streamBody, context) {\n  return collectBody(streamBody, context).then(function (body) {\n    return context.utf8Encoder(body);\n  });\n};\n/**\n * @internal\n */\nexport var throw200ExceptionsMiddlewareOptions = {\n  relation: \"after\",\n  toMiddleware: \"deserializerMiddleware\",\n  tags: [\"THROW_200_EXCEPTIONS\", \"S3\"],\n  name: \"throw200ExceptionsMiddleware\",\n  override: true\n};\n/**\n *\n * @internal\n */\nexport var getThrow200ExceptionsPlugin = function (config) {\n  return {\n    applyToStack: function (clientStack) {\n      clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);\n    }\n  };\n};","map":{"version":3,"sources":["../../src/throw-200-exceptions.ts"],"names":[],"mappings":";AAAA,SAAS,YAAY,QAAQ,wBAAwB;AAQrD;;;;AAIG;AACH,OAAO,IAAM,4BAA4B,GAAG,UAAC,MAA0B,EAAA;EAAsC,OAAA,UAC3G,IAAI,EAAA;IACD,OAAA,UAAO,IAAI,EAAA;MAAA,OAAA,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;cACC,OAAA,CAAA,CAAA,CAAA,WAAM,IAAI,CAAC,IAAI,CAAC,CAAA;;cAAzB,MAAM,GAAG,EAAA,CAAA,IAAA,EAAgB;cACvB,QAAQ,GAAK,MAAM,CAAA,QAAX;cAChB,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,OAAA,CAAA,CAAA,CAAA,YAAO,MAAM,CAAA;cAC7C,UAAU,GAAW,QAAQ,CAAA,UAAnB,EAAE,IAAI,GAAK,QAAQ,CAAA,IAAb;cACxB,IAAI,UAAU,GAAG,GAAG,IAAI,UAAU,IAAI,GAAG,EAAE,OAAA,CAAA,CAAA,CAAA,YAAO,MAAM,CAAA;cAGtC,OAAA,CAAA,CAAA,CAAA,WAAM,WAAW,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;;cAA3C,SAAS,GAAG,EAAA,CAAA,IAAA,EAA+B;cAC9B,OAAA,CAAA,CAAA,CAAA,WAAM,iBAAiB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAA;;cAAvD,UAAU,GAAG,EAAA,CAAA,IAAA,EAA0C;cAC7D,IAAI,SAAS,CAAC,MAAM,KAAK,CAAC,EAAE;gBACpB,GAAG,GAAG,IAAI,KAAK,CAAC,oBAAoB,CAAC;gBAC3C,GAAG,CAAC,IAAI,GAAG,eAAe;gBAC1B,MAAM,GAAG;cACV;cACD,IAAI,UAAU,IAAI,UAAU,CAAC,KAAK,CAAC,SAAS,CAAC,EAAE;gBAC7C;gBACA,QAAQ,CAAC,UAAU,GAAG,GAAG;cAC1B;cAED;cACA;cACA,QAAQ,CAAC,IAAI,GAAG,SAAS;cACzB,OAAA,CAAA,CAAA,CAAA,YAAO,MAAM,CAAA;UAAC;;;KACf;EAxBI,CAwBJ;AA1B4G,CA0B5G;AAED;AACA,IAAM,WAAW,GAAG,UAAC,UAAkC,EAAE,OAA2B,EAAA;EAA/D,IAAA,UAAA,KAAA,KAAA,CAAA,EAAA;IAAA,UAAA,GAAA,IAAsB,UAAU,EAAE;EAAA;EACrD,IAAI,UAAU,YAAY,UAAU,EAAE;IACpC,OAAO,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC;EACnC;EACD,OAAO,OAAO,CAAC,eAAe,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,UAAU,EAAE,CAAC;AACjF,CAAC;AAED;AACA,IAAM,iBAAiB,GAAG,UAAC,UAAe,EAAE,OAA2B,EAAA;EACrE,OAAA,WAAW,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,UAAC,IAAI,EAAA;IAAK,OAAA,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC;EAAzB,CAAyB,CAAC;AAA1E,CAA0E;AAE5E;;AAEG;AACH,OAAO,IAAM,mCAAmC,GAA8B;EAC5E,QAAQ,EAAE,OAAO;EACjB,YAAY,EAAE,wBAAwB;EACtC,IAAI,EAAE,CAAC,sBAAsB,EAAE,IAAI,CAAC;EACpC,IAAI,EAAE,8BAA8B;EACpC,QAAQ,EAAE;CACX;AAED;;;AAGG;AACH,OAAO,IAAM,2BAA2B,GAAG,UAAC,MAA0B,EAAA;EAA0B,OAAC;IAC/F,YAAY,EAAE,UAAC,WAAW,EAAA;MACxB,WAAW,CAAC,aAAa,CAAC,4BAA4B,CAAC,MAAM,CAAC,EAAE,mCAAmC,CAAC;IACtG;GACD;AAJ+F,CAI9F","sourcesContent":["import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { DeserializeMiddleware, Encoder, Pluggable, RelativeMiddlewareOptions, StreamCollector } from \"@aws-sdk/types\";\n\ntype PreviouslyResolved = {\n  streamCollector: StreamCollector;\n  utf8Encoder: Encoder;\n};\n\n/**\n * In case of an internal error/terminated connection, S3 operations may return 200 errors. CopyObject, UploadPartCopy,\n * CompleteMultipartUpload may return empty payload or payload with only xml Preamble.\n * @internal\n */\nexport const throw200ExceptionsMiddleware = (config: PreviouslyResolved): DeserializeMiddleware<any, any> => (\n  next\n) => async (args) => {\n  const result = await next(args);\n  const { response } = result;\n  if (!HttpResponse.isInstance(response)) return result;\n  const { statusCode, body } = response;\n  if (statusCode < 200 && statusCode >= 300) return result;\n\n  // Throw 2XX response that's either an error or has empty body.\n  const bodyBytes = await collectBody(body, config);\n  const bodyString = await collectBodyString(bodyBytes, config);\n  if (bodyBytes.length === 0) {\n    const err = new Error(\"S3 aborted request\");\n    err.name = \"InternalError\";\n    throw err;\n  }\n  if (bodyString && bodyString.match(\"<Error>\")) {\n    // Set the error code to 4XX so that error deserializer can parse them\n    response.statusCode = 400;\n  }\n\n  // Body stream is consumed and paused at this point. So replace the response.body to the collected bytes.\n  // So that the deserializer can consume the body as normal.\n  response.body = bodyBytes;\n  return result;\n};\n\n// Collect low-level response body stream to Uint8Array.\nconst collectBody = (streamBody: any = new Uint8Array(), context: PreviouslyResolved): Promise<Uint8Array> => {\n  if (streamBody instanceof Uint8Array) {\n    return Promise.resolve(streamBody);\n  }\n  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());\n};\n\n// Encode Uint8Array data into string with utf-8.\nconst collectBodyString = (streamBody: any, context: PreviouslyResolved): Promise<string> =>\n  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));\n\n/**\n * @internal\n */\nexport const throw200ExceptionsMiddlewareOptions: RelativeMiddlewareOptions = {\n  relation: \"after\",\n  toMiddleware: \"deserializerMiddleware\",\n  tags: [\"THROW_200_EXCEPTIONS\", \"S3\"],\n  name: \"throw200ExceptionsMiddleware\",\n  override: true,\n};\n\n/**\n *\n * @internal\n */\nexport const getThrow200ExceptionsPlugin = (config: PreviouslyResolved): Pluggable<any, any> => ({\n  applyToStack: (clientStack) => {\n    clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
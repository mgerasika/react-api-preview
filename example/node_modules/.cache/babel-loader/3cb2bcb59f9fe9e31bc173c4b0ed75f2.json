{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = literalTemplate;\nvar _options = require(\"./options\");\nvar _parse = require(\"./parse\");\nvar _populate = require(\"./populate\");\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\nfunction buildLiteralData(formatter, tpl, opts) {\n  let names;\n  let nameSet;\n  let metadata;\n  let prefix = \"\";\n  do {\n    prefix += \"$\";\n    const result = buildTemplateCode(tpl, prefix);\n    names = result.names;\n    nameSet = new Set(names);\n    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {\n      parser: opts.parser,\n      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n      placeholderPattern: opts.placeholderPattern,\n      preserveComments: opts.preserveComments,\n      syntacticPlaceholders: opts.syntacticPlaceholders\n    });\n  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));\n  return {\n    metadata,\n    names\n  };\n}\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n  return {\n    names,\n    code\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","literalTemplate","_options","require","_parse","_populate","formatter","tpl","opts","metadata","names","buildLiteralData","arg","defaultReplacements","forEach","replacement","i","replacements","normalizeReplacements","keys","key","prototype","hasOwnProperty","call","Error","unwrap","assign","nameSet","prefix","result","buildTemplateCode","Set","code","parser","placeholderWhitelist","concat","Array","from","placeholderPattern","preserveComments","syntacticPlaceholders","placeholders","some","placeholder","isDuplicate","has","name","length","push"],"sources":["/home/mgerasika/Documents/git/oddbox/oddbox-frontend-npm-usage-example/node_modules/@babel/template/lib/literal.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = literalTemplate;\n\nvar _options = require(\"./options\");\n\nvar _parse = require(\"./parse\");\n\nvar _populate = require(\"./populate\");\n\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\n\nfunction buildLiteralData(formatter, tpl, opts) {\n  let names;\n  let nameSet;\n  let metadata;\n  let prefix = \"\";\n\n  do {\n    prefix += \"$\";\n    const result = buildTemplateCode(tpl, prefix);\n    names = result.names;\n    nameSet = new Set(names);\n    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {\n      parser: opts.parser,\n      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n      placeholderPattern: opts.placeholderPattern,\n      preserveComments: opts.preserveComments,\n      syntacticPlaceholders: opts.syntacticPlaceholders\n    });\n  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));\n\n  return {\n    metadata,\n    names\n  };\n}\n\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n\n  return {\n    names,\n    code\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}
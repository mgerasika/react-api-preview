{"ast":null,"code":"import { t } from '@common/hooks/use-t.hook';\nimport { generateId } from '@common/utils/generate-id.util';\nimport dayjs from 'dayjs';\nimport { formatDate } from './format-date.util.js';\nimport { getNow } from './now.util.js';\nimport { throwException } from './throw-exception.util.js';\nlet ECalendarEventType;\n(function (ECalendarEventType) {\n  ECalendarEventType[\"subscription\"] = \"subscription\";\n  ECalendarEventType[\"order\"] = \"order\";\n})(ECalendarEventType || (ECalendarEventType = {}));\nconst getStep = _ref => {\n  let {\n    billing_period,\n    billing_period_unit,\n    isNewSubscription\n  } = _ref;\n  if (billing_period_unit === 'week') {\n    return isNewSubscription ? 7 * Math.min(1, billing_period) : 7 * billing_period;\n  } else if (billing_period_unit === 'day') {\n    return billing_period;\n  }\n  throwException('Not implemented (get step)');\n};\nlet EUpcomingDeliverySubType;\n(function (EUpcomingDeliverySubType) {\n  EUpcomingDeliverySubType[\"upcomingDelivery\"] = \"upcomingDelivery\";\n  EUpcomingDeliverySubType[\"pause\"] = \"pause\";\n  EUpcomingDeliverySubType[\"skippedButPauseRemoved\"] = \"skippedButPauseRemoved\";\n  EUpcomingDeliverySubType[\"blockedForUpdate\"] = \"blockedForUpdate\";\n})(EUpcomingDeliverySubType || (EUpcomingDeliverySubType = {}));\nconst isSameOrAfter = (day1, day2) => {\n  return day1.isSame(day2, 'days') || day1.isAfter(day2, 'days');\n};\nconst isSameOrBefore = (day1, day2) => {\n  return day1.isSame(day2, 'days') || day1.isBefore(day2, 'days');\n};\nfunction getEventsFromOrders(_ref2) {\n  let {\n    rangeStartDate,\n    rangeEndDate,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes\n  } = _ref2;\n  const res = [];\n  orders.forEach(order => {\n    const orderDate = dayjs(order.orderDate);\n    if (isSameOrAfter(orderDate, rangeStartDate) && isSameOrBefore(orderDate, rangeEndDate)) {\n      res.push({\n        id: generateId('event'),\n        title: t('Order ') + ` (${order?.payment_status}) ` + order?.order_line_items?.map(i => i.description).join(', '),\n        allDay: true,\n        editable: false,\n        start: orderDate.toDate(),\n        metadata: {\n          type: ECalendarEventType.order,\n          orderObj: {\n            order,\n            subscriptionBillingDate: orderDate.toDate(),\n            subscriptionBillingDate_blockedOnUI: dayjs(orderDate).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate()\n          }\n        },\n        extraDate: orderDate.toDate()\n      });\n    }\n  });\n  return res;\n}\nfunction getEventsFromSubscriptions(today, subscriptions, rangeStartDate, rangeEndDate, orderDates, addAdditionalMinutesForBlockUIInMinutes) {\n  let res = [];\n  const activeSubscriptions = subscriptions.filter(s => s.status !== 'cancelled' && !s.deleted);\n  activeSubscriptions.forEach(subscription => {\n    res = [...res, ...getEventsFromSubscription({\n      today,\n      subscription,\n      rangeStartDate,\n      rangeEndDate,\n      orderDates,\n      addAdditionalMinutesForBlockUIInMinutes\n    })];\n  });\n  return res;\n}\nfunction getEventsFromSubscription(_ref3) {\n  let {\n    today,\n    subscription,\n    rangeStartDate,\n    rangeEndDate,\n    orderDates,\n    addAdditionalMinutesForBlockUIInMinutes\n  } = _ref3;\n  const res = [];\n  const todayM = dayjs(today);\n  const cutOff = subscription.cutOff;\n  // TODO: no need for this condition. Subs are already filtered in getEventsFromSubscriptions\n  if (subscription.status !== 'cancelled' && !subscription.deleted) {\n    // const subscriptionStartDate = subscription.pause\n    //     ? subscription.startDate\n    // \t: subscription.nextBillingAtDate || subscription.startDate;\n\n    // Warning!!! don't change to startDate - not working in a lot of cases!!!\n    let subscriptionStartDate = subscription.nextBillingAtDate;\n    // modify day of week\n    subscriptionStartDate = dayjs(subscriptionStartDate).set('day', subscription.cutOffDayOfWeekFromDC).toDate();\n    let step = getStep({\n      billing_period: subscription.billing_period || 0,\n      billing_period_unit: subscription.billing_period_unit,\n      isNewSubscription: false\n    }) || Number.MAX_VALUE;\n    // should coming from subscription or delivery configuration\n    let current = dayjs(subscriptionStartDate); //.set('hours', 10).set('minutes', 0);\n    current = current.set('hours', Number(subscription.cutoffTime?.getHours()));\n    current = current.set('minutes', Number(subscription.cutoffTime?.getMinutes()));\n    current = current.set('seconds', 0);\n    while (current.isAfter(rangeStartDate)) {\n      const prevTick = current.subtract(step, 'd');\n      if (prevTick.isSame(subscription.startDate, 'd') || prevTick.isAfter(subscription.startDate)) {\n        current = current.subtract(step, 'd');\n      } else {\n        break;\n      }\n    }\n    let subscriptionEndDate = subscription.endDate;\n    const pauses = subscription.pauses || [];\n    while (isSameOrBefore(current, rangeEndDate)) {\n      const pause = pauses.find(pause => {\n        const pauseEndDate = dayjs(pause?.endDate).subtract(1, 'm');\n        return current.isSame(pause.startDate, 'd') || current.isSame(pauseEndDate) || current.isAfter(pause.startDate) && current.isBefore(pauseEndDate);\n      });\n      const haveOrder = orderDates.find(orderDate => current.isSame(orderDate, 'd'));\n      if (!haveOrder) {\n        if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate) && (!subscription.cancelDate || subscription.cancelDate && current.isBefore(subscription.cancelDate, 'd'))) {\n          const currentWithAdditionalMinutesForBlockUI = dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes');\n          let subType = EUpcomingDeliverySubType.upcomingDelivery;\n          if (pause) {\n            subType = EUpcomingDeliverySubType.pause;\n          } else if (current.isBefore(subscription.nextBillingAtDate, 'day') && current.isBefore(todayM)) {\n            // if (!isSameOrAfter(current, todayM))\n            {\n              subType = EUpcomingDeliverySubType.skippedButPauseRemoved;\n              // current = current.add(step, 'd');\n              // continue;\n            }\n          } else {\n            subType = todayM.isAfter(currentWithAdditionalMinutesForBlockUI) || todayM.isSame(currentWithAdditionalMinutesForBlockUI) ? EUpcomingDeliverySubType.blockedForUpdate : EUpcomingDeliverySubType.upcomingDelivery;\n          }\n          if (subscription.has_scheduled_changes && isSameOrAfter(current, subscription.nextBillingAtDate) && subscription.subscription_with_scheduled_changes?.id) {\n            res.push({\n              id: generateId('event'),\n              title: `${subscription.id}`,\n              start: current.toDate(),\n              allDay: true,\n              editable: false,\n              metadata: {\n                type: ECalendarEventType.subscription,\n                subscriptionObj: {\n                  subscription: subscription.subscription_with_scheduled_changes,\n                  subType,\n                  subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                  subscriptionBillingDate: current.toDate(),\n                  subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate(),\n                  totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0)\n                }\n              },\n              extraDate: current.toDate()\n            });\n            step = getStep({\n              billing_period: subscription.subscription_with_scheduled_changes?.billing_period || 0,\n              billing_period_unit: subscription.subscription_with_scheduled_changes?.billing_period_unit,\n              isNewSubscription: false\n            }) || Number.MAX_VALUE;\n            subscriptionEndDate = subscription.subscription_with_scheduled_changes?.endDate;\n          } else if (!isSameOrAfter(current, subscription.nextBillingAtDate) && subType == EUpcomingDeliverySubType.upcomingDelivery) ;else {\n            const title = `${subscription.id}`;\n            res.push({\n              id: generateId('event'),\n              title,\n              start: current.toDate(),\n              allDay: true,\n              editable: false,\n              metadata: {\n                subscriptionObj: {\n                  subscription,\n                  subType,\n                  subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                  subscriptionBillingDate: current.toDate(),\n                  subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes').toDate(),\n                  totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0)\n                },\n                type: ECalendarEventType.subscription\n              },\n              extraDate: current.toDate()\n            });\n          }\n        }\n      }\n      current = current.add(step, 'd');\n    }\n  }\n  return res;\n}\nfunction getEventsFromPrice(_ref4) {\n  let {\n    price,\n    rangeStartDate,\n    rangeEndDate,\n    cutOff,\n    isNewSubscription\n  } = _ref4;\n  const res = [];\n  let current = rangeStartDate ? dayjs(rangeStartDate) : dayjs(getNow()).hour(23).minute(59).second(59);\n  const step = getStep({\n    billing_period: price.period || 0,\n    billing_period_unit: price.period_unit,\n    isNewSubscription\n  }) || Number.MAX_VALUE;\n  const subscriptionEndDate = new Date(8640000000000000);\n  while (isSameOrBefore(current, rangeEndDate)) {\n    if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate)) {\n      res.push({\n        id: generateId('event'),\n        title: formatDate(current.toDate()),\n        start: current.toDate(),\n        allDay: true,\n        editable: false,\n        metadata: {\n          type: ECalendarEventType.subscription,\n          priceObj: {\n            price,\n            subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n            subscriptionBillingDate: current.toDate(),\n            subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(0, 'minutes').toDate()\n          }\n\n          // subscriptionSkipObject: undefined,\n        },\n\n        extraDate: current.toDate()\n      });\n    }\n    current = current.add(step, 'd');\n  }\n  return res;\n}\nconst getAllEvents = _ref5 => {\n  let {\n    today,\n    subscriptions,\n    range,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes\n  } = _ref5;\n  const subscriptionEvents = getEventsFromSubscriptions(today, subscriptions || [], range?.start, range?.end, orders?.map(o => o.orderDate) || [], addAdditionalMinutesForBlockUIInMinutes);\n  const orderEvents = getEventsFromOrders({\n    orders: orders || [],\n    rangeStartDate: range?.start,\n    rangeEndDate: range?.end,\n    addAdditionalMinutesForBlockUIInMinutes\n  });\n  return [...subscriptionEvents, ...orderEvents].sort((a, b) => a.start.getTime && b.start.getTime && a.start?.getTime() > b.start?.getTime() ? 1 : -1);\n};\nfunction getFirstEvent(events) {\n  const [firstEvent] = events.filter(f => f.metadata?.type === ECalendarEventType.subscription && f.metadata.subscriptionObj?.subType !== EUpcomingDeliverySubType.skippedButPauseRemoved)\n  // filter past skips\n  .filter(f => f.metadata?.subscriptionObj?.subType !== EUpcomingDeliverySubType.pause || f.metadata?.subscriptionObj?.subType === EUpcomingDeliverySubType.pause && f.metadata?.subscriptionObj.subscriptionBillingDate.getTime() > getNow().getTime());\n  return firstEvent;\n}\nexport { ECalendarEventType, EUpcomingDeliverySubType, getAllEvents, getEventsFromPrice, getFirstEvent, getStep };","map":{"version":3,"sources":["../../../src/utils/get-events.util.ts"],"names":["ECalendarEventType","getStep","billing_period","billing_period_unit","isNewSubscription","Math","min","throwException","EUpcomingDeliverySubType","isSameOrAfter","day1","day2","isSame","isAfter","isSameOrBefore","isBefore","getEventsFromOrders","rangeStartDate","rangeEndDate","orders","addAdditionalMinutesForBlockUIInMinutes","res","forEach","order","orderDate","dayjs","push","id","generateId","title","t","payment_status","order_line_items","map","i","description","join","allDay","editable","start","toDate","metadata","type","orderObj","subscriptionBillingDate","subscriptionBillingDate_blockedOnUI","subtract","extraDate","getEventsFromSubscriptions","today","subscriptions","orderDates","activeSubscriptions","filter","s","status","deleted","subscription","getEventsFromSubscription","todayM","cutOff","subscriptionStartDate","nextBillingAtDate","set","cutOffDayOfWeekFromDC","step","Number","MAX_VALUE","current","cutoffTime","getHours","getMinutes","prevTick","startDate","subscriptionEndDate","endDate","pauses","pause","find","pauseEndDate","haveOrder","cancelDate","currentWithAdditionalMinutesForBlockUI","subType","upcomingDelivery","skippedButPauseRemoved","blockedForUpdate","has_scheduled_changes","subscription_with_scheduled_changes","subscriptionObj","subscriptionDeliveryDate","add","totalPrice","totalAddonsPrice","getEventsFromPrice","price","getNow","hour","minute","second","period","period_unit","Date","formatDate","priceObj","getAllEvents","range","subscriptionEvents","end","o","orderEvents","sort","a","b","getTime","getFirstEvent","events","firstEvent","f"],"mappings":"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","sourcesContent":["import { CustomEventInput, ICalendarDateRange } from '@common/general-ui/full-calendar/full-calendar.component';\nimport { t } from '@common/hooks/use-t.hook';\nimport { IIdObject } from '@common/interfaces/id-object.interface';\nimport { generateId } from '@common/utils/generate-id.util';\nimport dayjs from 'dayjs';\nimport { formatDate } from './format-date.util';\nimport { getNow } from './now.util';\nimport { throwException } from './throw-exception.util';\n\nexport enum ECalendarEventType {\n    subscription = 'subscription',\n    order = 'order',\n}\n\nexport interface IPauseCommon {\n    pauseBillingDate: Date;\n    resumeBillingDate: Date;\n}\n\nexport interface ISubscriptionCommon extends IIdObject {\n    status?: string;\n    deleted?: boolean;\n    cutOff: number;\n    cutoffTime: Date | undefined;\n    cutOffDayOfWeekFromDC: number;\n    nextBillingAtDate?: Date;\n    subscription_items?: Array<{ item_price_id?: string }>;\n    startDate?: Date;\n    endDate?: Date;\n    cancelDate?: Date;\n    has_scheduled_changes?: boolean;\n    subscription_with_scheduled_changes?: ISubscriptionCommon;\n    pauses: IDayRangeCommon[] | undefined;\n    totalPrice: number;\n    totalAddonsPrice: number;\n    billing_period?: number;\n    billing_period_unit?: string;\n}\n\nexport interface IItemPriceCommon {\n    period?: number;\n    period_unit?: string;\n}\n\nexport interface IDayRangeCommon {\n    startDate?: Date;\n    endDate?: Date;\n}\n\nexport interface IOrderCommon {\n    orderDate: Date;\n    payment_status?: string;\n    order_line_items?: { description?: string }[];\n}\n\nexport const getStep = ({\n    billing_period,\n    billing_period_unit,\n    isNewSubscription,\n}: {\n    billing_period: number;\n    billing_period_unit: string | undefined;\n    isNewSubscription: boolean;\n}): number | void => {\n    if (billing_period_unit === 'week') {\n        return isNewSubscription ? 7 * Math.min(1, billing_period) : 7 * billing_period;\n    } else if (billing_period_unit === 'day') {\n        return billing_period;\n    }\n    throwException('Not implemented (get step)');\n};\n\nexport enum EUpcomingDeliverySubType {\n    upcomingDelivery = 'upcomingDelivery',\n    pause = 'pause',\n    skippedButPauseRemoved = 'skippedButPauseRemoved',\n    blockedForUpdate = 'blockedForUpdate',\n}\n\nexport interface ICalendarMetaData<\n    TSubscription extends ISubscriptionCommon = ISubscriptionCommon,\n    TPrice extends IItemPriceCommon = IItemPriceCommon,\n    TOrder extends IOrderCommon = IOrderCommon,\n> {\n    type: ECalendarEventType;\n    subscriptionObj?: {\n        subType: EUpcomingDeliverySubType | undefined;\n        subscription?: TSubscription;\n        // subscriptionSkipObject: ICbSubscriptionSkip | undefined;\n        subscriptionDeliveryDate: Date;\n        subscriptionBillingDate_blockedOnUI: Date;\n        subscriptionBillingDate: Date;\n        totalPrice: number;\n    };\n    priceObj?: {\n        price?: TPrice;\n        subscriptionDeliveryDate: Date | undefined;\n        subscriptionBillingDate_blockedOnUI: Date | undefined;\n        subscriptionBillingDate: Date | undefined;\n    };\n    orderObj?: {\n        order: TOrder | undefined;\n        subscriptionBillingDate: Date | undefined;\n        subscriptionBillingDate_blockedOnUI: Date | undefined;\n    };\n}\n\nconst isSameOrAfter = (day1: dayjs.Dayjs, day2: Date | dayjs.Dayjs | undefined): boolean => {\n    return day1.isSame(day2, 'days') || day1.isAfter(day2, 'days');\n};\nconst isSameOrBefore = (day1: dayjs.Dayjs, day2: Date | dayjs.Dayjs | undefined): boolean => {\n    return day1.isSame(day2, 'days') || day1.isBefore(day2, 'days');\n};\nexport type ICalendarEventCommon<\n    TSubsr extends ISubscriptionCommon = ISubscriptionCommon,\n    TPrice extends IItemPriceCommon = IItemPriceCommon,\n    TOrder extends IOrderCommon = IOrderCommon,\n> = CustomEventInput<ICalendarMetaData<TSubsr, TPrice, TOrder>> & IIdObject;\n\nfunction getEventsFromOrders({\n    rangeStartDate,\n    rangeEndDate,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    orders: IOrderCommon[];\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    orders.forEach((order) => {\n        const orderDate = dayjs(order.orderDate);\n\n        if (isSameOrAfter(orderDate, rangeStartDate) && isSameOrBefore(orderDate, rangeEndDate)) {\n            res.push({\n                id: generateId('event'),\n                title:\n                    t('Order ') +\n                    ` (${order?.payment_status}) ` +\n                    order?.order_line_items?.map((i) => i.description).join(', '),\n                allDay: true,\n                editable: false,\n                start: orderDate.toDate(),\n                metadata: {\n                    type: ECalendarEventType.order,\n                    orderObj: {\n                        order,\n                        subscriptionBillingDate: orderDate.toDate(),\n                        subscriptionBillingDate_blockedOnUI: dayjs(orderDate)\n                            .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                            .toDate(),\n                    },\n                },\n                extraDate: orderDate.toDate(),\n            });\n        }\n    });\n    return res;\n}\n\nfunction getEventsFromSubscriptions(\n    today: Date,\n    subscriptions: ISubscriptionCommon[],\n    rangeStartDate: Date | undefined,\n    rangeEndDate: Date | undefined,\n    orderDates: Date[],\n    addAdditionalMinutesForBlockUIInMinutes: number,\n): ICalendarEventCommon[] {\n    let res: ICalendarEventCommon[] = [];\n\n    const activeSubscriptions = subscriptions.filter((s) => s.status !== 'cancelled' && !s.deleted);\n\n    activeSubscriptions.forEach((subscription) => {\n        res = [\n            ...res,\n\n            ...getEventsFromSubscription({\n                today,\n                subscription,\n                rangeStartDate,\n                rangeEndDate,\n                orderDates,\n                addAdditionalMinutesForBlockUIInMinutes,\n            }),\n        ];\n    });\n\n    return res;\n}\n\nfunction getEventsFromSubscription({\n    today,\n    subscription,\n    rangeStartDate,\n    rangeEndDate,\n    orderDates,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    today: Date;\n    subscription: ISubscriptionCommon;\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    orderDates: Date[];\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    const todayM = dayjs(today);\n    const cutOff = subscription.cutOff;\n    // TODO: no need for this condition. Subs are already filtered in getEventsFromSubscriptions\n    if (subscription.status !== 'cancelled' && !subscription.deleted) {\n        // const subscriptionStartDate = subscription.pause\n        //     ? subscription.startDate\n        // \t: subscription.nextBillingAtDate || subscription.startDate;\n\n        // Warning!!! don't change to startDate - not working in a lot of cases!!!\n        let subscriptionStartDate = subscription.nextBillingAtDate;\n        // modify day of week\n        subscriptionStartDate = dayjs(subscriptionStartDate)\n            .set('day', subscription.cutOffDayOfWeekFromDC as number)\n            .toDate();\n\n        let step =\n            getStep({\n                billing_period: subscription.billing_period || 0,\n                billing_period_unit: subscription.billing_period_unit,\n                isNewSubscription: false,\n            }) || Number.MAX_VALUE;\n        // should coming from subscription or delivery configuration\n        let current = dayjs(subscriptionStartDate); //.set('hours', 10).set('minutes', 0);\n        current = current.set('hours', Number(subscription.cutoffTime?.getHours()));\n        current = current.set('minutes', Number(subscription.cutoffTime?.getMinutes()));\n        current = current.set('seconds', 0);\n        while (current.isAfter(rangeStartDate)) {\n            const prevTick = current.subtract(step, 'd');\n            if (prevTick.isSame(subscription.startDate, 'd') || prevTick.isAfter(subscription.startDate)) {\n                current = current.subtract(step, 'd');\n            } else {\n                break;\n            }\n        }\n\n        let subscriptionEndDate = subscription.endDate;\n\n        const pauses = subscription.pauses || [];\n\n        while (isSameOrBefore(current, rangeEndDate)) {\n            const pause = pauses.find((pause) => {\n                const pauseEndDate = dayjs(pause?.endDate).subtract(1, 'm');\n                return (\n                    current.isSame(pause.startDate, 'd') ||\n                    current.isSame(pauseEndDate) ||\n                    (current.isAfter(pause.startDate) && current.isBefore(pauseEndDate))\n                );\n            });\n\n            const haveOrder = orderDates.find((orderDate) => current.isSame(orderDate, 'd'));\n            if (!haveOrder) {\n                if (\n                    isSameOrAfter(current, rangeStartDate) &&\n                    isSameOrBefore(current, subscriptionEndDate) &&\n                    (!subscription.cancelDate || (subscription.cancelDate && current.isBefore(subscription.cancelDate, 'd')))\n                ) {\n                    const currentWithAdditionalMinutesForBlockUI = dayjs(current).subtract(\n                        addAdditionalMinutesForBlockUIInMinutes,\n                        'minutes',\n                    );\n\n                    let subType: EUpcomingDeliverySubType = EUpcomingDeliverySubType.upcomingDelivery;\n                    if (pause) {\n                        subType = EUpcomingDeliverySubType.pause;\n                    } else if (current.isBefore(subscription.nextBillingAtDate, 'day') && current.isBefore(todayM)) {\n                        // if (!isSameOrAfter(current, todayM))\n                        {\n                            subType = EUpcomingDeliverySubType.skippedButPauseRemoved;\n                            // current = current.add(step, 'd');\n                            // continue;\n                        }\n                    } else {\n                        subType =\n                            todayM.isAfter(currentWithAdditionalMinutesForBlockUI) ||\n                            todayM.isSame(currentWithAdditionalMinutesForBlockUI)\n                                ? EUpcomingDeliverySubType.blockedForUpdate\n                                : EUpcomingDeliverySubType.upcomingDelivery;\n                    }\n                    if (\n                        subscription.has_scheduled_changes &&\n                        isSameOrAfter(current, subscription.nextBillingAtDate) &&\n                        subscription.subscription_with_scheduled_changes?.id\n                    ) {\n                        res.push({\n                            id: generateId('event'),\n                            title: `${subscription.id}`,\n                            start: current.toDate(),\n                            allDay: true,\n                            editable: false,\n                            metadata: {\n                                type: ECalendarEventType.subscription,\n                                subscriptionObj: {\n                                    subscription: subscription.subscription_with_scheduled_changes,\n                                    subType,\n                                    subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                                    subscriptionBillingDate: current.toDate(),\n                                    subscriptionBillingDate_blockedOnUI: dayjs(current)\n                                        .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                                        .toDate(),\n                                    totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0),\n                                },\n                            },\n                            extraDate: current.toDate(),\n                        });\n\n                        step =\n                            getStep({\n                                billing_period: subscription.subscription_with_scheduled_changes?.billing_period || 0,\n                                billing_period_unit: subscription.subscription_with_scheduled_changes?.billing_period_unit,\n                                isNewSubscription: false,\n                            }) || Number.MAX_VALUE;\n                        subscriptionEndDate = subscription.subscription_with_scheduled_changes?.endDate;\n                    } else if (\n                        !isSameOrAfter(current, subscription.nextBillingAtDate) &&\n                        subType == EUpcomingDeliverySubType.upcomingDelivery\n                    ) {\n                        // do nothing it's not possible\n                        // upcoming delivery will be available only after nextBillingAt or in the same day\n                    } else {\n                        const title = `${subscription.id}`;\n                        res.push({\n                            id: generateId('event'),\n                            title,\n                            start: current.toDate(),\n                            allDay: true,\n                            editable: false,\n                            metadata: {\n                                subscriptionObj: {\n                                    subscription,\n                                    subType,\n                                    subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                                    subscriptionBillingDate: current.toDate(),\n                                    subscriptionBillingDate_blockedOnUI: dayjs(current)\n                                        .subtract(addAdditionalMinutesForBlockUIInMinutes, 'minutes')\n                                        .toDate(),\n                                    totalPrice: subscription?.totalPrice - (pause ? subscription.totalAddonsPrice : 0),\n                                },\n\n                                type: ECalendarEventType.subscription,\n                            },\n                            extraDate: current.toDate(),\n                        });\n                    }\n                }\n            }\n            current = current.add(step, 'd');\n        }\n    }\n\n    return res;\n}\n\nexport function getEventsFromPrice({\n    price,\n    rangeStartDate,\n    rangeEndDate,\n    cutOff,\n    isNewSubscription,\n}: {\n    price: IItemPriceCommon;\n    rangeStartDate: Date | undefined;\n    rangeEndDate: Date | undefined;\n    cutOff: number;\n    isNewSubscription: boolean;\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] {\n    const res: ICalendarEventCommon[] = [];\n\n    let current = rangeStartDate ? dayjs(rangeStartDate) : dayjs(getNow()).hour(23).minute(59).second(59);\n    const step =\n        getStep({ billing_period: price.period || 0, billing_period_unit: price.period_unit, isNewSubscription }) ||\n        Number.MAX_VALUE;\n    const subscriptionEndDate = new Date(8640000000000000);\n\n    while (isSameOrBefore(current, rangeEndDate)) {\n        if (isSameOrAfter(current, rangeStartDate) && isSameOrBefore(current, subscriptionEndDate)) {\n            res.push({\n                id: generateId('event'),\n                title: formatDate(current.toDate()),\n                start: current.toDate(),\n                allDay: true,\n                editable: false,\n                metadata: {\n                    type: ECalendarEventType.subscription,\n                    priceObj: {\n                        price,\n                        subscriptionDeliveryDate: current.add(cutOff, 'd').toDate(),\n                        subscriptionBillingDate: current.toDate(),\n                        subscriptionBillingDate_blockedOnUI: dayjs(current).subtract(0, 'minutes').toDate(),\n                    },\n\n                    // subscriptionSkipObject: undefined,\n                },\n                extraDate: current.toDate(),\n            });\n        }\n        current = current.add(step, 'd');\n    }\n\n    return res;\n}\n\nexport const getAllEvents = ({\n    today,\n    subscriptions,\n    range,\n    orders,\n    addAdditionalMinutesForBlockUIInMinutes,\n}: {\n    today: Date;\n    range: ICalendarDateRange | undefined;\n    subscriptions: ISubscriptionCommon[] | undefined;\n    orders: IOrderCommon[] | undefined;\n    addAdditionalMinutesForBlockUIInMinutes: number;\n}): ICalendarEventCommon[] => {\n    const subscriptionEvents = getEventsFromSubscriptions(\n        today,\n        subscriptions || [],\n        range?.start,\n        range?.end,\n        orders?.map((o) => o.orderDate) || [],\n        addAdditionalMinutesForBlockUIInMinutes,\n    );\n\n    const orderEvents = getEventsFromOrders({\n        orders: orders || [],\n        rangeStartDate: range?.start,\n        rangeEndDate: range?.end,\n        addAdditionalMinutesForBlockUIInMinutes,\n    });\n    return [...subscriptionEvents, ...orderEvents].sort((a, b) =>\n        (a.start as Date).getTime && (b.start as Date).getTime && (a.start as Date)?.getTime() > (b.start as Date)?.getTime()\n            ? 1\n            : -1,\n    );\n};\n\nexport function getFirstEvent<T extends ICalendarEventCommon>(events: ICalendarEventCommon[]): T | undefined {\n    const [firstEvent] = events\n        .filter(\n            (f) =>\n                f.metadata?.type === ECalendarEventType.subscription &&\n                f.metadata.subscriptionObj?.subType !== EUpcomingDeliverySubType.skippedButPauseRemoved,\n        )\n        // filter past skips\n        .filter(\n            (f) =>\n                f.metadata?.subscriptionObj?.subType !== EUpcomingDeliverySubType.pause ||\n                (f.metadata?.subscriptionObj?.subType === EUpcomingDeliverySubType.pause &&\n                    f.metadata?.subscriptionObj.subscriptionBillingDate.getTime() > getNow().getTime()),\n        );\n    return firstEvent as T;\n}\n"]},"metadata":{},"sourceType":"module"}
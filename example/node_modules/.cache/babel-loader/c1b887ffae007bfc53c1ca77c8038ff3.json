{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readFile = readFile;\nexports.readFileSync = readFileSync;\nvar _fs = _interopRequireDefault(require(\"fs\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nasync function fsReadFileAsync(pathname, encoding) {\n  return new Promise((resolve, reject) => {\n    _fs.default.readFile(pathname, encoding, (error, contents) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n      resolve(contents);\n    });\n  });\n}\nasync function readFile(filepath) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const throwNotFound = options.throwNotFound === true;\n  try {\n    const content = await fsReadFileAsync(filepath, 'utf8');\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}\nfunction readFileSync(filepath) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const throwNotFound = options.throwNotFound === true;\n  try {\n    const content = _fs.default.readFileSync(filepath, 'utf8');\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n    throw error;\n  }\n}","map":{"version":3,"sources":["../src/readFile.ts"],"names":["fsReadFileAsync","pathname","encoding","Promise","resolve","reject","fs","readFile","error","contents","filepath","options","throwNotFound","content","code","readFileSync"],"mappings":";;;;;;;AAAA,IAAA,GAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;;;;;AAEA,eAAeA,eAAf,CACEC,QADF,EAEEC,QAFF,EAGmB;EACjB,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAA2B;IAC5CC,GAAAA,CAAAA,OAAAA,CAAGC,QAAHD,CAAYL,QAAZK,EAAsBJ,QAAtBI,EAAgC,CAACE,KAAD,EAAQC,QAAR,KAA2B;MACzD,IAAID,KAAJ,EAAW;QACTH,MAAM,CAACG,KAAD,CAANH;QACA;MACD;MAEDD,OAAO,CAACK,QAAD,CAAPL;IACD,CAPDE,CAAAA;EAQD,CATM,CAAP;AAUD;AAMD,eAAeC,QAAf,CACEG,QADF,EAG0B;EAAA,IADxBC,OAAgB,uEAAG,CAAA,CAFrB;EAIE,MAAMC,aAAa,GAAGD,OAAO,CAACC,aAARD,KAA0B,IAAhD;EAEA,IAAI;IACF,MAAME,OAAO,GAAG,MAAMb,eAAe,CAACU,QAAD,EAAW,MAAX,CAArC;IAEA,OAAOG,OAAP;EACD,CAJD,CAIE,OAAOL,KAAP,EAAc;IACd,IAAII,aAAa,KAAK,KAAlBA,IAA2BJ,KAAK,CAACM,IAANN,KAAe,QAA9C,EAAwD;MACtD,OAAO,IAAP;IACD;IAED,MAAMA,KAAN;EACD;AACF;AAED,SAASO,YAAT,CAAsBL,QAAtB,EAA8E;EAAA,IAAtCC,OAAgB,uEAAG,CAAA,CAA3D;EACE,MAAMC,aAAa,GAAGD,OAAO,CAACC,aAARD,KAA0B,IAAhD;EAEA,IAAI;IACF,MAAME,OAAO,GAAGP,GAAAA,CAAAA,OAAAA,CAAGS,YAAHT,CAAgBI,QAAhBJ,EAA0B,MAA1BA,CAAhB;IAEA,OAAOO,OAAP;EACD,CAJD,CAIE,OAAOL,KAAP,EAAc;IACd,IAAII,aAAa,KAAK,KAAlBA,IAA2BJ,KAAK,CAACM,IAANN,KAAe,QAA9C,EAAwD;MACtD,OAAO,IAAP;IACD;IAED,MAAMA,KAAN;EACD;AACF","sourcesContent":["import fs from 'fs';\n\nasync function fsReadFileAsync(\n  pathname: string,\n  encoding: string,\n): Promise<string> {\n  return new Promise((resolve, reject): void => {\n    fs.readFile(pathname, encoding, (error, contents): void => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(contents);\n    });\n  });\n}\n\ninterface Options {\n  throwNotFound?: boolean;\n}\n\nasync function readFile(\n  filepath: string,\n  options: Options = {},\n): Promise<string | null> {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = await fsReadFileAsync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nfunction readFileSync(filepath: string, options: Options = {}): string | null {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = fs.readFileSync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nexport { readFile, readFileSync };\n"]},"metadata":{},"sourceType":"script"}
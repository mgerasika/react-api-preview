{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;\nvar _t = require(\"@babel/types\");\nconst {\n  assertExpressionStatement\n} = _t;\nfunction makeStatementFormatter(fn) {\n  return {\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: ast => {\n      return fn(ast.program.body.slice(1));\n    }\n  };\n}\nconst smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\nexports.smart = smart;\nconst statements = makeStatementFormatter(body => body);\nexports.statements = statements;\nconst statement = makeStatementFormatter(body => {\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n  return body[0];\n});\nexports.statement = statement;\nconst expression = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: _ref => {\n    let {\n      program\n    } = _ref;\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  }\n};\nexports.expression = expression;\nconst program = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program\n};\nexports.program = program;","map":{"version":3,"names":["Object","defineProperty","exports","value","statements","statement","smart","program","expression","_t","require","assertExpressionStatement","makeStatementFormatter","fn","code","str","validate","unwrap","ast","body","slice","length","Error","start","stmt"],"sources":["/home/mgerasika/Documents/git/oddbox/oddbox-frontend-npm-usage-example/node_modules/@babel/template/lib/formatters.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  assertExpressionStatement\n} = _t;\n\nfunction makeStatementFormatter(fn) {\n  return {\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: ast => {\n      return fn(ast.program.body.slice(1));\n    }\n  };\n}\n\nconst smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\nexports.smart = smart;\nconst statements = makeStatementFormatter(body => body);\nexports.statements = statements;\nconst statement = makeStatementFormatter(body => {\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\nexports.statement = statement;\nconst expression = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ({\n    program\n  }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  }\n};\nexports.expression = expression;\nconst program = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program\n};\nexports.program = program;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,UAAU,GAAGF,OAAO,CAACG,SAAS,GAAGH,OAAO,CAACI,KAAK,GAAGJ,OAAO,CAACK,OAAO,GAAGL,OAAO,CAACM,UAAU,GAAG,KAAK,CAAC;AAEtG,IAAIC,EAAE,GAAGC,OAAO,CAAC,cAAc,CAAC;AAEhC,MAAM;EACJC;AACF,CAAC,GAAGF,EAAE;AAEN,SAASG,sBAAsB,CAACC,EAAE,EAAE;EAClC,OAAO;IACLC,IAAI,EAAEC,GAAG,IAAK,2BAA0BA,GAAI,EAAC;IAC7CC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAClBC,MAAM,EAAEC,GAAG,IAAI;MACb,OAAOL,EAAE,CAACK,GAAG,CAACX,OAAO,CAACY,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IACtC;EACF,CAAC;AACH;AAEA,MAAMd,KAAK,GAAGM,sBAAsB,CAACO,IAAI,IAAI;EAC3C,IAAIA,IAAI,CAACE,MAAM,GAAG,CAAC,EAAE;IACnB,OAAOF,IAAI;EACb,CAAC,MAAM;IACL,OAAOA,IAAI,CAAC,CAAC,CAAC;EAChB;AACF,CAAC,CAAC;AACFjB,OAAO,CAACI,KAAK,GAAGA,KAAK;AACrB,MAAMF,UAAU,GAAGQ,sBAAsB,CAACO,IAAI,IAAIA,IAAI,CAAC;AACvDjB,OAAO,CAACE,UAAU,GAAGA,UAAU;AAC/B,MAAMC,SAAS,GAAGO,sBAAsB,CAACO,IAAI,IAAI;EAC/C,IAAIA,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;EAC7C;EAEA,IAAIH,IAAI,CAACE,MAAM,GAAG,CAAC,EAAE;IACnB,MAAM,IAAIC,KAAK,CAAC,0CAA0C,CAAC;EAC7D;EAEA,OAAOH,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC;AACFjB,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B,MAAMG,UAAU,GAAG;EACjBM,IAAI,EAAEC,GAAG,IAAK,MAAKA,GAAI,KAAI;EAC3BC,QAAQ,EAAEE,GAAG,IAAI;IACf,IAAIA,GAAG,CAACX,OAAO,CAACY,IAAI,CAACE,MAAM,GAAG,CAAC,EAAE;MAC/B,MAAM,IAAIC,KAAK,CAAC,0CAA0C,CAAC;IAC7D;IAEA,IAAId,UAAU,CAACS,MAAM,CAACC,GAAG,CAAC,CAACK,KAAK,KAAK,CAAC,EAAE;MACtC,MAAM,IAAID,KAAK,CAAC,+BAA+B,CAAC;IAClD;EACF,CAAC;EACDL,MAAM,EAAE,QAEF;IAAA,IAFG;MACPV;IACF,CAAC;IACC,MAAM,CAACiB,IAAI,CAAC,GAAGjB,OAAO,CAACY,IAAI;IAC3BR,yBAAyB,CAACa,IAAI,CAAC;IAC/B,OAAOA,IAAI,CAAChB,UAAU;EACxB;AACF,CAAC;AACDN,OAAO,CAACM,UAAU,GAAGA,UAAU;AAC/B,MAAMD,OAAO,GAAG;EACdO,IAAI,EAAEC,GAAG,IAAIA,GAAG;EAChBC,QAAQ,EAAE,MAAM,CAAC,CAAC;EAClBC,MAAM,EAAEC,GAAG,IAAIA,GAAG,CAACX;AACrB,CAAC;AACDL,OAAO,CAACK,OAAO,GAAGA,OAAO"},"metadata":{},"sourceType":"script"}
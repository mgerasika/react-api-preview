{"ast":null,"code":"var _excluded = [\"name\", \"getCustomErrorMessage\"];\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { CONST } from '../constants/const.constant.js';\nimport { FormAdditionalContext } from '../general-ui/form/form.component.js';\nimport { useContext, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { useFormContext } from 'react-hook-form';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// Why use this code instead register method -> forwardRef problem with antd - works ok with native inputs but with antd have troubles - manually fire event.\n// also discussion about problem with ref https://stackoverflow.com/questions/58703615/react-hook-form-with-antd-styling\nvar useField = function useField(_ref) {\n  var name = _ref.name,\n    getCustomErrorMessage = _ref.getCustomErrorMessage,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  var formContext = useFormContext();\n  var _formContext$formStat = formContext.formState,\n    fieldsErrors = _formContext$formStat.errors,\n    touchedFields = _formContext$formStat.touchedFields,\n    register = formContext.register,\n    unregister = formContext.unregister,\n    watch = formContext.watch,\n    trigger = formContext.trigger,\n    setValue = formContext.setValue;\n  var formAdditionalContext = useContext(FormAdditionalContext);\n  var registerProps = register(name, _objectSpread(_objectSpread({}, rest), getCustomErrorMessage ? getCustomErrorMessage(getDefaultValidationMessages(rest)) : getDefaultValidationMessages(rest)));\n  var onFieldBlur = formAdditionalContext.onFieldBlur,\n    onFieldChange = formAdditionalContext.onFieldChange,\n    registerBlurHandler = formAdditionalContext.registerBlurHandler;\n  var onBlur = registerProps.onBlur;\n  useEffect(function () {\n    registerBlurHandler(name, onBlur);\n  }, [registerBlurHandler, name, onBlur]);\n  var fieldValue = watch(name);\n  var valueRef = useRef(fieldValue);\n  valueRef.current = fieldValue;\n  useEffect(function () {\n    return function () {\n      return unregister(name);\n    };\n  }, [name, unregister]);\n  var triggerValidate = useCallback(function () {\n    trigger(name);\n  }, [trigger, name]);\n  var setFieldValue = useCallback(function (newValue) {\n    if (valueRef.current !== newValue) {\n      valueRef.current = newValue;\n      setValue(name, newValue);\n      onFieldChange(name);\n    }\n  }, [name, onFieldChange, setValue]);\n  var setFieldTouched = useCallback(function () {\n    // don't forget pass name to onBlur event. If missed - touched don't work correctly\n    // if call manually - don't forget add type='blur'\n    onBlur({\n      type: 'blur',\n      target: {\n        name: name,\n        value: valueRef.current\n      }\n    });\n    if (valueRef.current && typeof valueRef.current === 'string') {\n      setValue(name, valueRef.current.trim());\n    }\n    onFieldBlur(name);\n  }, [name, onBlur, onFieldBlur, setValue]);\n  var fieldError = fieldsErrors[name];\n  var fieldIsTouched = touchedFields ? touchedFields[name] : false;\n  var fieldErrorMessage = fieldIsTouched && fieldError !== null && fieldError !== void 0 && fieldError.type ? fieldError.message : undefined;\n  return useMemo(function () {\n    return {\n      value: fieldValue,\n      triggerValidate: triggerValidate,\n      setFieldValue: setFieldValue,\n      setFieldTouched: setFieldTouched,\n      errorMessage: fieldErrorMessage\n    };\n  }, [fieldValue, triggerValidate, setFieldValue, setFieldTouched, fieldErrorMessage]);\n};\nvar getDefaultValidationMessages = function getDefaultValidationMessages(_ref2) {\n  var required = _ref2.required,\n    minLength = _ref2.minLength,\n    maxLength = _ref2.maxLength,\n    min = _ref2.min,\n    max = _ref2.max;\n  var result = {};\n  if (required) {\n    result.required = CONST.thisFieldRequired;\n  }\n  if (maxLength !== undefined && maxLength > 0) {\n    result.maxLength = {\n      value: maxLength,\n      message: \"This field too long (at least \".concat(maxLength, \" characters)\")\n    };\n  }\n  if (max !== undefined && max > 0) {\n    result.max = {\n      value: max,\n      message: \"This number too big (max \".concat(max, \")\")\n    };\n  }\n  if (min !== undefined) {\n    result.min = {\n      value: min,\n      message: \"This number too short (min \".concat(min, \")\")\n    };\n  }\n  if (minLength !== undefined && minLength > 0) {\n    result.minLength = {\n      value: minLength,\n      message: \"This field too short (at least \".concat(minLength, \" characters)\")\n    };\n  }\n  result.pattern = {\n    value: /^[/`/\\t/\\n/\\r a-zA-Z0-9/[/$/€/&/+/,/:/;/”/“/=/?/@/#/|/'/</>/./^/*/(/)/%/!/\\\\//{/}///-/\"/'_\\]\\-~£]*$/g,\n    message: 'Only latin symbols allowed'\n  };\n  return result;\n};\nexport { useField };","map":{"version":3,"sources":["../../../src/hooks/use-field.hook.ts"],"names":["useField","name","getCustomErrorMessage","rest","formContext","useFormContext","formState","errors","fieldsErrors","touchedFields","register","unregister","watch","trigger","setValue","formAdditionalContext","useContext","FormAdditionalContext","registerProps","getDefaultValidationMessages","onFieldBlur","onFieldChange","registerBlurHandler","onBlur","useEffect","fieldValue","valueRef","useRef","current","triggerValidate","useCallback","setFieldValue","newValue","setFieldTouched","type","target","value","trim","fieldError","fieldIsTouched","fieldErrorMessage","message","undefined","useMemo","errorMessage","required","minLength","maxLength","min","max","result","CONST","thisFieldRequired","pattern"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { CONST } from '@common/constants/const.constant';\nimport { FormAdditionalContext, IFormAdditionalContextProps } from '@common/general-ui/form/form.component';\nimport { IDictionary } from '@common/interfaces/dictionary.interface';\nimport { useCallback, useContext, useEffect, useMemo, useRef } from 'react';\nimport { RegisterOptions, useFormContext, ValidationRule } from 'react-hook-form';\n\ninterface IUseFieldReturn<T> {\n    errorMessage: string | undefined;\n    setFieldValue: (newValue: T) => void;\n    setFieldTouched: () => void;\n    triggerValidate: () => void;\n    value: T;\n}\n\ninterface IProps extends RegisterOptions {\n    name: any;\n    getCustomErrorMessage: ((opts: RegisterOptions) => RegisterOptions) | undefined;\n}\n\n// Why use this code instead register method -> forwardRef problem with antd - works ok with native inputs but with antd have troubles - manually fire event.\n// also discussion about problem with ref https://stackoverflow.com/questions/58703615/react-hook-form-with-antd-styling\nexport const useField = <T>({ name, getCustomErrorMessage, ...rest }: IProps): IUseFieldReturn<T> => {\n    const formContext = useFormContext<T>();\n    const {\n        formState: { errors: fieldsErrors, touchedFields },\n        register, // onChange, onBlur, name, ref!!!\n        unregister,\n        watch,\n        trigger,\n        setValue,\n    } = formContext;\n\n    const formAdditionalContext = useContext<IFormAdditionalContextProps<any>>(FormAdditionalContext);\n    const registerProps = register(name, {\n        ...rest,\n        ...(getCustomErrorMessage\n            ? getCustomErrorMessage(getDefaultValidationMessages(rest))\n            : getDefaultValidationMessages(rest)),\n    });\n\n    const { onFieldBlur, onFieldChange, registerBlurHandler } = formAdditionalContext;\n    const { onBlur } = registerProps;\n    useEffect(() => {\n        registerBlurHandler(name, onBlur);\n    }, [registerBlurHandler, name, onBlur]);\n\n    const fieldValue = watch(name);\n    const valueRef = useRef<any>(fieldValue);\n    valueRef.current = fieldValue;\n\n    useEffect(() => {\n        return (): void => unregister(name);\n    }, [name, unregister]);\n    const triggerValidate = useCallback(() => {\n        trigger(name);\n    }, [trigger, name]);\n\n    const setFieldValue = useCallback(\n        (newValue: T) => {\n            if (valueRef.current !== newValue) {\n                valueRef.current = newValue;\n                setValue(name, newValue as any);\n                onFieldChange(name as string);\n            }\n        },\n        [name, onFieldChange, setValue],\n    );\n\n    const setFieldTouched = useCallback(() => {\n        // don't forget pass name to onBlur event. If missed - touched don't work correctly\n        // if call manually - don't forget add type='blur'\n        onBlur({\n            type: 'blur',\n            target: {\n                name,\n                value: valueRef.current,\n            },\n        });\n        if (valueRef.current && typeof valueRef.current === 'string') {\n            setValue(name, (valueRef.current as any).trim());\n        }\n        onFieldBlur(name as string);\n    }, [name, onBlur, onFieldBlur, setValue]);\n\n    const fieldError = (fieldsErrors as IDictionary<any>)[name];\n    const fieldIsTouched = touchedFields ? (touchedFields as IDictionary<any>)[name] : false;\n    const fieldErrorMessage = fieldIsTouched && fieldError?.type ? fieldError.message : undefined;\n    return useMemo(() => {\n        return {\n            value: fieldValue as T,\n            triggerValidate,\n            setFieldValue,\n            setFieldTouched,\n\n            errorMessage: fieldErrorMessage,\n        };\n    }, [fieldValue, triggerValidate, setFieldValue, setFieldTouched, fieldErrorMessage]);\n};\n\nconst getDefaultValidationMessages = ({ required, minLength, maxLength, min, max }: RegisterOptions): RegisterOptions => {\n    const result: RegisterOptions = {} as RegisterOptions;\n    if (required) {\n        result.required = CONST.thisFieldRequired;\n    }\n    if (maxLength !== undefined && maxLength > 0) {\n        result.maxLength = {\n            value: maxLength,\n            message: `This field too long (at least ${maxLength} characters)`,\n        } as ValidationRule<number>;\n    }\n    if (max !== undefined && max > 0) {\n        result.max = {\n            value: max,\n            message: `This number too big (max ${max})`,\n        } as ValidationRule<number>;\n    }\n    if (min !== undefined) {\n        result.min = {\n            value: min,\n            message: `This number too short (min ${min})`,\n        } as ValidationRule<number>;\n    }\n    if (minLength !== undefined && minLength > 0) {\n        result.minLength = {\n            value: minLength,\n            message: `This field too short (at least ${minLength} characters)`,\n        } as ValidationRule<number>;\n    }\n    result.pattern = {\n        value: /^[/`/\\t/\\n/\\r a-zA-Z0-9/[/$/€/&/+/,/:/;/”/“/=/?/@/#/|/'/</>/./^/*/(/)/%/!/\\\\//{/}///-/\"/'_\\]\\-~£]*$/g,\n        message: 'Only latin symbols allowed',\n    };\n    return result;\n};\n"]},"metadata":{},"sourceType":"module"}
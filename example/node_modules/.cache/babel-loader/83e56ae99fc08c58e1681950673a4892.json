{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _generated = require(\"../validators/generated\");\nvar _generated2 = require(\"../builders/generated\");\nvar _default = toStatement;\nexports.default = _default;\nfunction toStatement(node, ignore) {\n  if ((0, _generated.isStatement)(node)) {\n    return node;\n  }\n  let mustHaveId = false;\n  let newType;\n  if ((0, _generated.isClass)(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if ((0, _generated.isFunction)(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if ((0, _generated.isAssignmentExpression)(node)) {\n    return (0, _generated2.expressionStatement)(node);\n  }\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n  node.type = newType;\n  return node;\n}","map":{"version":3,"sources":["../../src/converters/toStatement.ts"],"names":["toStatement","node","ignore","mustHaveId","newType","id","Error","type"],"mappings":";;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,yBAAA,CAAA;AAMA,IAAA,WAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;eAGeA,W;;AAgBf,SAASA,WAAT,CAAqBC,IAArB,EAAmCC,MAAnC,EAA0E;EACxE,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,WAAA,EAAYD,IAAZ,CAAJ,EAAuB;IACrB,OAAOA,IAAP;EACD;EAED,IAAIE,UAAU,GAAG,KAAjB;EACA,IAAIC,OAAJ;EAEA,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,OAAA,EAAQH,IAAR,CAAJ,EAAmB;IACjBE,UAAU,GAAG,IAAbA;IACAC,OAAO,GAAG,kBAAVA;EACD,CAHD,MAGO,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,UAAA,EAAWH,IAAX,CAAJ,EAAsB;IAC3BE,UAAU,GAAG,IAAbA;IACAC,OAAO,GAAG,qBAAVA;EACD,CAHM,MAGA,IAAI,CAAA,CAAA,EAAA,UAAA,CAAA,sBAAA,EAAuBH,IAAvB,CAAJ,EAAkC;IACvC,OAAO,CAAA,CAAA,EAAA,WAAA,CAAA,mBAAA,EAAoBA,IAApB,CAAP;EACD;EAGD,IAAIE,UAAU,IAAI,CAACF,IAAI,CAACI,EAAxB,EAA4B;IAC1BD,OAAO,GAAG,KAAVA;EACD;EAED,IAAI,CAACA,OAAL,EAAc;IACZ,IAAIF,MAAJ,EAAY;MACV,OAAO,KAAP;IACD,CAFD,MAEO;MACL,MAAM,IAAII,KAAJ,CAAW,eAAcL,IAAI,CAACM,IAAK,iBAAnC,CAAN;IACD;EACF;EAGDN,IAAI,CAACM,IAALN,GAAYG,OAAZH;EAGA,OAAOA,IAAP;AACD","sourcesContent":["import {\n  isStatement,\n  isFunction,\n  isClass,\n  isAssignmentExpression,\n} from \"../validators/generated\";\nimport { expressionStatement } from \"../builders/generated\";\nimport type * as t from \"..\";\n\nexport default toStatement as {\n  (node: t.AssignmentExpression, ignore?: boolean): t.ExpressionStatement;\n\n  <T extends t.Statement>(node: T, ignore: false): T;\n  <T extends t.Statement>(node: T, ignore?: boolean): T | false;\n\n  (node: t.Class, ignore: false): t.ClassDeclaration;\n  (node: t.Class, ignore?: boolean): t.ClassDeclaration | false;\n\n  (node: t.Function, ignore: false): t.FunctionDeclaration;\n  (node: t.Function, ignore?: boolean): t.FunctionDeclaration | false;\n\n  (node: t.Node, ignore: false): t.Statement;\n  (node: t.Node, ignore?: boolean): t.Statement | false;\n};\n\nfunction toStatement(node: t.Node, ignore?: boolean): t.Statement | false {\n  if (isStatement(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if (isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\" as const;\n  } else if (isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\" as const;\n  } else if (isAssignmentExpression(node)) {\n    return expressionStatement(node);\n  }\n\n  // @ts-expect-error todo(flow->ts): node.id might be missing\n  if (mustHaveId && !node.id) {\n    newType = false as false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  // @ts-expect-error manipulating node.type\n  node.type = newType;\n\n  // @ts-expect-error todo(flow->ts) refactor to avoid type unsafe mutations like reassigning node type above\n  return node;\n}\n"]},"metadata":{},"sourceType":"script"}
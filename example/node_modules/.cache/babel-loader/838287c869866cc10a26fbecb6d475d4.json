{"ast":null,"code":"import { toHex } from \"@aws-sdk/util-hex-encoding\";\n/**\n * A lossless representation of a signed, 64-bit integer. Instances of this\n * class may be used in arithmetic expressions as if they were numeric\n * primitives, but the binary representation will be preserved unchanged as the\n * `bytes` property of the object. The bytes should be encoded as big-endian,\n * two's complement integers.\n */\nvar Int64 = /** @class */function () {\n  function Int64(bytes) {\n    this.bytes = bytes;\n    if (bytes.byteLength !== 8) {\n      throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n    }\n  }\n  Int64.fromNumber = function (number) {\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\n      throw new Error(number + \" is too large (or, if negative, too small) to represent as an Int64\");\n    }\n    var bytes = new Uint8Array(8);\n    for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n    if (number < 0) {\n      negate(bytes);\n    }\n    return new Int64(bytes);\n  };\n  /**\n   * Called implicitly by infix arithmetic operators.\n   */\n  Int64.prototype.valueOf = function () {\n    var bytes = this.bytes.slice(0);\n    var negative = bytes[0] & 128;\n    if (negative) {\n      negate(bytes);\n    }\n    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n  };\n  Int64.prototype.toString = function () {\n    return String(this.valueOf());\n  };\n  return Int64;\n}();\nexport { Int64 };\nfunction negate(bytes) {\n  for (var i = 0; i < 8; i++) {\n    bytes[i] ^= 0xff;\n  }\n  for (var i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}","map":{"version":3,"sources":["../../src/Int64.ts"],"names":[],"mappings":"AACA,SAAS,KAAK,QAAQ,4BAA4B;AAIlD;;;;;;AAMG;AACH,IAAA,KAAA,GAAA,aAAA,YAAA;EACE,SAAA,KAAA,CAAqB,KAAiB,EAAA;IAAjB,IAAA,CAAA,KAAK,GAAL,KAAK;IACxB,IAAI,KAAK,CAAC,UAAU,KAAK,CAAC,EAAE;MAC1B,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC;IACzD;EACH;EAEO,KAAA,CAAA,UAAU,GAAjB,UAAkB,MAAc,EAAA;IAC9B,IAAI,MAAM,GAAG,mBAAmB,IAAI,MAAM,GAAG,CAAC,mBAAmB,EAAE;MACjE,MAAM,IAAI,KAAK,CAAI,MAAM,GAAA,qEAAqE,CAAC;IAChG;IAED,IAAM,KAAK,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC;IAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,SAAS,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,SAAS,IAAI,GAAG,EAAE;MACxG,KAAK,CAAC,CAAC,CAAC,GAAG,SAAS;IACrB;IAED,IAAI,MAAM,GAAG,CAAC,EAAE;MACd,MAAM,CAAC,KAAK,CAAC;IACd;IAED,OAAO,IAAI,KAAK,CAAC,KAAK,CAAC;EACzB,CAAC;EAED;;AAEG;EACH,KAAA,CAAA,SAAA,CAAA,OAAO,GAAP,YAAA;IACE,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;IACjC,IAAM,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,GAAU;IACtC,IAAI,QAAQ,EAAE;MACZ,MAAM,CAAC,KAAK,CAAC;IACd;IAED,OAAO,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,IAAI,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;EACzD,CAAC;EAED,KAAA,CAAA,SAAA,CAAA,QAAQ,GAAR,YAAA;IACE,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;EAC/B,CAAC;EACH,OAAA,KAAC;AAAD,CAAC,EAAA;;AAED,SAAS,MAAM,CAAC,KAAiB,EAAA;EAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;IAC1B,KAAK,CAAC,CAAC,CAAC,IAAI,IAAI;EACjB;EAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;IAC3B,KAAK,CAAC,CAAC,CAAC,EAAE;IACV,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;EACrB;AACH","sourcesContent":["import { Int64 as IInt64 } from \"@aws-sdk/types\";\nimport { toHex } from \"@aws-sdk/util-hex-encoding\";\n\nexport interface Int64 extends IInt64 {}\n\n/**\n * A lossless representation of a signed, 64-bit integer. Instances of this\n * class may be used in arithmetic expressions as if they were numeric\n * primitives, but the binary representation will be preserved unchanged as the\n * `bytes` property of the object. The bytes should be encoded as big-endian,\n * two's complement integers.\n */\nexport class Int64 {\n  constructor(readonly bytes: Uint8Array) {\n    if (bytes.byteLength !== 8) {\n      throw new Error(\"Int64 buffers must be exactly 8 bytes\");\n    }\n  }\n\n  static fromNumber(number: number): Int64 {\n    if (number > 9223372036854775807 || number < -9223372036854775808) {\n      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);\n    }\n\n    const bytes = new Uint8Array(8);\n    for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {\n      bytes[i] = remaining;\n    }\n\n    if (number < 0) {\n      negate(bytes);\n    }\n\n    return new Int64(bytes);\n  }\n\n  /**\n   * Called implicitly by infix arithmetic operators.\n   */\n  valueOf(): number {\n    const bytes = this.bytes.slice(0);\n    const negative = bytes[0] & 0b10000000;\n    if (negative) {\n      negate(bytes);\n    }\n\n    return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);\n  }\n\n  toString() {\n    return String(this.valueOf());\n  }\n}\n\nfunction negate(bytes: Uint8Array): void {\n  for (let i = 0; i < 8; i++) {\n    bytes[i] ^= 0xff;\n  }\n\n  for (let i = 7; i > -1; i--) {\n    bytes[i]++;\n    if (bytes[i] !== 0) break;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
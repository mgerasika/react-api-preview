{"ast":null,"code":"import { __asyncGenerator, __await, __generator } from \"tslib\";\nexport function getChunkedStream(source) {\n  var _a;\n  var currentMessageTotalLength = 0;\n  var currentMessagePendingLength = 0;\n  var currentMessage = null;\n  var messageLengthBuffer = null;\n  var allocateMessage = function (size) {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    var currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  var iterator = function () {\n    return __asyncGenerator(this, arguments, function () {\n      var sourceIterator, _a, value, done, chunkLength, currentOffset, bytesRemaining, numBytesForTotal, numBytesToWrite;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            sourceIterator = source[Symbol.asyncIterator]();\n            _b.label = 1;\n          case 1:\n            if (!true) return [3 /*break*/, 16];\n            return [4 /*yield*/, __await(sourceIterator.next())];\n          case 2:\n            _a = _b.sent(), value = _a.value, done = _a.done;\n            if (!done) return [3 /*break*/, 10];\n            if (!!currentMessageTotalLength) return [3 /*break*/, 4];\n            return [4 /*yield*/, __await(void 0)];\n          case 3:\n            return [2 /*return*/, _b.sent()];\n          case 4:\n            if (!(currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 7];\n            return [4 /*yield*/, __await(currentMessage)];\n          case 5:\n            return [4 /*yield*/, _b.sent()];\n          case 6:\n            _b.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            throw new Error(\"Truncated event message received.\");\n          case 8:\n            return [4 /*yield*/, __await(void 0)];\n          case 9:\n            return [2 /*return*/, _b.sent()];\n          case 10:\n            chunkLength = value.length;\n            currentOffset = 0;\n            _b.label = 11;\n          case 11:\n            if (!(currentOffset < chunkLength)) return [3 /*break*/, 15];\n            // create new message if necessary\n            if (!currentMessage) {\n              bytesRemaining = chunkLength - currentOffset;\n              // prevent edge case where total length spans 2 chunks\n              if (!messageLengthBuffer) {\n                messageLengthBuffer = new Uint8Array(4);\n              }\n              numBytesForTotal = Math.min(4 - currentMessagePendingLength,\n              // remaining bytes to fill the messageLengthBuffer\n              bytesRemaining // bytes left in chunk\n              );\n\n              messageLengthBuffer.set(\n              // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n              value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);\n              currentMessagePendingLength += numBytesForTotal;\n              currentOffset += numBytesForTotal;\n              if (currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                return [3 /*break*/, 15];\n              }\n              allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n              messageLengthBuffer = null;\n            }\n            numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength,\n            // number of bytes left to complete message\n            chunkLength - currentOffset // number of bytes left in the original chunk\n            );\n\n            currentMessage.set(\n            // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);\n            currentMessagePendingLength += numBytesToWrite;\n            currentOffset += numBytesToWrite;\n            if (!(currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength)) return [3 /*break*/, 14];\n            return [4 /*yield*/, __await(currentMessage)];\n          case 12:\n            // push out the message\n            return [4 /*yield*/, _b.sent()];\n          case 13:\n            // push out the message\n            _b.sent();\n            // cleanup\n            currentMessage = null;\n            currentMessageTotalLength = 0;\n            currentMessagePendingLength = 0;\n            _b.label = 14;\n          case 14:\n            return [3 /*break*/, 11];\n          case 15:\n            return [3 /*break*/, 1];\n          case 16:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  return _a = {}, _a[Symbol.asyncIterator] = iterator, _a;\n}","map":{"version":3,"sources":["../../src/getChunkedStream.ts"],"names":[],"mappings":"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","sourcesContent":["export function getChunkedStream(source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array> {\n  let currentMessageTotalLength = 0;\n  let currentMessagePendingLength = 0;\n  let currentMessage: Uint8Array | null = null;\n  let messageLengthBuffer: Uint8Array | null = null;\n  const allocateMessage = (size: number) => {\n    if (typeof size !== \"number\") {\n      throw new Error(\"Attempted to allocate an event message where size was not a number: \" + size);\n    }\n    currentMessageTotalLength = size;\n    currentMessagePendingLength = 4;\n    currentMessage = new Uint8Array(size);\n    const currentMessageView = new DataView(currentMessage.buffer);\n    currentMessageView.setUint32(0, size, false); //set big-endian Uint32 to 0~3 bytes\n  };\n\n  const iterator = async function* () {\n    const sourceIterator = source[Symbol.asyncIterator]();\n    while (true) {\n      const { value, done } = await sourceIterator.next();\n      if (done) {\n        if (!currentMessageTotalLength) {\n          return;\n        } else if (currentMessageTotalLength === currentMessagePendingLength) {\n          yield currentMessage as Uint8Array;\n        } else {\n          throw new Error(\"Truncated event message received.\");\n        }\n        return;\n      }\n\n      const chunkLength = value.length;\n      let currentOffset = 0;\n\n      while (currentOffset < chunkLength) {\n        // create new message if necessary\n        if (!currentMessage) {\n          // working on a new message, determine total length\n          const bytesRemaining = chunkLength - currentOffset;\n          // prevent edge case where total length spans 2 chunks\n          if (!messageLengthBuffer) {\n            messageLengthBuffer = new Uint8Array(4);\n          }\n          const numBytesForTotal = Math.min(\n            4 - currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n            bytesRemaining // bytes left in chunk\n          );\n\n          messageLengthBuffer.set(\n            // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n            value.slice(currentOffset, currentOffset + numBytesForTotal),\n            currentMessagePendingLength\n          );\n\n          currentMessagePendingLength += numBytesForTotal;\n          currentOffset += numBytesForTotal;\n\n          if (currentMessagePendingLength < 4) {\n            // not enough information to create the current message\n            break;\n          }\n          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));\n          messageLengthBuffer = null;\n        }\n\n        // write data into current message\n        const numBytesToWrite = Math.min(\n          currentMessageTotalLength - currentMessagePendingLength, // number of bytes left to complete message\n          chunkLength - currentOffset // number of bytes left in the original chunk\n        );\n        currentMessage!.set(\n          // @ts-ignore error TS2532: Object is possibly 'undefined' for value\n          value.slice(currentOffset, currentOffset + numBytesToWrite),\n          currentMessagePendingLength\n        );\n        currentMessagePendingLength += numBytesToWrite;\n        currentOffset += numBytesToWrite;\n\n        // check if a message is ready to be pushed\n        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {\n          // push out the message\n          yield currentMessage as Uint8Array;\n          // cleanup\n          currentMessage = null;\n          currentMessageTotalLength = 0;\n          currentMessagePendingLength = 0;\n        }\n      }\n    }\n  };\n\n  return {\n    [Symbol.asyncIterator]: iterator,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}
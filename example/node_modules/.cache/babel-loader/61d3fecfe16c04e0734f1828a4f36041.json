{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\nvar _is = require(\"../validators/is\");\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nvar _helperStringParser = require(\"@babel/helper-string-parser\");\nvar _constants = require(\"../constants\");\nvar _utils = require(\"./utils\");\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\nconst functionCommon = () => ({\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n});\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = () => Object.assign({}, functionCommon(), {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\", \"using\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\", \"LVal\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"TSDeclareFunction\", \"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSSatisfiesExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    module: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n          case \"new\":\n            property = \"target\";\n            break;\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\"))\n  }\n});\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        const raw = node.value.raw;\n        let unterminatedCalled = false;\n        const error = () => {\n          throw new Error(\"Internal @babel/types error.\");\n        };\n        const {\n          str,\n          firstInvalidLoc\n        } = (0, _helperStringParser.readStringContents)(\"template\", raw, 0, 0, 0, {\n          unterminated() {\n            unterminatedCalled = true;\n          },\n          strictNumericEscape: error,\n          invalidEscapeSequence: error,\n          numericSeparatorInEscapeSequence: error,\n          unexpectedNumericSeparator: error,\n          invalidDigit: error,\n          invalidCodePoint: error\n        });\n        if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n        node.value.cooked = firstInvalidLoc ? null : str;\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    static: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\"),\n      default: \"method\"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});","map":{"version":3,"sources":["../../src/definitions/core.ts"],"names":["defineType","fields","elements","validate","default","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","ASSIGNMENT_OPERATORS","pattern","node","key","val","validator","left","right","builder","BINARY_OPERATORS","expression","inOp","assign","oneOfNodeTypes","value","directives","body","label","optional","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","functionCommon","params","generator","async","functionTypeAnnotationCommon","returnType","functionDeclarationCommon","declare","id","predicate","parent","inherits","patternLikeCommon","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","implements","mixins","abstract","source","exportKind","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","await","module","importKind","classMethodOrPropertyCommon","accessibility","static","override","classMethodOrDeclareMethodCommon","access","tag","quasi","raw","cooked","templateElementCookedValidator","unterminatedCalled","error","str","firstInvalidLoc","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","tail","quasis","delegate","readonly","variance"],"mappings":"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","sourcesContent":["import is from \"../validators/is\";\nimport isValidIdentifier from \"../validators/isValidIdentifier\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"..\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  type Validator,\n} from \"./utils\";\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n        ),\n      ),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: (function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return assertValueType(\"string\");\n        }\n\n        const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n        const pattern = assertOneOf(\"=\");\n\n        return function (node: t.AssignmentExpression, key, val) {\n          const validator = is(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      })(),\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"LVal\")\n        : assertNodeType(\n            \"Identifier\",\n            \"MemberExpression\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSTypeAssertion\",\n            \"TSNonNullExpression\",\n          ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } as Validator,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Directive\")),\n      ),\n      default: [],\n    },\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            \"SpreadElement\",\n            \"JSXNamespacedName\",\n            \"ArgumentPlaceholder\",\n          ),\n        ),\n      ),\n    },\n    ...(!process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertOneOf(true, false),\n            optional: true,\n          },\n        }\n      : {}),\n    typeArguments: {\n      validate: assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? Object.assign(() => {}, {\n            each: { oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"] },\n          })\n        : assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"VariableDeclaration\", \"LVal\")\n        : assertNodeType(\n            \"VariableDeclaration\",\n            \"Identifier\",\n            \"MemberExpression\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSTypeAssertion\",\n            \"TSNonNullExpression\",\n          ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(assertNodeType(\"Identifier\", \"Pattern\", \"RestElement\")),\n    ),\n  },\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  typeParameters: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\")\n      : assertNodeType(\n          \"TypeParameterDeclaration\",\n          \"TSTypeParameterDeclaration\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate: (function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n\n    const identifier = assertNodeType(\"Identifier\");\n\n    return function (parent, key, node) {\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: process.env.BABEL_8_BREAKING\n      ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n      : assertNodeType(\n          \"TypeAnnotation\",\n          \"TSTypeAnnotation\",\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          \"Noop\",\n        ),\n    optional: true,\n  },\n  decorators: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(assertNodeType(\"Decorator\")),\n    ),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            if (!isValidIdentifier(val, false)) {\n              throw new TypeError(`\"${val}\" is not a valid identifier name`);\n            }\n          } as Validator,\n          { type: \"string\" },\n        ),\n      ),\n    },\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n\n    const [, parentKey] = match;\n    const nonComp = { computed: false };\n\n    // We can't check if `parent.property === node`, because nodes are validated\n    // before replacing them in the AST.\n    if (parentKey === \"property\") {\n      if (is(\"MemberExpression\", parent, nonComp)) return;\n      if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if (is(\"Property\", parent, nonComp)) return;\n      if (is(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if (is(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n    } else if (parentKey === \"meta\") {\n      if (is(\"MetaProperty\", parent, { meta: node })) return;\n    }\n\n    if (\n      // Ideally we should call isStrictReservedWord if this node is a descendant\n      // of a block in strict mode. Also, we should pass the inModule option so\n      // we can disable \"await\" in module.\n      (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n      // Even if \"this\" is a keyword, we are using the Identifier\n      // node to represent it.\n      node.name !== \"this\"\n    ) {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  },\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: assertValueType(\"number\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            const invalid = /[^gimsuy]/.exec(val);\n            if (invalid) {\n              throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n            }\n          } as Validator,\n          { type: \"string\" },\n        ),\n      ),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\n    \"object\",\n    \"property\",\n    \"computed\",\n    ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : []),\n  ],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // @ts-expect-error todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    ...(!process.env.BABEL_TYPES_8_BREAKING\n      ? {\n          optional: {\n            validate: assertOneOf(true, false),\n            optional: true,\n          },\n        }\n      : {}),\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: assertValueType(\"string\"),\n    },\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Directive\")),\n      ),\n      default: [],\n    },\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\"),\n        ),\n      ),\n    },\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n      ...(!process.env.BABEL_TYPES_8_BREAKING ? { default: \"method\" } : {}),\n    },\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = function (node: t.ObjectMethod, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // @ts-expect-error todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  visitor: [\n    \"key\",\n    \"params\",\n    \"body\",\n    \"decorators\",\n    \"returnType\",\n    \"typeParameters\",\n  ],\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\n    \"key\",\n    \"value\",\n    \"computed\",\n    \"shorthand\",\n    ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : []),\n  ],\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"DecimalLiteral\",\n          \"PrivateName\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } as Validator,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: [\n              \"Expression\",\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"DecimalLiteral\",\n              \"PrivateName\",\n            ],\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            if (val && node.computed) {\n              throw new TypeError(\n                \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n              );\n            }\n          } as Validator,\n          { type: \"boolean\" },\n        ),\n        function (node: t.ObjectProperty, key, val) {\n          if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n          if (val && !is(\"Identifier\", node.key)) {\n            throw new TypeError(\n              \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n            );\n          }\n        } as Validator,\n      ),\n      default: false,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: (function () {\n    const pattern = assertNodeType(\n      \"Identifier\",\n      \"Pattern\",\n      \"TSAsExpression\",\n      \"TSSatisfiesExpression\",\n      \"TSNonNullExpression\",\n      \"TSTypeAssertion\",\n    );\n    const expression = assertNodeType(\"Expression\");\n\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      const validator = is(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"LVal\")\n        : assertNodeType(\n            \"Identifier\",\n            \"ArrayPattern\",\n            \"ObjectPattern\",\n            \"MemberExpression\",\n            \"TSAsExpression\",\n            \"TSSatisfiesExpression\",\n            \"TSTypeAssertion\",\n            \"TSNonNullExpression\",\n          ),\n    },\n    // For Flow\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate(parent: t.ArrayPattern | t.ObjectPattern, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n    const [, listKey, index] = match as unknown as [\n      string,\n      keyof typeof parent,\n      string,\n    ];\n    if ((parent[listKey] as t.Node[]).length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  },\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Expression\")),\n      ),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"SwitchCase\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: chain(\n        assertNodeType(\"BlockStatement\"),\n        Object.assign(\n          function (node: t.TryStatement) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (!node.handler && !node.finalizer) {\n              throw new TypeError(\n                \"TryStatement expects either a handler or finalizer, or both\",\n              );\n            }\n          } as Validator,\n          {\n            oneOfNodeTypes: [\"BlockStatement\"],\n          },\n        ),\n      ),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertNodeType(\"Expression\")\n        : assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n      ),\n    },\n    declarations: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"VariableDeclarator\")),\n      ),\n    },\n  },\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n    if (!is(\"ForXStatement\", parent, { left: node })) return;\n    if (node.declarations.length !== 1) {\n      throw new TypeError(\n        `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n      );\n    }\n  },\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: (function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return assertNodeType(\"LVal\");\n        }\n\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n        );\n        const without = assertNodeType(\"Identifier\");\n\n        return function (node: t.VariableDeclarator, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      })(),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\", \"LVal\")),\n      ),\n    },\n    // For TypeScript\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"ClassMethod\",\n            \"ClassPrivateMethod\",\n            \"ClassProperty\",\n            \"ClassPrivateProperty\",\n            \"ClassAccessorProperty\",\n            \"TSDeclareMethod\",\n            \"TSIndexSignature\",\n            \"StaticBlock\",\n          ),\n        ),\n      ),\n    },\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"id\",\n    \"body\",\n    \"superClass\",\n    \"mixins\",\n    \"typeParameters\",\n    \"superTypeParameters\",\n    \"implements\",\n    \"decorators\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // In declarations, this is missing if this is the\n      // child of an ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    superTypeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n        ),\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    typeParameters: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n          )\n        : assertNodeType(\n            \"TypeParameterDeclaration\",\n            \"TSTypeParameterDeclaration\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    superTypeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\"TSExpressionWithTypeArguments\", \"ClassImplements\"),\n        ),\n      ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate: (function () {\n    const identifier = assertNodeType(\"Identifier\");\n\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ModuleDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ModuleDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      validate: assertNodeType(\n        \"TSDeclareFunction\",\n        \"FunctionDeclaration\",\n        \"ClassDeclaration\",\n        \"Expression\",\n      ),\n    },\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ModuleDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: chain(\n        assertNodeType(\"Declaration\"),\n        Object.assign(\n          function (node: t.ExportNamedDeclaration, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (val && node.specifiers.length) {\n              throw new TypeError(\n                \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n              );\n            }\n          } as Validator,\n          { oneOfNodeTypes: [\"Declaration\"] },\n        ),\n        function (node: t.ExportNamedDeclaration, key, val) {\n          if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n          // This validator isn't put at the top level because we can run it\n          // even if this node doesn't have a parent.\n\n          if (val && node.source) {\n            throw new TypeError(\"Cannot export a declaration from a source\");\n          }\n        },\n      ),\n    },\n    assertions: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    specifiers: {\n      default: [],\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          (function () {\n            const sourced = assertNodeType(\n              \"ExportSpecifier\",\n              \"ExportDefaultSpecifier\",\n              \"ExportNamespaceSpecifier\",\n            );\n            const sourceless = assertNodeType(\"ExportSpecifier\");\n\n            if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n\n            return function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } as Validator;\n          })(),\n        ),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return assertNodeType(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return function (node, key, val) {\n          if (is(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"ImportAttribute\")),\n      ),\n    },\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    specifiers: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"ImportSpecifier\",\n            \"ImportDefaultSpecifier\",\n            \"ImportNamespaceSpecifier\",\n          ),\n        ),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: chain(\n        assertNodeType(\"Identifier\"),\n        Object.assign(\n          function (node: t.MetaProperty, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            let property;\n            switch (val.name) {\n              case \"function\":\n                property = \"sent\";\n                break;\n              case \"new\":\n                property = \"target\";\n                break;\n              case \"import\":\n                property = \"meta\";\n                break;\n            }\n            if (!is(\"Identifier\", node.property, { name: property })) {\n              throw new TypeError(\"Unrecognised MetaProperty\");\n            }\n          } as Validator,\n          { oneOfNodeTypes: [\"Identifier\"] },\n        ),\n      ),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (node: any, key: string, val: any) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(\n        assertNodeType(\n          \"Identifier\",\n          \"Pattern\",\n          \"RestElement\",\n          \"TSParameterProperty\",\n        ),\n      ),\n    ),\n  },\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: chain(\n      assertValueType(\"array\"),\n      assertEach(assertNodeType(\"Decorator\")),\n    ),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"key\",\n    \"params\",\n    \"body\",\n    \"decorators\",\n    \"returnType\",\n    \"typeParameters\",\n  ],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"properties\",\n    \"typeAnnotation\",\n    \"decorators\" /* for legacy param decorators */,\n  ],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"RestElement\", \"ObjectProperty\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n  process.env.BABEL_8_BREAKING\n    ? undefined\n    : {\n        aliases: [\"Expression\"],\n      },\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TemplateElement\")),\n      ),\n    },\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } as Validator,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.YieldExpression, key, val) {\n            if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n            if (val && !node.argument) {\n              throw new TypeError(\n                \"Property delegate of YieldExpression cannot be true if there is no argument\",\n              );\n            }\n          } as Validator,\n          { type: \"boolean\" },\n        ),\n      ),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: Validator = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } as Validator,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertValueType(\"boolean\")\n        : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            \"SpreadElement\",\n            \"JSXNamespacedName\",\n            \"ArgumentPlaceholder\",\n          ),\n        ),\n      ),\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING\n        ? assertValueType(\"boolean\")\n        : chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: assertNodeType(\"TypeParameterInstantiation\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\"TSTypeParameterInstantiation\"),\n      optional: true,\n    },\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (node: any, key: string, val: any) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          };\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: process.env.BABEL_8_BREAKING\n        ? assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\")\n        : assertNodeType(\n            \"TypeAnnotation\",\n            \"TSTypeAnnotation\",\n            // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n            \"Noop\",\n          ),\n      optional: true,\n    },\n    decorators: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Decorator\")),\n      ),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"key\",\n    \"params\",\n    \"body\",\n    \"decorators\",\n    \"returnType\",\n    \"typeParameters\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"Statement\")),\n      ),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\n/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n    throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n  }\n  if (lat < -90 || 90 < lat) {\n    throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n  } else if (lng < -180 || 180 < lng) {\n    throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n  }\n}\nexport function validateGeofenceId(geofenceId) {\n  var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n  // Check if geofenceId is valid\n  if (!geofenceIdRegex.test(geofenceId)) {\n    throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n  }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n  // Validate LinearRing size, must be at least 4 points\n  if (linearRing.length < 4) {\n    throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n  }\n  // Validate all coordinates are valid, error with which ones are bad\n  var badCoordinates = [];\n  linearRing.forEach(function (coordinates) {\n    try {\n      validateCoordinates(coordinates[0], coordinates[1]);\n    } catch (error) {\n      badCoordinates.push({\n        coordinates: coordinates,\n        error: error.message\n      });\n    }\n  });\n  if (badCoordinates.length > 0) {\n    throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n  }\n  // Validate first and last coordinates are the same\n  var _a = __read(linearRing[0], 2),\n    lngA = _a[0],\n    latA = _a[1];\n  var _b = __read(linearRing[linearRing.length - 1], 2),\n    lngB = _b[0],\n    latB = _b[1];\n  if (lngA !== lngB || latA !== latB) {\n    throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n  }\n  if (booleanClockwise(linearRing)) {\n    throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n  }\n}\nexport function validatePolygon(polygon, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n  if (!Array.isArray(polygon)) {\n    throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n  }\n  if (polygon.length < 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n  }\n  if (polygon.length > 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n  }\n  var verticesCount = polygon.reduce(function (prev, linearRing) {\n    return prev + linearRing.length;\n  }, 0);\n  if (verticesCount > 1000) {\n    throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n  }\n  polygon.forEach(function (linearRing) {\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function validateGeofencesInput(geofences) {\n  var geofenceIds = {};\n  geofences.forEach(function (geofence) {\n    // verify all required properties are present\n    // Validate geofenceId exists\n    if (!geofence.geofenceId) {\n      throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n    }\n    var geofenceId = geofence.geofenceId;\n    validateGeofenceId(geofenceId);\n    // Validate geofenceId is unique\n    if (geofenceIds[geofenceId]) {\n      throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n    } else {\n      geofenceIds[geofenceId] = true;\n    }\n    // Validate geometry exists\n    if (!geofence.geometry) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n    }\n    var geometry = geofence.geometry;\n    // Validate polygon exists\n    if (!geometry.polygon) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n    }\n    var polygon = geometry.polygon;\n    // Validate polygon length and structure\n    try {\n      validatePolygon(polygon, geofenceId);\n    } catch (error) {\n      if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n        throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n      }\n    }\n    // Validate LinearRing length, structure, and coordinates\n    var _a = __read(polygon, 1),\n      linearRing = _a[0];\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n  var locationServiceModifiedInput = __assign({}, locationServiceInput);\n  locationServiceModifiedInput.FilterCountries = options.countries;\n  locationServiceModifiedInput.MaxResults = options.maxResults;\n  if (options.searchIndexName) {\n    locationServiceModifiedInput.IndexName = options.searchIndexName;\n  }\n  if (options['biasPosition'] && options['searchAreaConstraints']) {\n    throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n  }\n  if (options['biasPosition']) {\n    locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n  }\n  if (options['searchAreaConstraints']) {\n    locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n  }\n  return locationServiceModifiedInput;\n}","map":{"version":3,"sources":["../src/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n    if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n        throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n    }\n    if (lat < -90 || 90 < lat) {\n        throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n    }\n    else if (lng < -180 || 180 < lng) {\n        throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n    }\n}\nexport function validateGeofenceId(geofenceId) {\n    var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n    // Check if geofenceId is valid\n    if (!geofenceIdRegex.test(geofenceId)) {\n        throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n    }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n    var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n    // Validate LinearRing size, must be at least 4 points\n    if (linearRing.length < 4) {\n        throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n    }\n    // Validate all coordinates are valid, error with which ones are bad\n    var badCoordinates = [];\n    linearRing.forEach(function (coordinates) {\n        try {\n            validateCoordinates(coordinates[0], coordinates[1]);\n        }\n        catch (error) {\n            badCoordinates.push({ coordinates: coordinates, error: error.message });\n        }\n    });\n    if (badCoordinates.length > 0) {\n        throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n    }\n    // Validate first and last coordinates are the same\n    var _a = __read(linearRing[0], 2), lngA = _a[0], latA = _a[1];\n    var _b = __read(linearRing[linearRing.length - 1], 2), lngB = _b[0], latB = _b[1];\n    if (lngA !== lngB || latA !== latB) {\n        throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n    }\n    if (booleanClockwise(linearRing)) {\n        throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n    }\n}\nexport function validatePolygon(polygon, geofenceId) {\n    var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n    if (!Array.isArray(polygon)) {\n        throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n    }\n    if (polygon.length < 1) {\n        throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n    }\n    if (polygon.length > 1) {\n        throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n    }\n    var verticesCount = polygon.reduce(function (prev, linearRing) { return prev + linearRing.length; }, 0);\n    if (verticesCount > 1000) {\n        throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n    }\n    polygon.forEach(function (linearRing) {\n        validateLinearRing(linearRing, geofenceId);\n    });\n}\nexport function validateGeofencesInput(geofences) {\n    var geofenceIds = {};\n    geofences.forEach(function (geofence) {\n        // verify all required properties are present\n        // Validate geofenceId exists\n        if (!geofence.geofenceId) {\n            throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n        }\n        var geofenceId = geofence.geofenceId;\n        validateGeofenceId(geofenceId);\n        // Validate geofenceId is unique\n        if (geofenceIds[geofenceId]) {\n            throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n        }\n        else {\n            geofenceIds[geofenceId] = true;\n        }\n        // Validate geometry exists\n        if (!geofence.geometry) {\n            throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n        }\n        var geometry = geofence.geometry;\n        // Validate polygon exists\n        if (!geometry.polygon) {\n            throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n        }\n        var polygon = geometry.polygon;\n        // Validate polygon length and structure\n        try {\n            validatePolygon(polygon, geofenceId);\n        }\n        catch (error) {\n            if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n                throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n            }\n        }\n        // Validate LinearRing length, structure, and coordinates\n        var _a = __read(polygon, 1), linearRing = _a[0];\n        validateLinearRing(linearRing, geofenceId);\n    });\n}\nexport function mapSearchOptions(options, locationServiceInput) {\n    var locationServiceModifiedInput = __assign({}, locationServiceInput);\n    locationServiceModifiedInput.FilterCountries = options.countries;\n    locationServiceModifiedInput.MaxResults = options.maxResults;\n    if (options.searchIndexName) {\n        locationServiceModifiedInput.IndexName = options.searchIndexName;\n    }\n    if (options['biasPosition'] && options['searchAreaConstraints']) {\n        throw new Error('BiasPosition and SearchAreaConstraints are mutually exclusive, please remove one or the other from the options object');\n    }\n    if (options['biasPosition']) {\n        locationServiceModifiedInput.BiasPosition = options['biasPosition'];\n    }\n    if (options['searchAreaConstraints']) {\n        locationServiceModifiedInput.FilterBBox = options['searchAreaConstraints'];\n    }\n    return locationServiceModifiedInput;\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}
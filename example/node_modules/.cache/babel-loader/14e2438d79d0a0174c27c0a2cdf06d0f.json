{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.typeIs = typeIs;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\nvar _is = require(\"../validators/is\");\nvar _validate = require(\"../validators/validate\");\nconst VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nconst ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nconst FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nconst NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nconst BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nconst DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nconst NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType(...typeName);\n}\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\nfunction assertOneOf() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n  validate.oneOf = values;\n  return validate;\n}\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n  function validate(node, key, val) {\n    for (const type of types) {\n      if ((0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n  function validate(node, key, val) {\n    for (const type of types) {\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n    if (!valid) {\n      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n    }\n  }\n  validate.type = type;\n  return validate;\n}\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join(\"\\n\")}`);\n    }\n  }\n  validate.shapeOf = shape;\n  return validate;\n}\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n    let current = node;\n    while (node) {\n      const {\n        type\n      } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n      break;\n    }\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n  return validate;\n}\nfunction chain() {\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n  function validate() {\n    for (const fn of fns) {\n      fn(...arguments);\n    }\n  }\n  validate.chainOf = fns;\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(`An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`);\n  }\n  return validate;\n}\nconst validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nconst validFieldKeys = [\"default\", \"optional\", \"validate\"];\nfunction defineAliasedType() {\n  for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    aliases[_key5] = arguments[_key5];\n  }\n  return function (type) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let defined = opts.aliases;\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    return defineType(type, opts);\n  };\n}\nfunction defineType(type) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n          throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          validate: field.validate\n        };\n      }\n    }\n  }\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  store[type] = opts;\n}\nconst store = {};","map":{"version":3,"sources":["../../src/definitions/utils.ts"],"names":["VISITOR_KEYS","ALIAS_KEYS","FLIPPED_ALIAS_KEYS","NODE_FIELDS","BUILDER_KEYS","DEPRECATED_KEYS","NODE_PARENT_VALIDATIONS","getType","val","Array","isArray","validate","typeIs","typeName","assertNodeType","validateType","validateOptional","optional","validateOptionalType","arrayOf","elementType","chain","assertValueType","assertEach","arrayOfType","validateArrayOfType","callback","validator","node","key","i","length","subkey","v","process","env","BABEL_TYPES_8_BREAKING","each","assertOneOf","values","indexOf","TypeError","JSON","stringify","oneOf","types","type","oneOfNodeTypes","assertNodeOrValueType","oneOfNodeOrValueTypes","valid","assertShape","shape","errors","property","Object","keys","error","push","message","join","shapeOf","assertOptionalChainStart","current","callee","object","fns","fn","chainOf","Error","validTypeOpts","validFieldKeys","defineAliasedType","aliases","opts","defined","inherits","store","slice","additional","filter","a","includes","unshift","defineType","fields","getOwnPropertyNames","field","def","default","visitor","builder","k","deprecatedAlias","concat","undefined","forEach","alias"],"mappings":"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","sourcesContent":["import is from \"../validators/is\";\nimport { validateField, validateChild } from \"../validators/validate\";\nimport type * as t from \"..\";\n\nexport const VISITOR_KEYS: Record<string, string[]> = {};\nexport const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>> =\n  {};\nexport const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]> = {};\nexport const NODE_FIELDS: Record<string, FieldDefinitions> = {};\nexport const BUILDER_KEYS: Record<string, string[]> = {};\nexport const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment> = {};\nexport const NODE_PARENT_VALIDATIONS: Record<string, Validator> = {};\n\nfunction getType(val: any) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\ntype NodeTypesWithoutComment = t.Node[\"type\"] | keyof t.Aliases;\n\ntype NodeTypes = NodeTypesWithoutComment | t.Comment[\"type\"];\n\ntype PrimitiveTypes = ReturnType<typeof getType>;\n\ntype FieldDefinitions = {\n  [x: string]: FieldOptions;\n};\n\ntype DefineTypeOpts = {\n  fields?: FieldDefinitions;\n  visitor?: Array<string>;\n  aliases?: Array<string>;\n  builder?: Array<string>;\n  inherits?: NodeTypes;\n  deprecatedAlias?: string;\n  validate?: Validator;\n};\n\nexport type Validator = (\n  | { type: PrimitiveTypes }\n  | { each: Validator }\n  | { chainOf: Validator[] }\n  | { oneOf: any[] }\n  | { oneOfNodeTypes: NodeTypes[] }\n  | { oneOfNodeOrValueTypes: (NodeTypes | PrimitiveTypes)[] }\n  | { shapeOf: { [x: string]: FieldOptions } }\n  | {}\n) &\n  ((node: t.Node, key: string, val: any) => void);\n\nexport type FieldOptions = {\n  default?: string | number | boolean | [];\n  optional?: boolean;\n  validate?: Validator;\n};\n\nexport function validate(validate: Validator): FieldOptions {\n  return { validate };\n}\n\nexport function typeIs(typeName: NodeTypes | NodeTypes[]) {\n  return typeof typeName === \"string\"\n    ? assertNodeType(typeName)\n    : assertNodeType(...typeName);\n}\n\nexport function validateType(typeName: NodeTypes | NodeTypes[]) {\n  return validate(typeIs(typeName));\n}\n\nexport function validateOptional(validate: Validator): FieldOptions {\n  return { validate, optional: true };\n}\n\nexport function validateOptionalType(\n  typeName: NodeTypes | NodeTypes[],\n): FieldOptions {\n  return { validate: typeIs(typeName), optional: true };\n}\n\nexport function arrayOf(elementType: Validator): Validator {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nexport function arrayOfType(typeName: NodeTypes | NodeTypes[]) {\n  return arrayOf(typeIs(typeName));\n}\n\nexport function validateArrayOfType(typeName: NodeTypes | NodeTypes[]) {\n  return validate(arrayOfType(typeName));\n}\n\nexport function assertEach(callback: Validator): Validator {\n  function validator(node: t.Node, key: string, val: any) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nexport function assertOneOf(...values: Array<any>): Validator {\n  function validate(node: any, key: string, val: any) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          values,\n        )} but got ${JSON.stringify(val)}`,\n      );\n    }\n  }\n\n  validate.oneOf = values;\n\n  return validate;\n}\n\nexport function assertNodeType(...types: NodeTypes[]): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(\n  ...types: (NodeTypes | PrimitiveTypes)[]\n): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    for (const type of types) {\n      if (getType(val) === type || is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nexport function assertValueType(type: PrimitiveTypes): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\n        `Property ${key} expected type of ${type} but got ${getType(val)}`,\n      );\n    }\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nexport function assertShape(shape: { [x: string]: FieldOptions }): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        validateField(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\n        `Property ${key} of ${\n          node.type\n        } expected to have the following:\\n${errors.join(\"\\n\")}`,\n      );\n    }\n  }\n\n  validate.shapeOf = shape;\n\n  return validate;\n}\n\nexport function assertOptionalChainStart(): Validator {\n  function validate(node: t.Node) {\n    let current = node;\n    while (node) {\n      const { type } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\n      `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`,\n    );\n  }\n\n  return validate;\n}\n\nexport function chain(...fns: Array<Validator>): Validator {\n  function validate(...args: Parameters<Validator>) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n\n  if (\n    fns.length >= 2 &&\n    \"type\" in fns[0] &&\n    fns[0].type === \"array\" &&\n    !(\"each\" in fns[1])\n  ) {\n    throw new Error(\n      `An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`,\n    );\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = [\n  \"aliases\",\n  \"builder\",\n  \"deprecatedAlias\",\n  \"fields\",\n  \"inherits\",\n  \"visitor\",\n  \"validate\",\n];\nconst validFieldKeys = [\"default\", \"optional\", \"validate\"];\n\n// Wraps defineType to ensure these aliases are included.\nexport function defineAliasedType(...aliases: string[]) {\n  return (type: string, opts: DefineTypeOpts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      if (opts.inherits) defined = store[opts.inherits].aliases?.slice();\n      defined ??= [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    return defineType(type, opts);\n  };\n}\n\nexport default function defineType(type: string, opts: DefineTypeOpts = {}) {\n  const inherits = (opts.inherits && store[opts.inherits]) || {};\n\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (\n          Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\"\n        ) {\n          throw new Error(\n            \"field defaults can only be primitives or empty arrays currently\",\n          );\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          validate: field.validate,\n        };\n      }\n    }\n  }\n\n  const visitor: Array<string> = opts.visitor || inherits.visitor || [];\n  const aliases: Array<string> = opts.aliases || inherits.aliases || [];\n  const builder: Array<string> =\n    opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type as NodeTypesWithoutComment;\n  }\n\n  // ensure all field keys are represented in `fields`\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type as NodeTypesWithoutComment] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type as NodeTypesWithoutComment);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n\nconst store = {} as Record<string, DefineTypeOpts>;\n"]},"metadata":{},"sourceType":"script"}